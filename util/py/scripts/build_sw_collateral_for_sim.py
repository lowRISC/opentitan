#!/usr/bin/env python3
# Copyright lowRISC contributors (OpenTitan project).
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0
"""Script that invokes Bazel to build and deploy software collateral for a simulation.

MOTIVE
------
Bazel is used to build device software for OpenTitan.
Many different software binaries may be run on or loaded into an OpenTitan
system in simulation, which Bazel Targets are used to define and build.

Bazel rules can output multiple files, and the software collateral that
is actually needed by the simulator may be different depending on configuration,
such as if the binary is scrambled/unscrambled, .vmem or .bin format, etc.
Our rules are designed to build many possible pieces of collateral at once, all
with the same common root filename, but with different suffixes and file extensions
that differentiate their formats and uses.
To 'connect' a particular piece of software collateral with the correct
mechanism to load it into the sim, we append some extra metadata to the Bazel
Label. We refer to this extra data as 'flags'. The first flag is always the
integer 'index', which identifies which device memory system the image should be
loaded into (e.g. ROM, OTP, Flash, etc). The flag "signed" is used to set the SW
image extension correctly. The flag "test_in_rom" is used to indicate a test runs
directly out of ROM instead of flash. There are more possible flags documented below.

A string for each sw image (root filename + index + flags) is also passed through
to the tesbench, which re-parses it (in chip_env_cfg.sv) to extract the index and
flags which determines which piece of collateral should be loaded (by filename)
to which simulated memory model.

ACTIONS
-------
- Loop through the list of 'sw_images' provided (label + flags)
- Build the Bazel Target for each label
- Use Bazel 'cquery' to locate the output files for the target
- Copy the output files to the simulation working directory

DETAILS
-------
The arg `sw_images` is a space-separated list of images required for a test.
Each item in the list may have additional metadata / flags appended using
the delimiter ':'.

Expected format:

  <package>:<target>:<index>:<flag1>:<flag2>:...
  ↑                 ↑
  └──────label──────┘

e.g.

  //sw/device/silicon_creator/manuf/base/binaries:ft_personalize_sival:1:silicon_creator:signed
  ↑                                                                   ↑ ↑               ↑     ↑
  └──────────────────────────────label────────────────────────────────┴─┴─────flag1─────┴flag2┘
                                                                     index

If one delimiter is detected, then the full string is considered to be the
<label> (i.e. package+target).
If two delimiters are detected, then it must be <label> followed by <index>.
All trailing <flags> after the <index> are optional.
Flags have no specific schema, and ordering of flags (after the index) is not significant.
A list 'KNOWN_FLAGS' is maintained in this file to ensure each flag is documented.

After the Bazel Target is built, we use `bazel cquery` to locate the built
software artifacts so they can be copied to the test bench run directory.
We only copy device SW images, and do not copy host-side artifacts (like
opentitantool) that are also dependencies of the Bazel test target.
"""

import argparse
from pathlib import Path
import subprocess
import os
import sys
import shutil
from dataclasses import dataclass, field
from enum import Enum
import textwrap

import logging

logger = logging.getLogger(__name__)

BAZEL_COMMON_CQUERY_FLAGS = ["--ui_event_filters=-info", "--noshow_progress"]

# Query files (passed via --starlark:file)
BAZEL_STARLARK_FILE_DATA_RUNFILES_FILES_QUERY = (
    Path(__file__).parent / "queries" / "DATA_RUNFILES_FILES_QUERY.cquery"
).absolute()
BAZEL_STARLARK_FILE_FILES_QUERY = (
    Path(__file__).parent / "queries" / "FILES_QUERY.cquery"
).absolute()

# The following dict maps rule kinds to the starlark expression required
# to print the files we need to deploy from them.
BAZEL_STARLARK_QUERY_RULE_KIND = {
    "opentitan_test": BAZEL_STARLARK_FILE_DATA_RUNFILES_FILES_QUERY,
    "opentitan_binary": BAZEL_STARLARK_FILE_FILES_QUERY,
    "alias": BAZEL_STARLARK_FILE_FILES_QUERY,
}

ENV = os.environ.copy()

# Keep all flags documented.
KNOWN_FLAGS = [
    # Rules generated by the 'opentitan_test' macro
    "new_rules",
    # Tests that run in ROM instead of Flash
    "test_in_rom",
    # For pre-compiled binaries (i.e. outside of the normal flow)
    "prebuilt",
    # Manually added when instantiating rules to use a flash image built for
    # the `silicon_creator` device. This is used for GLS tests that integrate
    # the ROM macro, which is built for the `silicon_creator` device, not the
    # `sim_dv` device.
    "silicon_creator",
    # Used to mark tests generated by the `opentitan_flash_binary` or `opentitan_binary`
    # Bazel macros directly, instead of the `opentitan_test` macro.
    "ot_flash_binary",
    # If the image builds a signed binary, then this flag should be added to
    # correctly locate the output binary by name.
    "signed",
    # Also used to mark images that build binaries signed with fake keys, to
    # then also correctly locate the output binary by name.
    "fake_ecdsa_dev_key_0",
    "fake_ecdsa_prod_key_0",
    "fake_ecdsa_test_key_0",
    "fake_rsa_dev_key_0",
    "fake_rsa_prod_key_0",
    "fake_rsa_test_key_0",
    # Don't filter out runfiles for other sw_build_devices if this flag is present
    "dont_filter",
]


class sw_type_e(Enum):
    SwTypeROM = 0  # Ibex SW - first stage boot ROM.
    SwTypeTestSlotA = 1  # Ibex SW - test SW in (flash) slot A.
    SwTypeTestSlotB = 2  # Ibex SW - test SW in (flash) slot B.
    SwTypeOTBN = 3  # Otbn SW
    SwTypeOtp = 4  # Customized OTP image
    SwTypeDebug = 5  # Debug SW - injected into SRAM.
    SwTypeCtnRAM = 6  # Ibex SW - test SW in CTN SRAM.
    SwTypeSecondROM = 7  # Ibex SW - second stage boot ROM


class BazelRunner:
    """A collection of functions useful for running Bazel operations."""

    def __init__(self):
        self.cmd = ""
        self.airgapped_opts = []
        self.build_opts = []
        self.cquery_opts_common = BAZEL_COMMON_CQUERY_FLAGS

    def __str__(self):
        s = textwrap.dedent(f"""
        BazelRunner:
          cmd={self.cmd}
          airgapped_opts={self.airgapped_opts}
          build_opts={self.build_opts}
          cquery_common_opts={self.cquery_opts_common}
        """)
        return s

    def build(self, labels: list[str], opts: list[str] = []) -> None:
        build_cmd = (
            self.cmd,
            "build",
            *self.airgapped_opts,
            *self.build_opts,
            *labels,
            *opts,
        )
        logger.info(f"build_cmd = {' '.join(build_cmd)}")
        self._run_cmd(build_cmd)

    def query(self, label: str, opts: list[str]) -> list[str]:
        query_cmd = (
            self.cmd,
            "query",
            *self.airgapped_opts,
            label,
            *opts,
        )
        logger.info(f"query_cmd = {' '.join(query_cmd)}")
        return self._run_cmd(query_cmd)

    def cquery(self, label: str, opts: list[str]) -> list[str]:
        cquery_cmd = (
            self.cmd,
            "cquery",
            *self.airgapped_opts,
            label,
            *self.cquery_opts_common,
            *opts,
        )
        logger.info(f"cquery_cmd = {' '.join(cquery_cmd)}")
        return self._run_cmd(cquery_cmd)

    def _run_cmd(self, cmd: list[str]) -> list[str]:
        """Run a single subprocess command.

        Returns:
            Each (non-empty) line of the stdout as a list of strings.
        """

        cmd = [x for x in cmd if x]  # Remove empty strings
        logger.debug(f"_run_cmd -> cmd:\n{cmd}")

        res = subprocess.run(cmd, capture_output=True, encoding="utf-8", text=True)

        if res.returncode != 0:
            print(res.stdout, flush=True)
            print(res.stderr, flush=True)
            sys.exit(f"_run_cmd -> had a non-zero return code of {res.returncode}.")

        logger.debug(f"_run_cmd -> stdout:\n{res.stdout}")
        logger.debug(f"_run_cmd -> stderr:\n{res.stderr}")

        stdout_lines = res.stdout.split("\n")
        return [s for s in stdout_lines if s]


@dataclass
class ImageString:
    """Parse the custom format used to add metadata to bazel targets for loading in simulation."""

    raw: str
    label: str = field(init=False)
    package: str = field(init=False)
    target: str = field(init=False)
    index: int = field(init=False)
    flags: set[str] = field(init=False)

    def __post_init__(self):
        parts = self.raw.split(":")
        assert len(parts) >= 3, "Image string needs at least label+index at minimum."

        self.package = parts[0]
        self.target = parts[1]
        self.index = int(parts[2])
        self.flags = parts[3:] if len(parts) > 3 else ()
        self.label = f"{self.package}:{self.target}"

        assert all((f in KNOWN_FLAGS) for f in self.flags), "Unknown FLAG used in sw_image"
        logger.debug(f"flags={self}")


@dataclass
class ImageQuery:
    """The metadata for each image required to locate all artifacts after building.

    The ImageQuery.label (runfile query) may be different to the ImageString.label
    (+sw_images input label) as sometimes the query label is modified to append extra metadata
    to locate the correct rule.
    One example of this is if the 'silicon_creator' flag is present, in which case
    '_silicon_creator' is appended to the query label.
    """

    image_string: ImageString
    label: str
    cquery: str
    kind: str


def _deploy_software_collateral(args) -> None:
    """Build, then deploy the software collateral"""

    images_str = "\n".join(args.sw_images)
    logger.info(
        "Building and deploying collateral for the following images:\n"
        "[IMAGES]\n"
        f"{images_str}\n"
        "[RUN_DIR]\n"
        f"{args.run_dir}\n"
    )

    bazel_runner = BazelRunner()

    bazel_runner.cmd = "./bazelisk.sh"
    bazel_runner.build_opts = args.sw_build_opts + [
        "--define",
        "DISABLE_VERILATOR_BUILD=true",
    ]

    # In the air-gapped environment, the following environment variable will exist.
    if ENV.get("BAZEL_PYTHON_WHEELS_REPO"):
        # We need to change our bazel invocation as follows when running air-gapped.
        bazel_runner.cmd = "bazel"
        bazel_runner.airgapped_opts = [
            "--define",
            "SPECIFY_BINDGEN_LIBSTDCXX=true",
            f"--distdir={ENV.get('BAZEL_DISTDIR')}",
            f"--repository_cache={ENV.get('BAZEL_CACHE')}",
        ]

    # Export this environment variable to build with a non-default OTP permuation
    if ENV.get("BAZEL_OTP_DATA_PERM_FLAG"):
        bazel_runner.build_opts += [
            f"--//util/design/data:data_perm={ENV.get('BAZEL_OTP_DATA_PERM_FLAG')}",
        ]

    # If build_seed is provided, feed this value into bazel when building the OTP pre-load images.
    # This overrides the default seed value and is needed for reproducibility to match the
    # synthesized hardware from the 'build' stage. (sw build happens in the 'run' stage)
    if args.build_seed != "None":
        bazel_runner.build_opts += [
            f"--//hw/ip/otp_ctrl/data:lc_seed={args.build_seed}",
            f"--//hw/ip/otp_ctrl/data:otp_seed={args.build_seed}",
        ]

    # Print a summary of the accumulated bazel_runner configuration that we will use to
    # assemble all further bazel operations.
    logger.info(bazel_runner)

    # Determine the final label and cquery expression to build and get the
    # artifacts for each image.
    image_query_set = {}
    for image in args.sw_images:
        image_string = ImageString(image)

        if sw_type_e(image_string.index) in (
            sw_type_e.SwTypeROM,
            sw_type_e.SwTypeTestSlotA,
            sw_type_e.SwTypeTestSlotB,
            sw_type_e.SwTypeCtnRAM,
            sw_type_e.SwTypeSecondROM,
            sw_type_e.SwTypeOTBN,
        ):
            if "silicon_creator" in image_string.flags:
                # Add the flag `silicon_creator` when using a flash image built
                # for the `silicon_creator` device.
                # This is used for GLS tests that integrate the ROM macro, which
                # is built for the `silicon_creator` device, not the `sim_dv` device.
                #
                # Currently, the '_silicon_creator' suffix is added manually when
                # instantiating rules.
                label = f"{image_string.label}_silicon_creator"
            else:
                # If test type is `opentitan_test` and the flash image was generated
                # by the `opentitan_test` Bazel macro itself, or it was generated
                # by the `opentitan_flash_binary` or `opentitan_binary` Bazel macros,
                # then we need to append the device suffix.
                label = f"{image_string.label}_{args.sw_build_device}"

            # For this type of image, relevant files may be present in both the 'data'
            # and 'srcs' attributes of the target. Query for both.
            cquery = f"labels(data, {label}) union labels(srcs, {label})"

        else:
            # For all other values of sw_type_e, the label/query is just the label
            # passed as input (minus all trailing flags).
            label = image_string.label
            cquery = image_string.label

        # Query to determine what 'kind' the target is
        kind_query = bazel_runner.cquery(label, ["--output=label_kind"])
        kind = kind_query[0].split(" ")[0]

        # Add a query object to the set for this image
        image_query_set[image] = ImageQuery(image_string, label, cquery, kind)

    logger.info("Image query parameters determined.\n")

    # Build all the software artifacts
    bazel_labels = (v.label for v in image_query_set.values())
    logger.info("Building all labels...")
    bazel_runner.build(bazel_labels)
    logger.info("All labels built.\n")

    # Now the build is complete, deploy the files for each target
    for image in args.sw_images:
        logger.info(f"Querying runfiles for image : {image}")

        iq = image_query_set[image]

        # First, run the query to get the maximal set of runfiles for the image
        runfiles = _get_image_runfiles(iq, bazel_runner)

        # Some rules may return runfiles for many different software devices, but
        # we only require the files for a specific device (passed by --sw-build-device)
        # Our bazel rules always append the device as the final element of the filename
        # before any extensions (the final string fragment before the first period)
        # Perform a crude string-contains check to determine if this is one of those rules,
        # and if so, remove files unrelated to this device
        dev = args.sw_build_device

        def _f_endswith_dev(f: Path) -> bool:
            f_stem = str(f).split(".")[0]
            return f_stem.endswith(dev)

        is_device_specific = any([_f_endswith_dev(Path(f)) for f in runfiles])
        if is_device_specific and ("dont_filter" not in iq.image_string.flags):
            logger.info(
                f"This query returned device_specific '{dev}' files, filtering "
                "out runfiles for other devices..."
            )
            runfiles = list(filter(lambda f: _f_endswith_dev(Path(f)), runfiles))

        # Now copy any runfiles for this image to the test's working directory so they
        # can be accessed easily via relative path.
        _copy_files_to_run_dir(runfiles, args.run_dir)
        runfiles_str = "\n".join(runfiles)
        logger.info(
            f"Deployed the following collateral:\n[IMAGE]\n{image}\n[FILES]\n{runfiles_str}\n"
        )


def _get_image_runfiles(iq: ImageQuery, bazel_runner: BazelRunner) -> list[str]:
    """Run the target/kind-specific Bazel queries to get the runfiles list for this image."""

    if logger.level <= logging.INFO:
        location_query = bazel_runner.query(iq.label, ["--output=location"])
        location = location_query[0].split(" ")[0]
        logger.info(f"bazel target location: {location}")

    # Depending on the target 'kind', we may need to query differently to get the
    # path inside the bazel build hierarchy to the build results, and also to filter
    # the query only for targets / files which are strictly necessary for simulation.
    # _Note_
    # We may also want to extract collateral to assist debug and development, such as
    # disassembly files for given binaries.
    runfiles: list[str] = []

    logger.info(f"kind = {iq.kind}")
    if iq.kind in ("opentitan_test", "opentitan_binary", "alias"):
        # For targets of this kind, we can query directly for the set of runfiles.
        # The query may have a slightly different starlark expression to extract the
        # files from the target depending on the kind.

        runfiles = bazel_runner.cquery(
            label=iq.label,
            opts=[
                "--output=starlark",
                f"--starlark:file={BAZEL_STARLARK_QUERY_RULE_KIND[iq.kind]}",
            ],
        )

    else:
        # For all other kinds, we have to do two queries to reach the runfiles. The first
        # query may return a list of labels from the rule's attributes (e.g. data, srcs),
        # which we tidy up and filter out targets which we know will return unused dependencies.
        deps = bazel_runner.cquery(
            label=f"{iq.cquery}",
            opts=[
                "--output=starlark",
            ],
        )

        # Bazel 6 cquery outputs repository targets in canonical format (@//blabla)
        # whereas bazel 5 does not, so strip leading @ if present.
        deps = [dep.lstrip("@") for dep in deps]
        logger.info(f"deps = {deps}")

        for label in deps:
            if any(
                [
                    # - OTP preload images are copied
                    label.startswith("//hw/top_*/ip_autogen/otp_ctrl/data"),
                    # - Any deps from the following directories/packages are _not_ copied:
                    #   - hw/
                    #   - util/
                    #   - sw/host/
                    (not any(label.startswith(s) for s in ("//hw", "//util", "//sw/host"))),
                ]
            ):
                runfiles += bazel_runner.cquery(
                    label,
                    [
                        "--output=starlark",
                        f"--starlark:file={BAZEL_STARLARK_FILE_FILES_QUERY}",
                    ],
                )

    return runfiles


def _copy_files_to_run_dir(files: list[str], run_dir: Path) -> None:
    """Copy all target artifacts to the run directory.

    If the artifact is a .bin, and a .elf file of the same name also exists,
    also copy the equivalent .elf file.
    """

    for f in [Path(f) for f in files]:
        shutil.copyfile(f, run_dir / f.name)
        # If we are copying a .bin file, and the corresponding .elf file exists, also copy that
        maybe_elf = f.with_suffix(".elf")
        if f.suffix == "bin" and maybe_elf.exists():
            shutil.copy(maybe_elf, run_dir)


def _main() -> None:
    def _space_sep_str(value):
        return list(filter(None, value.split(" ")))

    def _int_or_str(value):
        try:
            return int(value)
        except Exception:
            return value

    mod_doc = sys.modules[__name__].__doc__
    parser = argparse.ArgumentParser(
        # Use the module description to generate CLI --help docs
        description=(mod_doc.split("\n")[0]),
        epilog=(80 * "-" + f"\n\n{mod_doc}"),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--sw-images",
        type=_space_sep_str,
        default=[],
        help="Bazel label + additional metadata to describe the needed sw collateral",
    )
    parser.add_argument(
        "--sw-build-opts",
        type=_space_sep_str,
        default=[],
        help="Additional opts to be passed while building software",
    )
    parser.add_argument("--sw-build-device", type=str, help="")
    parser.add_argument("--seed", type=int, help="Seed")
    parser.add_argument("--build-seed", type=_int_or_str, help="Build Seed")
    parser.add_argument(
        "--run-dir",
        type=Path,
        help="Run directory where the software artifacts should be deployed to",
    )
    args = parser.parse_args()

    log_level = logging.INFO
    log_format = "%(levelname)s: [%(filename)s:%(lineno)d] %(message)s"
    logging.basicConfig(level=log_level, format=log_format)

    # Generate string of script arguments
    def _mk_argstr(args) -> str:
        argstr = ""
        for arg, argval in sorted(vars(args).items()):
            if argval:
                if not isinstance(argval, list):
                    argval = [argval]
                for a in argval:
                    argname = "-".join(arg.split("_"))
                    # Get absolute paths for all files specified.
                    a = a.resolve() if isinstance(a, Path) else a
                    argstr += " \\\n//   --" + argname + " " + str(a) + ""
        return argstr

    # Log the script name and invocation arguments
    logger.info(f"\n// {sys.argv[0]} {_mk_argstr(args)}\n")

    _deploy_software_collateral(args)


if __name__ == "__main__":
    sys.exit(_main())
