// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
<%
import textwrap
%>\
${helper.file_header.render()}
// This file was generated automatically.
// Please do not modify content of this file directly.
// File generated by using template: "toplevel_memory.rs.tpl"
// To regenerate this file follow OpenTitan topgen documentations.

#![allow(dead_code)]

//! Rust Top-Specific Definitions.
//!
//! This file contains const definitions for use within Rust code.

% for name, region in helper.memories():
<%
    hex_base_addr = "0x{:X}".format(region.base_addr)
    hex_size_bytes = "0x{:X}".format(region.size_bytes)

    base_addr_name = region.base_addr_name().as_c_define()
    size_bytes_name = region.size_bytes_name().as_c_define()

%>\
/// Memory base address for ${name} in top ${top["name"]}.
pub const TOP_${top["name"].upper()}_${base_addr_name}: usize = ${hex_base_addr};

/// Memory size for ${name} in top ${top["name"]}.
pub const TOP_${top["name"].upper()}_${size_bytes_name}: usize = ${hex_size_bytes};

## TODO: we need a more holistic approach to declare memories and IPs sitting in the
## CTN address space. For now, we create the base and offset for the CTN SRAM with this workaround.
% if name == "ctn":
<%
    hex_base_addr = "0x{:X}".format(region.base_addr + 0x01000000)
    hex_size_bytes = "0x{:X}".format(0x00100000)

    base_addr_name = region.base_addr_name().as_c_define().replace('CTN', 'RAM_CTN')
    size_bytes_name = region.size_bytes_name().as_c_define().replace('CTN', 'RAM_CTN')

%>\
/// Memory base address for ram_ctn in top ${top["name"]}.
pub const TOP_${top["name"].upper()}_${base_addr_name}: usize = ${hex_base_addr};

/// Memory size for ram_ctn in top ${top["name"]}.
pub const TOP_${top["name"].upper()}_${size_bytes_name}: usize = ${hex_size_bytes};
% endif
% endfor
% for (inst_name, if_name), region in helper.devices():
<%
    if_desc = inst_name if if_name is None else '{} device on {}'.format(if_name, inst_name)
    hex_base_addr = "0x{:X}".format(region.base_addr)
    hex_size_bytes = "0x{:X}".format(region.size_bytes)

    base_addr_name = region.base_addr_name().as_c_define()
    size_bytes_name = region.size_bytes_name().as_c_define()
%>\
/// Peripheral base address for ${if_desc} in top ${top["name"]}.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const ${base_addr_name}: usize = ${hex_base_addr};

/// Peripheral size for ${if_desc} in top ${top["name"]}.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #${base_addr_name} and
/// `${base_addr_name} + ${size_bytes_name}`.
pub const ${size_bytes_name}: usize = ${hex_size_bytes};
% endfor

% for (subspace_name, description, subspace_range) in helper.subranges:
/// ${subspace_name.upper()} Region
///
% for l in textwrap.wrap(description, 76, break_long_words=False):
/// ${l}
% endfor
pub const ${subspace_range.base_addr_name().as_c_define()}: usize = ${"0x{:X}".format(subspace_range.base_addr)};
pub const ${subspace_range.size_bytes_name().as_c_define()}: usize = ${"0x{:X}".format(subspace_range.size_bytes)};
% endfor
