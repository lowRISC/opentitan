// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// xbar_cover.cfg generated by `tlgen.py` tool
<%
  import math
  import tlgen.lib as lib

  num_hosts = len(xbar.hosts)
  if num_hosts > 1:
    host_unr_source_bits = math.ceil(math.log2(num_hosts))
  else:
    host_unr_source_bits = 0
  # TODO: Add support for multiple ASIDs within an xbar.
  addr_space = sorted(xbar.hosts[0].addr_spaces)[0]
%>\

+tree tb.dut
-module pins_if     // DV construct.
-module clk_rst_if  // DV construct.

-assert legalAOpcodeErr_A
-assert sizeGTEMaskErr_A
-assert sizeMatchesMaskErr_A
-assert addrSizeAlignedErr_A

// due to VCS issue (fixed at VCS/2020.12), can't move this part into begin...end (tgl) or after.
-node tb.dut tl_*.a_param
-node tb.dut tl_*.d_param
-node tb.dut tl_*.d_opcode[2:1]

-moduletree prim_cdc_rand_delay  // exclude DV construct.

// [UNR] these device address bits are always 0
% for device in xbar.devices:
<%
    addr_range = device.addr_ranges[addr_space]
    excl_bits = lib.get_toggle_excl_bits(addr_range)

    esc_name = device.name.replace('.', '__')
%>\
  % for bit_range in excl_bits:
-node tb.dut tl_${esc_name}_o.a_address[${bit_range[1]}:${bit_range[0]}]
  % endfor
% endfor

% if host_unr_source_bits > 0:
-node tb.dut tl_*.a_source[7:${8 - host_unr_source_bits}]
-node tb.dut tl_*.d_source[7:${8 - host_unr_source_bits}]
% endif
begin tgl
  -tree tb
  +tree tb.dut 1
  -node tb.dut.scanmode_i
end
