#!/usr/bin/env python3

# Copyright lowRISC contributors (OpenTitan project).
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

"""Instrument each basic blocks in the asm files."""

import argparse
import copy
import difflib
import os

from pathlib import Path
from typing import List

from util.coverage.asm.basic_block import (
    Block,
    apply_block_counter,
    flatten_blocks,
    propagate_counter,
    run_analyze_pipeline,
)
from util.coverage.asm.parser import (
    Statement,
    StmtType,
    run_parsing_pipeline,
)


def remove_autogen_markers(statements: List[Statement]) -> List[Statement]:
    """Removes autogenerated counter markers from a list of statements.

    Args:
        statements: A list of `Statement` objects.

    Returns:
        A new list of `Statement` objects with autogen markers removed.
    """
    return [s for s in statements if s.mnemonic != 'COVERAGE_ASM_AUTOGEN_MARK']


def add_autogen_markers(blocks: List[Block]) -> List[Block]:
    """Adds autogenerated counter markers to a list of basic blocks.

    This function iterates through the basic blocks and inserts
    `COVERAGE_ASM_AUTOGEN_MARK` statements where necessary to
    instrument code for coverage.

    Args:
        blocks: A list of `Block` objects.

    Returns:
        A new list of `Block` objects with autogen markers added.
    """
    blocks = copy.deepcopy(blocks)
    autogen_enabled: bool = False

    for block in blocks:
        # Insert autogen marker if there's no counter
        if block.counter is None:
            insert_idx: int = 0

            # Check for autogen start pragma
            if not autogen_enabled:
                for stmt in block.statements:
                    insert_idx += 1
                    if stmt.type == StmtType.PRAGMA:
                        if stmt.mnemonic == 'autogen' and stmt.args == 'start':
                            autogen_enabled = True
                            break

            # Skip the block when disabled
            if not autogen_enabled:
                continue

            # Check if the block only contains comments.
            if not all(stmt.is_comment for stmt in block.statements):
                # Insert after label and comments
                for stmt in block.statements[insert_idx:]:
                    if stmt.is_comment or stmt.type == StmtType.LABEL:
                        insert_idx += 1
                    else:
                        break

                # Insert a placeholder counter
                block.statements.insert(
                    insert_idx,
                    Statement(
                        mnemonic='COVERAGE_ASM_AUTOGEN_MARK',
                        args='t6,-1',
                        raw='  COVERAGE_ASM_AUTOGEN_MARK(t6,-1)\n',
                        lineno=-1,
                        colno=-1,
                        type=StmtType.COUNTER,
                    ),
                )

        # Update the final autogen status
        for stmt in block.statements:
            if stmt.type == StmtType.PRAGMA and stmt.mnemonic == 'autogen':
                if stmt.args == 'stop':
                    autogen_enabled = False
                elif stmt.args == 'start':
                    autogen_enabled = True
                else:
                    raise ValueError(f'Unknown autogen pragma: {stmt.mnemonic}')

    return blocks


def renumber_counter_id(blocks: List[Block]) -> List[Block]:
    """Renumber all counter statements, starting from zero.

    Args:
        blocks: A list of `Block` objects.

    Returns:
        A new list of `Block` objects with renumbered counter statements.
    """
    blocks = copy.deepcopy(blocks)
    current_id: int = 0

    for block in blocks:
        for stmt in block.statements:
            if stmt.type == StmtType.COUNTER:
                reg = stmt.args.split(',', 1)[0]
                stmt.args = f'{reg},{current_id}'
                indent = len(stmt.raw) - len(stmt.raw.lstrip(' '))
                stmt.raw = f'{" " * indent}{stmt.mnemonic}({stmt.args})\n'
                current_id += 1

    return blocks


def print_diff(path, fromtext, totext):
    diff = difflib.unified_diff(
        fromtext.splitlines(keepends=True),
        totext.splitlines(keepends=True),
        fromfile=str(path),
        tofile=str(path),
    )
    for line in diff:
        print(line, end='')


def main(args: argparse.Namespace) -> None:
    check_result: bool = True

    for path in args.files:
        code = path.read_text()

        # Syntax preprocess and tokenization
        statements: List[Statement] = run_parsing_pipeline(code)

        # Cleanup old autogen markers
        statements = remove_autogen_markers(statements)

        # Analyze code
        blocks: List[Block] = run_analyze_pipeline(statements)

        if not args.clear:
            # Create new autogen markers
            blocks = add_autogen_markers(blocks)
            blocks = renumber_counter_id(blocks)
            blocks = apply_block_counter(blocks)
            blocks = propagate_counter(blocks)

        statements = flatten_blocks(blocks)
        instrumented_code = ''.join(stmt.raw for stmt in statements)

        # Show results
        if args.check:
            if instrumented_code != code:
                print_diff(path, code, instrumented_code)
                check_result = False
        else:
            print('#' * 10, f'{path}', '#' * 10)
            for block in blocks:
                block.pretty_print()

        # Save results
        if args.clear or args.apply:
            with open(path, 'w') as f:
                f.write(instrumented_code)

    if args.check and not check_result:
        print()
        print('Please update the asm instrumentation with:')
        print('$ ./util/coverage/asm/run_instrument.sh --apply')
        exit(-1)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Instrument asm files annotated with coverage pragma.'
    )
    parser.add_argument(
        '--files',
        type=Path,
        nargs='+',
        required=True,
        metavar='FILE',
        help='Files to instrument.',
    )

    mode_group = parser.add_mutually_exclusive_group(required=True)
    mode_group.add_argument(
        '--check',
        action='store_true',
        help='Check if the instrumented code is up-to-date.',
    )
    mode_group.add_argument(
        '--dryrun', action='store_true',
        help='Show the instrumented code without saving.'
    )
    mode_group.add_argument(
        '--clear',
        action='store_true',
        help='Remove all autogen instrumentations.',
    )
    mode_group.add_argument(
        '--apply',
        action='store_true',
        help='Apply the instrumentation changes inplace.',
    )

    args = parser.parse_args()

    # Resolve paths relative to the workspace root
    root = Path(os.environ['BUILD_WORKSPACE_DIRECTORY'])
    args.files = [root / path for path in args.files]

    main(args)
