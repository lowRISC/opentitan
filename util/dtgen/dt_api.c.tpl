// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Device table API auto-generated by `dtgen`
<%
from topgen.lib import Name, is_top_reggen, is_ipgen

module_types = {m["type"] for m in top["module"]}
module_types = sorted(module_types)
top_name = Name(["top", top["name"]])
irq_base_name = top_name + Name(["plic", "irq", "id"])
top_clock_prefix = Name(["dt", "clock"])

def snake_to_constant_name(s):
    return Name.from_snake_case(s).as_c_enum()
%>\


#include "dt/dt_api.h"
#include "hw/top_${top["name"]}/sw/autogen/top_${top["name"]}.h"
#include <stdint.h>

<%
    dev_prefix = Name(["dt", "instance", "id"])
    irq_prefix = Name(["top", top["name"], "plic", "irq", "id"])
    none_irq_name = irq_prefix + Name(["None"])
    unknown_peripheral_name = dev_prefix + Name(["unknown"])
    irq_table = {none_irq_name: unknown_peripheral_name}
    if False:
        for module_name, irqs in helper.device_irqs.items():
            dev_name = Name.from_snake_case(module_name)
            module_type = [m for m in top["module"] if m["name"] == module_name]
            assert len(module_type) == 1
            for irq in irqs:
                irq_name = irq_prefix + Name.from_snake_case(irq)
                irq_table[irq_name] = dev_prefix + dev_name
                print("{} -> {}".format(irq_name, dev_prefix + dev_name))

    for intr in top["interrupt"]:
        width = int(intr["width"])
        for i in range(width):
            name = Name.from_snake_case(intr["name"])
            if width > 1:
              name += Name([str(i)])
            module_name = Name.from_snake_case(intr["module_name"])
            irq_table[irq_prefix + name] = dev_prefix + module_name
%>\

enum {
  kDtIrqIdCount = ${str(len(irq_table.keys()))},
};

static const dt_instance_id_t instance_from_irq[kDtIrqIdCount] = {
% for irq, device_id in irq_table.items():
    [${irq.as_c_enum()}] = ${device_id.as_c_enum()},
% endfor
};

dt_instance_id_t dt_plic_id_to_instance_id(dt_plic_irq_id_t irq) {
  if (irq < (dt_plic_irq_id_t)kDtIrqIdCount) {
    return instance_from_irq[irq];
  }
  return kDtInstanceIdUnknown;
}

static const dt_device_type_t device_type[kDtInstanceIdCount] = {
% for module_name in module_types:
<%
    modules = [m for m in top["module"] if m["type"] == module_name]
%>\
%   for (dev_index, m) in enumerate(modules):
  [${snake_to_constant_name("dt_instance_id_" + m["name"])}] = ${snake_to_constant_name("dt_device_type_" + m["type"])},
%   endfor
% endfor
};

static const dt_device_type_t instance_index[kDtInstanceIdCount] = {
% for module_name in module_types:
<%
    modules = [m for m in top["module"] if m["type"] == module_name]
%>\
%   for (dev_index, m) in enumerate(modules):
  [${snake_to_constant_name("dt_instance_id_" + m["name"])}] = ${dev_index},
%   endfor
% endfor
};

dt_device_type_t dt_device_type(dt_instance_id_t dev) {
  if (dev < kDtInstanceIdCount) {
    return device_type[dev];
  }
  return kDtDeviceTypeUnknown;
}

size_t dt_instance_index(dt_instance_id_t dev) {
  if (dev < kDtInstanceIdCount) {
    return instance_index[dev];
  }
  return 0;
}

<%
    # List all muxed pads directly from the top.
    pads = {pad["name"]: pad for pad in top['pinout']['pads'] if pad['connection'] == 'muxed'}

    # List direct pads from the pinmux to avoid pins which are not relevant.
    for pad in top['pinmux']['ios']:
        if pad['connection'] == 'muxed':
            continue
        name = pad['name']
        if pad['width'] > 1:
            name += str(pad['idx'])
        pads[name] = pad
%>\
/**
 * Pad description.
 *
 * A `dt_pad_t` represents a chip's physical pad.
 */
typedef struct dt_pad_desc {
  /** Pad type */
  dt_pad_type_t type;
  /** For `kDtPadTypeMio` pads: MIO out number. This is the index of the MIO_OUTSEL register
    * that controls this pad (or the output part of this pad).
    *
    * For `kDtPadTypeDio`:  DIO pad number. This is the index of the various DIO_PAD_* registers
    * that control this pad.
    */
  uint16_t mio_out_or_direct_pad;
  /** For `kDtPadTypeMio` pads: MIO pad number. This is the value to put in the MIO_PERIPH_INSEL
    * registers to connect a peripheral to this pad.
    */
  uint16_t insel;
} dt_pad_desc_t;

// Pad descriptions.
static const dt_pad_desc_t dt_pad[kDtPadCount] = {
% for (padname, pad) in pads.items():
<%
    if pad["connection"] == "muxed":
        pad_type = "Mio"
        pad_mio_out_or_direct_pad = "0"
        pad_insel = "0"
        if pad["port_type"] in ["input", "inout"]:
            pad_mio_out_or_direct_pad = snake_to_constant_name("top_{}_pinmux_mio_out_{}".format(top["name"], padname))
        if pad["port_type"] in ["output", "inout"]:
            pad_insel = snake_to_constant_name("top_{}_pinmux_insel_{}".format(top["name"], padname))
    elif pad["connection"] == "direct":
        pad_type = "Dio"
        pad_mio_out_or_direct_pad = snake_to_constant_name("top_{}_direct_pads_{}".format(top["name"], padname))
        pad_insel = "0"
    else:
        assert pad["connection"] == "manual", "unexpected connection type '{}'".format(pad["connection"])
        pad_mio_out_or_direct_pad = "0"
        pad_insel = "0"
        pad_type = "Unspecified"
%>\
  [${snake_to_constant_name("dt_pad_" + padname)}] = {
    .type = kDtPadType${pad_type},
    .mio_out_or_direct_pad = ${pad_mio_out_or_direct_pad},
    .insel = ${pad_insel},
  },
% endfor
};

<%
  invalid_pad_check = "pad < (dt_pad_t)0 || pad >= kDtPadCount"
%>

dt_pad_type_t dt_pad_type(dt_pad_t pad) {
  if(${invalid_pad_check}) {
    return kDtPadTypeUnspecified;
  }
  return dt_pad[pad].type;
}

dt_pinmux_mio_out_t dt_pad_mio_out(dt_pad_t pad) {
  if(${invalid_pad_check}) {
    return (dt_pinmux_mio_out_t)0;
  }
  return (dt_pinmux_mio_out_t)dt_pad[pad].mio_out_or_direct_pad;
}

dt_pinmux_muxed_pad_t dt_pad_mio_pad(dt_pad_t pad) {
  if(${invalid_pad_check}) {
    return (dt_pinmux_muxed_pad_t)0;
  }
  // Same index as MIO_OUT.
  return (dt_pinmux_muxed_pad_t)dt_pad_mio_out(pad);
}

dt_pinmux_insel_t dt_pad_mio_insel(dt_pad_t pad) {
  if(${invalid_pad_check}) {
    return (dt_pinmux_insel_t)0;
  }
  return (dt_pinmux_insel_t)dt_pad[pad].insel;
}

dt_pinmux_direct_pad_t dt_pad_dio_pad(dt_pad_t pad) {
  if(${invalid_pad_check}) {
    return (dt_pinmux_direct_pad_t)0;
  }
  return (dt_pinmux_direct_pad_t)dt_pad[pad].mio_out_or_direct_pad;
}

/* Pin that is constantly tied to high-Z (input only) */
const dt_periph_io_t kDtPeriphIoConstantHighZ = {
  .__internal = {
    .type = kDtPeriphIoTypeMio,
    .periph_input_or_direct_pad = 0,
    .outsel = kDtPinmuxOutselConstantHighZ,
  }
};

/* Pin that is constantly tied to zero (input/output) */
const dt_periph_io_t kDtPeriphIoConstantZero = {
  .__internal = {
    .type = kDtPeriphIoTypeMio,
    .periph_input_or_direct_pad = 0,
    .outsel = kDtPinmuxOutselConstantZero,
  }
};

/* Pin that is constantly tied to one (input/output) */
const dt_periph_io_t kDtPeriphIoConstantOne = {
  .__internal = {
    .type = kDtPeriphIoTypeMio,
    .periph_input_or_direct_pad = 0,
    .outsel = kDtPinmuxOutselConstantOne,
  }
};
