// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Device table API auto-generated by `dtgen`
<%
from topgen.lib import Name, is_top_reggen, is_ipgen
%>

/**
 * @file
 * @brief Device Tables (DT) API for top ${helper.top["name"]}
 */

#include "dt/dt_api.h"
#include "hw/top_${helper.top["name"]}/sw/autogen/top_${helper.top["name"]}.h"
#include <stdint.h>

<%
  top_plic_irq_id_name = Name.from_snake_case("top_" + helper.top["name"] + "_plic_irq_id")
  top_plic_irq_id_last = top_plic_irq_id_name + Name(["last"])
  top_plic_irq_id_count = top_plic_irq_id_name + Name(["count"])
%>
enum {
  ${top_plic_irq_id_count.as_c_enum()} = ${top_plic_irq_id_last.as_c_enum()} + 1,
};

static const ${helper.inst_from_irq_map.render_var_def(Name.from_snake_case("instance_from_irq"), helper.inst_from_irq_values)}

dt_instance_id_t dt_plic_id_to_instance_id(dt_plic_irq_id_t irq) {
  if (irq <= ${top_plic_irq_id_last.as_c_enum()}) {
    return instance_from_irq[irq];
  }
  return kDtInstanceIdUnknown;
}

% if helper.has_alert_handler():
<%
  top_alert_id_name = Name.from_snake_case("top_" + helper.top["name"] + "_alert_id")
  top_alert_id_last = top_alert_id_name + Name(["last"])
  top_alert_id_count = top_alert_id_name + Name(["count"])
%>
enum {
  ${top_alert_id_count.as_c_enum()} = ${top_alert_id_last.as_c_enum()} + 1,
};

static const ${helper.inst_from_alert_map.render_var_def(Name.from_snake_case("instance_from_alert"), helper.inst_from_alert_values)}

dt_instance_id_t dt_alert_id_to_instance_id(dt_alert_id_t alert) {
  if (alert <= ${top_alert_id_last.as_c_enum()}) {
    return instance_from_alert[alert];
  }
  return kDtInstanceIdUnknown;
}

%endif
static const ${helper.dev_type_map.render_var_def(Name.from_snake_case("device_type"), helper.dev_type_values)}

dt_device_type_t dt_device_type(dt_instance_id_t dev) {
  if (dev < kDtInstanceIdCount) {
    return device_type[dev];
  }
  return kDtDeviceTypeUnknown;
}

/**
 * Pad description.
 *
 * A `dt_pad_t` represents a chip's physical pad.
 */
${helper.pad_struct.render_type_def()}

<%
  dt_pad_array_name = Name.from_snake_case("dt_pad")
%>
// Pad descriptions.
static const ${helper.pad_dt_map.render_var_def(dt_pad_array_name, helper.pad_dt_values)}

<%
  invalid_pad_check = "pad < (dt_pad_t)0 || pad >= kDtPadCount"
%>

#define TRY_GET_PAD(pad, default) \
  ({ \
    if ((pad) < (dt_pad_t)0 || (pad) >= kDtPadCount) \
      return (default); \
    &dt_pad[pad]; \
  })

dt_pad_type_t dt_pad_type(dt_pad_t pad) {
  return TRY_GET_PAD(pad, kDtPadTypeUnspecified)->type;
}

dt_pinmux_mio_out_t dt_pad_mio_out(dt_pad_t pad) {
  return (dt_pinmux_mio_out_t)TRY_GET_PAD(pad, 0)->mio_out_or_direct_pad;
}

dt_pinmux_muxed_pad_t dt_pad_mio_pad_index(dt_pad_t pad) {
  // Same index as MIO_OUT.
  return (dt_pinmux_muxed_pad_t)dt_pad_mio_out(pad);
}

dt_pinmux_insel_t dt_pad_mio_insel(dt_pad_t pad) {
  return (dt_pinmux_insel_t)TRY_GET_PAD(pad, 0)->insel;
}

dt_pinmux_direct_pad_t dt_pad_dio_pad_index(dt_pad_t pad) {
  return (dt_pinmux_direct_pad_t)TRY_GET_PAD(pad, 0)->mio_out_or_direct_pad;
}

/* Pin that is constantly tied to high-Z (input only) */
const dt_periph_io_t kDtPeriphIoConstantHighZ = {
  .__internal = {
    .type = kDtPeriphIoTypeMio,
    .periph_input_or_direct_pad = 0,
    .outsel_or_dt_pad = kDtPinmuxOutselConstantHighZ,
  }
};

/* Pin that is constantly tied to zero (input/output) */
const dt_periph_io_t kDtPeriphIoConstantZero = {
  .__internal = {
    .type = kDtPeriphIoTypeMio,
    .periph_input_or_direct_pad = 0,
    .outsel_or_dt_pad = kDtPinmuxOutselConstantZero,
  }
};

/* Pin that is constantly tied to one (input/output) */
const dt_periph_io_t kDtPeriphIoConstantOne = {
  .__internal = {
    .type = kDtPeriphIoTypeMio,
    .periph_input_or_direct_pad = 0,
    .outsel_or_dt_pad = kDtPinmuxOutselConstantOne,
  }
};
