// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Device table API auto-generated by `dtgen`
<%
from basegen.lib import Name
from dtgen.helper import Extension

device_name = helper.ip.name
top_name = helper.top["name"]
%>\

/**
 * @file
 * @brief Device Tables (DT) for IP ${device_name} and top ${top_name}.
 */

#include "hw/top/dt/dt_${device_name}.h"

## Extension
${helper.render_extension(Extension.DtIpPos.SourceIncludes)}

/**
 * Description of instances.
 */
${helper.inst_struct.render_type_def()}

<%
  dt_array_name = helper.ip_name + Name(["desc"])
  dt_array = dt_array_name.as_snake_case()
  dt_array_count = helper.inst_enum.name + Name(["count"])
%>

static const ${helper.inst_dt_map.render_var_def(dt_array_name, helper.inst_dt_values)}

/**
 * Return a pointer to the `dt_${device_name}_desc_t` structure of the requested
 * `dt` if it's a valid index. Otherwise, this macro will `return` (i.e. exit
 * the function) with the provided default value.
 */
#define TRY_GET_DT(dt, default) \
  ({ \
    if ((dt) < (dt_${device_name}_t)0 || (dt) >= ${dt_array_count.as_c_enum()}) \
      return (default); \
    &${dt_array}[dt]; \
  })

dt_${device_name}_t dt_${device_name}_from_instance_id(dt_instance_id_t inst_id) {
% if helper.first_inst_id:
  if (inst_id >= ${helper.first_inst_id.as_c_enum()} && inst_id <= ${helper.last_inst_id.as_c_enum()}) {
    return (dt_${device_name}_t)(inst_id - ${helper.first_inst_id.as_c_enum()});
  }
% endif
  return (dt_${device_name}_t)0;
}

dt_instance_id_t dt_${device_name}_instance_id(
    dt_${device_name}_t dt) {
  return TRY_GET_DT(dt, kDtInstanceIdUnknown)->inst_id;
}

% if helper.has_reg_blocks():
uint32_t dt_${device_name}_reg_block(
    dt_${device_name}_t dt,
    dt_${device_name}_reg_block_t reg_block) {
  // Return a recognizable address in case of wrong argument.
  return TRY_GET_DT(dt, 0xdeadbeef)->reg_addr[reg_block];
}

% endif
uint32_t dt_${device_name}_memory_base(
    dt_${device_name}_t dt,
    dt_${device_name}_memory_t mem) {
  // Return a recognizable address in case of wrong argument.
  return TRY_GET_DT(dt, 0xdeadbeef)->mem_addr[mem];
}

uint32_t dt_${device_name}_memory_size(
    dt_${device_name}_t dt,
    dt_${device_name}_memory_t mem)  {
  // Return an empty size in case of wrong argument.
  return TRY_GET_DT(dt, 0)->mem_size[mem];
}

% if helper.has_irqs():
dt_plic_irq_id_t dt_${device_name}_irq_to_plic_id(
    dt_${device_name}_t dt,
    dt_${device_name}_irq_t irq) {
  dt_plic_irq_id_t first_irq = TRY_GET_DT(dt, kDtPlicIrqIdNone)->first_irq;
  if (first_irq == kDtPlicIrqIdNone) {
    return kDtPlicIrqIdNone;
  }
  return (dt_plic_irq_id_t)((uint32_t)first_irq + (uint32_t)irq);
}

dt_${device_name}_irq_t dt_${device_name}_irq_from_plic_id(
    dt_${device_name}_t dt,
    dt_plic_irq_id_t irq) {
  dt_${device_name}_irq_t count = ${helper.irq_enum.name.as_c_enum()}Count;
  dt_plic_irq_id_t first_irq = TRY_GET_DT(dt, count)->first_irq;
  if (first_irq == kDtPlicIrqIdNone) {
    return count;
  }
  if (irq < first_irq || irq >= first_irq + (dt_plic_irq_id_t)count) {
    return count;
  }
  return (dt_${device_name}_irq_t)(irq - first_irq);
}

%endif

% if helper.has_alerts() and helper.has_alert_handler():
dt_alert_id_t dt_${device_name}_alert_to_alert_id(
    dt_${device_name}_t dt,
    dt_${device_name}_alert_t alert) {
  return (dt_alert_id_t)((uint32_t)${dt_array}[dt].first_alert + (uint32_t)alert);
}

dt_${device_name}_alert_t dt_${device_name}_alert_from_alert_id(
    dt_${device_name}_t dt,
    dt_alert_id_t alert) {
  dt_${device_name}_alert_t count = ${helper.alert_enum.name.as_c_enum()}Count;
  if (alert < ${dt_array}[dt].first_alert || alert >= ${dt_array}[dt].first_alert + (dt_alert_id_t)count) {
    return count;
  }
  return (dt_${device_name}_alert_t)(alert - ${dt_array}[dt].first_alert);
}

%endif

% if helper.has_periph_io():
dt_periph_io_t dt_${device_name}_periph_io(
    dt_${device_name}_t dt,
    dt_${device_name}_periph_io_t sig) {
  // Return a harmless value in case of wrong argument.
  return TRY_GET_DT(dt, kDtPeriphIoConstantHighZ)->periph_io[sig];
}
% endif

% if helper.has_clocks():
dt_clock_t dt_${device_name}_clock(
    dt_${device_name}_t dt,
    dt_${device_name}_clock_t clk) {
  // Return the first clock in case of invalid argument.
  return TRY_GET_DT(dt, (dt_clock_t)0)->clock[clk];
}
% endif

% if helper.has_resets():
dt_reset_t dt_${device_name}_reset(
    dt_${device_name}_t dt,
    dt_${device_name}_reset_t rst) {
  const dt_${device_name}_reset_t count = ${helper.reset_enum.name.as_c_enum()}Count;
  if (rst >= count) {
    return kDtResetUnknown;
  }
  return TRY_GET_DT(dt, kDtResetUnknown)->reset[rst];
}
% endif

## Extension
${helper.render_extension(Extension.DtIpPos.SourceEnd)}
