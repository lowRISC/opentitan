// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Device table API auto-generated by `dtgen`
<%
from topgen.lib import Name, is_top_reggen, is_ipgen

top = helper.top
top_name = Name(["top", top["name"]])
irq_base_name = top_name + Name(["plic", "irq", "id"])
top_clock_prefix = Name(["dt", "clock"])

def snake_to_constant_name(s):
    return Name.from_snake_case(s).as_c_enum()

module_name = helper.ip.name
%>\


#include "dt/dt_${module_name}.h"

// Device tables for ${module_name}
<%
    modules = helper.inst_map.values()
    block = helper.ip
    reg_count_enum = Name.from_snake_case(
        "dt_{}_reg_block_count".format(module_name)
    ).as_c_enum()
    clk_count_enum = Name.from_snake_case(
        "dt_{}_clock_count".format(module_name)
    ).as_c_enum()
    irq_count_enum = Name.from_snake_case(
        "dt_{}_irq_count".format(module_name)
    ).as_c_enum()
    reg_count = len(block.reg_blocks)
    irq_count = 0
    for irq in block.interrupts:
      irq_count += irq.bits.width()
    irqs = {}
    for m in modules:
      irqs_packed = [irq
        for irq in top["interrupt"] if irq["module_name"] == m["name"]]
      irqs[m["name"]] = []
      for irq in irqs_packed:
        irq_name = irq_base_name + Name.from_snake_case(irq["name"])
        irq_width = int(irq["width"])
        if irq_width > 1:
          for i in range(irq_width):
            irqs[m["name"]].append(irq_name + Name([str(i)]))
        else:
          irqs[m["name"]].append(irq_name)
    block_clock_prefix = Name.from_snake_case(f"dt_{module_name}_clock")
    block_clocks = {}
    for clock in block.clocking.items:
        if clock.internal or clock.clock == None or clock.clock == "scan_clk_i":
            continue
        if clock.clock_base_name == "":
            block_clock = block_clock_prefix + Name(["clk"])
        else:
            block_clock = (block_clock_prefix +
                           Name.from_snake_case(clock.clock_base_name))
        block_clocks[clock.clock] = block_clock
    clk_count = len(block_clocks.keys())

    inouts, inputs, outputs = block.xputs
    device_ports = []
    for sig in inputs + outputs + inouts:
        device_ports.append(sig.name)

    pinmux_info = top["pinmux"]
%>\

/**
 * Description of instances.
 */
${helper.inst_struct.render()}

<%
  dt_array = (helper.ip_name + Name(["desc"])).as_snake_case()
%>

static const dt_${module_name}_desc_t ${dt_array}[${(helper.inst_enum.name + Name(["count"])).as_c_enum()}] = {
%   for (dev_index, inst_name) in enumerate(helper.inst_map.keys()):
  // Properties of ${m["name"]}
  [${(helper.inst_enum.name + inst_name).as_c_enum()}] = {
      .inst_id = ${snake_to_constant_name("dt_instance_id_" + m["name"])},
      .base_addr = {
%     for (rb, addr) in m["base_addrs"].items():
<%
      # If the register block name is not specified, it will be serialized as "null"
      # in the top-generated Hjson file. In this case, use the default node created
      # in dt_ip.h.tpl
      if rb == "null":
        rb = "core"
      # Only consider those address spaces that the hart can talk to.
      if "hart" not in addr:
        continue
%>\
        [${snake_to_constant_name(f"dt_{module_name}_reg_block_{rb}")}] = ${addr["hart"]},
%     endfor
    },
      .clock = {
%     for port, clock in m["clock_srcs"].items():
%       if port in block_clocks:
<%
        if type(clock) is str:
            clock_id = top_clock_prefix + Name.from_snake_case(clock)
        else:
            clock_id = top_clock_prefix + Name.from_snake_case(clock["clock"])
        block_clock_enum = block_clocks[port].as_c_enum()
%>\
        [${block_clock_enum}] = ${clock_id.as_c_enum()},
%       endif
%     endfor
      },
%   if len(block.interrupts) > 0:
## It can happen that a block declares some interrupts but the block is not connected to the PLIC.
## For example, on english breakfast, the rv_timer is directly connected to Ibex and not to the PLIC.
## In this case, we set the first_irq to kDtPlicIrqIdNone.
%     if len(irqs[m["name"]]) == 0:
      .first_irq = kDtPlicIrqIdNone,
%     else:
      .first_irq = ${irqs[m["name"]][0].as_c_enum()},
%     endif
%   endif
%   if len(device_ports) > 0:
      .periph_io = {
%     for port in device_ports:
%       for conn in [c for c in pinmux_info["ios"] if c["name"] == m["name"] + "_" + port]:
<%
            pin_name = port
            if conn["type"] == "input":
              pin_dir = "kDtPeriphIoDirIn"
            elif conn["type"] == "output":
              pin_dir = "kDtPeriphIoDirOut"
            else:
              assert conn["type"] == "inout", "unexpected connection dir '{}'".format(conn["type"])
              pin_dir = "kDtPeriphIoDirInout"

            if conn["idx"] != -1:
                pin_name += str(conn["idx"])
            if conn["connection"] == "muxed":
                pin_type = "Mio"
                pin_periph_input_or_direct_pad = "0"
                pin_outsel = "0"
                if conn["type"] in ["input", "inout"]:
                    pin_periph_input_or_direct_pad = snake_to_constant_name("top_{}_pinmux_peripheral_in_{}_{}".format(top["name"], m["name"], pin_name))
                if conn["type"] in ["output", "inout"]:
                    pin_outsel = snake_to_constant_name("top_{}_pinmux_outsel_{}_{}".format(top["name"], m["name"], pin_name))
            elif conn["connection"] == "direct":
                pin_type = "Dio"
                pin_periph_input_or_direct_pad = snake_to_constant_name("top_{}_direct_pads_{}_{}".format(top["name"], m["name"], pin_name))
                pin_outsel = "0"
            else:
                assert conn["connection"] == "manual", "unexpected connection type '{}'".format(conn["connection"])
                pin_periph_input_or_direct_pad = "0"
                pin_outsel = "0"
                pin_type = "Unspecified"
%>\
        [${snake_to_constant_name(f"dt_{module_name}_periph_io_{pin_name}")}] = {
          .__internal = {
            .type = kDtPeriphIoType${pin_type},
            .dir = ${pin_dir},
            .periph_input_or_direct_pad = ${pin_periph_input_or_direct_pad},
            .outsel = ${pin_outsel},
          }
        },
%       endfor
%     endfor
      },
%   endif
  },
%   endfor
};

dt_instance_id_t dt_${module_name}_instance_id(
    dt_${module_name}_t dt) {
  return ${dt_array}[dt].inst_id;
}

/**
 * Get the register base address of an instance.
 *
 * @param dt Pointer to an instance of ${module_name}.
 * @param reg_block The register block requested.
 * @return The register base address of the requested block.
 */
uint32_t dt_${module_name}_reg_block(
    dt_${module_name}_t dt,
    dt_${module_name}_reg_block_t reg_block) {
  return ${dt_array}[dt].base_addr[reg_block];
}

% if helper.has_irqs():
/**
 * Get the PLIC ID of a ${module_name} IRQ for a given instance.
 *
 * If the instance is not connected to the PLIC, this function
 * will return `kDtPlicIrqIdNone`.
 *
 * @param dt Pointer to an instance of ${module_name}.
 * @param irq_type A ${module_name} IRQ.
 * @return The PLIC ID of the IRQ of this instance.
 */
dt_plic_irq_id_t dt_${module_name}_irq_to_plic_id(
    dt_${module_name}_t dt,
    dt_${module_name}_irq_t irq) {
  if (${dt_array}[dt].first_irq == kDtPlicIrqIdNone) {
    return kDtPlicIrqIdNone;
  }
  return (dt_plic_irq_id_t)((uint32_t)${dt_array}[dt].first_irq + (uint32_t)irq);
}

/**
 * Convert a global IRQ ID to a local ${module_name} IRQ type.
 *
 * @param dt Pointer to an instance of ${module_name}.
 * @param irq A PLIC ID that belongs to this instance.
 * @return The ${module_name} IRQ, or `${helper.irq_enum.name.as_c_enum()}Count`.
 *
 * NOTE This function assumes that the PLIC ID belongs to the instance
 * of ${module_name} passed in parameter. In other words, it must be the case that
 * `dt_${module_name}_instance_id(dt) == dt_plic_id_to_instance_id(irq)`. Otherwise, this function
 * will return `${helper.irq_enum.name.as_c_enum()}Count`.
 */
dt_${module_name}_irq_t dt_${module_name}_irq_from_plic_id(
    dt_${module_name}_t dt,
    dt_plic_irq_id_t irq) {
  dt_${module_name}_irq_t count = ${helper.irq_enum.name.as_c_enum()}Count;
  if (irq < ${dt_array}[dt].first_irq || irq >= ${dt_array}[dt].first_irq + (dt_plic_irq_id_t)count) {
    return count;
  }
  return (dt_${module_name}_irq_t)(irq - ${dt_array}[dt].first_irq);
}

%endif
% if helper.has_periph_io():
/**
 * Get the peripheral I/O description of an instance.
 *
 * @param dt Pointer to an instance of ${module_name}.
 * @param sig Requested peripheral I/O.
 * @return Description of the requested peripheral I/O for this instance.
 */
dt_periph_io_t dt_${module_name}_periph_io(
    dt_${module_name}_t dt,
    dt_${module_name}_periph_io_t sig) {
  return ${dt_array}[dt].periph_io[sig];
}
% endif
