// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Device table API auto-generated by `dtgen`
<%
from topgen.lib import Name
from dtgen.helper import Extension

module_name = helper.ip.name
%>\


#include "dt/dt_${module_name}.h"

## Extension
${helper.render_extension(Extension.DtIpPos.SourceIncludes)}

/**
 * Description of instances.
 */
${helper.inst_struct.render_type_def()}

<%
  dt_array_name = helper.ip_name + Name(["desc"])
  dt_array = dt_array_name.as_snake_case()
  dt_array_count = helper.inst_enum.name + Name(["count"])
%>

static const ${helper.inst_dt_map.render_var_def(dt_array_name, helper.inst_dt_values)}

/**
 * Return a pointer to the `dt_${module_name}_desc_t` structure of the requested
 * `dt` if it's a valid index. Otherwise, this macro will `return` (i.e. exit
 * the function) with the provided default value.
 */
#define TRY_GET_DT(dt, default) \
  ({ \
    if ((dt) < (dt_${module_name}_t)0 || (dt) >= ${dt_array_count.as_c_enum()}) \
      return (default); \
    &${dt_array}[dt]; \
  })

dt_${module_name}_t dt_${module_name}_from_instance_id(dt_instance_id_t inst_id) {
  if (inst_id >= ${helper.first_inst_id.as_c_enum()} && inst_id <= ${helper.last_inst_id.as_c_enum()}) {
    return (dt_${module_name}_t)(inst_id - ${helper.first_inst_id.as_c_enum()});
  }
  return (dt_${module_name}_t)0;
}

dt_instance_id_t dt_${module_name}_instance_id(
    dt_${module_name}_t dt) {
  return TRY_GET_DT(dt, kDtInstanceIdUnknown)->inst_id;
}

/**
 * Get the register base address of an instance.
 *
 * @param dt Pointer to an instance of ${module_name}.
 * @param reg_block The register block requested.
 * @return The register base address of the requested block.
 */
uint32_t dt_${module_name}_reg_block(
    dt_${module_name}_t dt,
    dt_${module_name}_reg_block_t reg_block) {
  // Return a recognizable address in case of wrong argument.
  return TRY_GET_DT(dt, 0xdeadbeef)->base_addr[reg_block];
}

% if helper.has_irqs():
/**
 * Get the PLIC ID of a ${module_name} IRQ for a given instance.
 *
 * If the instance is not connected to the PLIC, this function
 * will return `kDtPlicIrqIdNone`.
 *
 * @param dt Pointer to an instance of ${module_name}.
 * @param irq_type A ${module_name} IRQ.
 * @return The PLIC ID of the IRQ of this instance.
 */
dt_plic_irq_id_t dt_${module_name}_irq_to_plic_id(
    dt_${module_name}_t dt,
    dt_${module_name}_irq_t irq) {
  dt_plic_irq_id_t first_irq = TRY_GET_DT(dt, kDtPlicIrqIdNone)->first_irq;
  if (first_irq == kDtPlicIrqIdNone) {
    return kDtPlicIrqIdNone;
  }
  return (dt_plic_irq_id_t)((uint32_t)first_irq + (uint32_t)irq);
}

/**
 * Convert a global IRQ ID to a local ${module_name} IRQ type.
 *
 * @param dt Pointer to an instance of ${module_name}.
 * @param irq A PLIC ID that belongs to this instance.
 * @return The ${module_name} IRQ, or `${helper.irq_enum.name.as_c_enum()}Count`.
 *
 * NOTE This function assumes that the PLIC ID belongs to the instance
 * of ${module_name} passed in parameter. In other words, it must be the case that
 * `dt_${module_name}_instance_id(dt) == dt_plic_id_to_instance_id(irq)`. Otherwise, this function
 * will return `${helper.irq_enum.name.as_c_enum()}Count`.
 */
dt_${module_name}_irq_t dt_${module_name}_irq_from_plic_id(
    dt_${module_name}_t dt,
    dt_plic_irq_id_t irq) {
  dt_${module_name}_irq_t count = ${helper.irq_enum.name.as_c_enum()}Count;
  dt_plic_irq_id_t first_irq = TRY_GET_DT(dt, count)->first_irq;
  if (first_irq == kDtPlicIrqIdNone) {
    return count;
  }
  if (irq < first_irq || irq >= first_irq + (dt_plic_irq_id_t)count) {
    return count;
  }
  return (dt_${module_name}_irq_t)(irq - first_irq);
}

%endif

% if helper.has_alerts() and helper.has_alert_handler():
/**
 * Get the alert ID of a ${module_name} alert for a given instance.
 *
 * NOTE This function only makes sense if the instance is connected to the Alert Handler. For any
 * instances where the instance is not connected, the return value is unspecified.
 *
 * @param dt Instance of ${module_name}.
 * @param alert_type A ${module_name} alert.
 * @return The Alert Handler alert ID of the alert of this instance.
 */
dt_alert_id_t dt_${module_name}_alert_to_alert_id(
    dt_${module_name}_t dt,
    dt_${module_name}_alert_t alert) {
  return (dt_alert_id_t)((uint32_t)${dt_array}[dt].first_alert + (uint32_t)alert);
}

/**
 * Convert a global alert ID to a local ${module_name} alert type.
 *
 * @param dt Instance of ${module_name}.
 * @param alert A global alert ID that belongs to this instance.
 * @return The ${module_name} alert, or `${helper.alert_enum.name.as_c_enum()}Count`.
 *
 * NOTE This function assumes that the global alert ID belongs to the
 * instance of ${module_name} passed in parameter. In other words, it must be the case
 * that `dt_${module_name}_instance_id(dt) == dt_alert_id_to_instance_id(alert)`. Otherwise,
 * this function will return `${helper.alert_enum.name.as_c_enum()}Count`.
 */
dt_${module_name}_alert_t dt_${module_name}_alert_from_alert_id(
    dt_${module_name}_t dt,
    dt_alert_id_t alert) {
  dt_${module_name}_alert_t count = ${helper.alert_enum.name.as_c_enum()}Count;
  if (alert < ${dt_array}[dt].first_alert || alert >= ${dt_array}[dt].first_alert + (dt_alert_id_t)count) {
    return count;
  }
  return (dt_${module_name}_alert_t)(alert - ${dt_array}[dt].first_alert);
}

%endif

% if helper.has_periph_io():
/**
 * Get the peripheral I/O description of an instance.
 *
 * @param dt Pointer to an instance of ${module_name}.
 * @param sig Requested peripheral I/O.
 * @return Description of the requested peripheral I/O for this instance.
 */
dt_periph_io_t dt_${module_name}_periph_io(
    dt_${module_name}_t dt,
    dt_${module_name}_periph_io_t sig) {
  // Return a harmless value in case of wrong argument.
  return TRY_GET_DT(dt, kDtPeriphIoConstantHighZ)->periph_io[sig];
}
% endif

% if helper.has_clocks():
/**
 * Get the clock signal connected to a clock port of an instance.
 *
 * @param dt Instance of ${module_name}.
 * @param sig Clock port.
 * @return Clock signal.
 */
dt_clock_t dt_${module_name}_clock(
    dt_${module_name}_t dt,
    dt_${module_name}_clock_t clk) {
  // Return the first clock in case of invalid argument.
  return TRY_GET_DT(dt, (dt_clock_t)0)->clock[clk];
}
% endif

% if helper.has_resets():
/**
 * Get the reset signal connected to a reset port of an instance.
 *
 * @param dt Instance of ${module_name}.
 * @param sig Reset port.
 * @return Reset signal.
 */
dt_reset_t dt_${module_name}_reset(
    dt_${module_name}_t dt,
    dt_${module_name}_reset_t rst) {
  const dt_${module_name}_reset_t count = ${helper.reset_enum.name.as_c_enum()}Count;
  if (rst >= count) {
    return kDtResetUnknown;
  }
  return TRY_GET_DT(dt, kDtResetUnknown)->reset[rst];
}
% endif

## Extension
${helper.render_extension(Extension.DtIpPos.SourceEnd)}
