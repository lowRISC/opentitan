// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Device table API auto-generated by `dtgen`
<%
from topgen.lib import Name, is_top_reggen, is_ipgen

top = helper.top

top_name = Name(["top", top["name"]])

include_guard = "OPENTITAN_TOP_{}_DT_API_H_".format(top["name"].upper())
%>\

#ifndef ${include_guard}
#define ${include_guard}

#include <stddef.h>
#include <stdint.h>
#include "${top_lib_header}"

/**
 * List of device types.
 *
 * Device types are guaranteed to be numbered consecutively from 0.
 */
${helper.device_type_enum.render()}

/**
 * List of instance IDs.
 *
 * Instance IDs are guaranteed to be numbered consecutively from 0.
 */
${helper.instance_id_enum.render()}

/**
 * Get the instance type of a device instance.
 *
 * For example the instance type of `kDtUart0` is `kDtInstanceTypeUart`.
 *
 * @param id An instance ID.
 * @return The instance type, or `kDtInstanceIdUnknown` if the ID is not valid.
 */
dt_device_type_t dt_device_type(dt_instance_id_t id);

/**
 * Get the instance number of a device instance.
 *
 * If a top has several instances of the same type, this will return the
 * instance number. This function guarantees that the instance
 * number can be used to index into the corresponding devicetable.
 *
 * For example, if the instance index of `kDtUart3` is 3 then it is guaranteed
 * then that `kDtUart[3] == kDtUart3`.
 *
 * @param dev An instance ID.
 * @return The instance number, or 0 if the ID is not valid.
 */
size_t dt_instance_index(dt_instance_id_t dev);

/** PLIC IRQ ID type.
 *
 * This type represents a raw IRQ ID from the PLIC.
 *
 * This is an alias to the top's `plic_irq_id_t` type for backward compatibility
 * with existing code.
 */
typedef ${top_name.as_snake_case()}_plic_irq_id_t dt_plic_irq_id_t;

/** PLIC IRQ ID for no interrupt. */
static const dt_plic_irq_id_t kDtPlicIrqIdNone=${top_name.as_c_enum()}PlicIrqIdNone;

/**
 * Get the instance ID for a given PLIC IRQ ID.
 *
 * For example, on earlgrey, the instance ID of `kTopEarlgreyPlicIrqIdUart0TxWatermark`
 * is `kDtInstanceIdUart0`. One can then use the type specific function to retrieve the
 * IRQ name, for example `dt_uart_irq_from_plic_id` for the UART.
 *
 * @param dev A PLIC ID.
 * @return The instance ID, or `kDtInstanceIdUnknown` if the PLIC ID is not valid.
 */
dt_instance_id_t dt_plic_id_to_instance_id(dt_plic_irq_id_t irq);

/**
 * List of clocks.
 *
 * Clocks are guaranteed to be numbered consecutively from 0.
 */
${helper.clock_enum.render()}

/**
 * Get the frequency of a clock.
 *
 * @param dev A clock ID.
 * @return Clock frequency in Hz.
 */
uint32_t dt_clock_frequency(dt_clock_t clk);

/**
 * Pinmux types.
 *
 * These types are aliases to top-level types for backward compatibility
 * with existing code.
 */
typedef ${top_name.as_snake_case()}_pinmux_peripheral_in_t dt_pinmux_peripheral_in_t;
typedef ${top_name.as_snake_case()}_pinmux_insel_t dt_pinmux_insel_t;
typedef ${top_name.as_snake_case()}_pinmux_outsel_t dt_pinmux_outsel_t;
typedef ${top_name.as_snake_case()}_pinmux_mio_out_t dt_pinmux_mio_out_t;
typedef ${top_name.as_snake_case()}_direct_pads_t dt_pinmux_direct_pad_t;
typedef ${top_name.as_snake_case()}_muxed_pads_t  dt_pinmux_muxed_pad_t;

/** Type of a signal. */
typedef enum dt_signal_type {
  /* This signal is connected to a muxed IO (MIO). */
  kDtSignalTypeMio,
  /* This signal is connected to a direct IO (DIO). */
  kDtSignalTypeDio,
  /* This signal is not connected to either a MIO or a DIO. */
  kDtSignalTypeUnspecified,
} dt_signal_type_t;

/** Signal description.
 *
 * A `dt_signal_t` represents a HW IP block signal, which can be an input, output or both.
 * Importantly, this only represents how the block signal is wired, i.e.
 * whether it is connected a MIO or a direct IO on the signalmux, and the relevant information necessary to
 * configure it.
 *
 * NOTE The fields of this structure are internal, use the dt_signal_* functions to access them.
 */
typedef struct dt_signal {
  struct {
    /** Signal type */
    dt_signal_type_t type;
    /** For `kDtSignalTypeMio` signals: peripheral input number. This is the index of the MIO_PERIPH_INSEL register
     * that controls this signal (or the input part of this signal). Set to `kDtSignalPeriphInputNone`
     * if this signal is not an input.
     *
     * For `kDtSignalTypeDio`:  DIO pad number. This is the index of the various DIO_PAD_* registers
     * that control this signal.
     */
    uint16_t periph_input_or_direct_pad;
    /** For `kDtSignalTypeMio` signals: peripheral output number. This is the value to put in the MIO_OUTSEL registers
     * to connect an output to this signal. Set to `kDtSignalOutselNone` if this signal is not an input.
     */
    uint16_t outsel;
  } __internal;
} dt_signal_t;

/** The signal is not an MIO input. */
static const dt_pinmux_peripheral_in_t kDtSignalPeriphInputNone = k${top_name.as_camel_case()}PinmuxPeripheralInLast + 1;

/** The signal is not an MIO output. */
static const dt_pinmux_outsel_t kDtSignalOutselNone = k${top_name.as_camel_case()}PinmuxOutselLast + 1;

/** The signal is not a direct IO. */
static const dt_pinmux_direct_pad_t kDtSignalDirectPadNone = k${top_name.as_camel_case()}DirectPadsLast + 1;

/** Tie constantly to zero. */
static const dt_pinmux_outsel_t kDtSignalOutselConstantZero = k${top_name.as_camel_case()}PinmuxOutselConstantZero;

/** Tie constantly to one. */
static const dt_pinmux_outsel_t kDtSignalOutselConstantOne = k${top_name.as_camel_case()}PinmuxOutselConstantOne;

/** Tie constantly to high-Z. */
static const dt_pinmux_outsel_t kDtSignalOutselConstantHighZ = k${top_name.as_camel_case()}PinmuxOutselConstantHighZ;

/* Signal that is constantly tied to high-Z (output only) */
extern const dt_signal_t kDtSignalConstantHighZ;

/* Signal that is constantly tied to one (output only) */
extern const dt_signal_t kDtSignalConstantZero;

/* Signal that is constantly tied to zero (output only) */
extern const dt_signal_t kDtSignalConstantOne;

/**
 * Return the type of a `dt_signal_t`.
 *
 * @param dev A signal description.
 * @return The signal type (MIO, DIO, etc).
 */
static inline dt_signal_type_t dt_signal_type(dt_signal_t signal) {
  return (dt_signal_type_t)signal.__internal.type;
}

/**
 * Return the peripheral input for an MIO signal.
 *
 * This is the index of the MIO_PERIPH_INSEL register that controls this signal
 * (or the input part of this signal).
 *
 * @param dev A signal of type `kDtSignalTypeMio`.
 * @return The peripheral input number of the MIO that this signal is connected to,
 * or `kDtSignalPeriphInputNone`.
 *
 * NOTE This function only makes sense for signals of type `kDtSignalTypeMio` which are
 * either inputs or inouts. For any other signal, this function will return `kDtSignalPeriphInputNone`.
 */
static inline dt_pinmux_peripheral_in_t dt_pin_mio_periph_input(dt_signal_t signal) {
  if (dt_signal_type(signal) != kDtSignalTypeMio) {
    return kDtSignalPeriphInputNone;
  }
  return (dt_pinmux_peripheral_in_t)signal.__internal.periph_input_or_direct_pad;
}

/**
 * Return the outsel for an MIO signal.
 *
 * This is the value to put in the `MIO_OUTSEL` registers to connect a pad to this signal.
 *
 * @param dev A signal of type `kDtSignalTypeMio`.
 * @return The outsel of the MIO that this signal is connected to,
 * or `kDtSignalOutselNone`.
 *
 * NOTE This function only makes sense for signals of type `kDtSignalTypeMio` which are
 * either outputs or inouts. For any other signal, this function will return `kDtSignalOutselNone`.
 */
static inline dt_pinmux_outsel_t dt_pin_mio_outsel(dt_signal_t signal) {
  if (dt_signal_type(signal) != kDtSignalTypeMio) {
    return kDtSignalOutselNone;
  }
  return (dt_pinmux_outsel_t)signal.__internal.outsel;
}

/**
 * Return the direct pad number of a DIO signal.
 *
 * This is the index of the various `DIO_PAD_*` registers that control this signal.
 *
 * @param dev A signal of type `kDtSignalTypeDio`.
 * @return The direct pad number of the DIO that this signal is connected to,
 * or `kDtSignalDirectPadNone`.
 *
 * NOTE This function only makes sense for signals of type `kDtSignalTypeDio` which are
 * either outputs or inouts. For any other signal type, this function will return `kDtSignalDirectPadNone`.
 */
static inline dt_pinmux_direct_pad_t dt_pin_dio_pad(dt_signal_t signal) {
  if (dt_signal_type(signal) != kDtSignalTypeDio) {
    return kDtSignalDirectPadNone;
  }
  return (dt_pinmux_direct_pad_t)signal.__internal.periph_input_or_direct_pad;
}

/** Type of a pad. */
typedef enum dt_pad_type {
  /* This pad is a muxed IO (MIO). */
  kDtPadTypeMio,
  /* This pad is a direct IO (DIO). */
  kDtPadTypeDio,
  /* This pad is not an MIO or a DIO. */
  kDtPadTypeOther,
} dt_pad_type_t;

/**
 * Pad description.
 *
 * A `dt_pad_t` represents a chip's physical pad.
 *
 * NOTE The fields of this structure are internal, use the dt_pad_* functions to access them.
 */
typedef struct dt_pad {
  struct {
    /** Pad type */
    uint16_t type : 2;
    /** For `kDtPadTypeMio` pads: MIO out number. This is the index of the MIO_OUTSEL register
     * that controls this pad (or the output part of this pad). Set to `kDtPadMioOutNone`
     * if this pad is not an output.
     *
     * For `kDtPadTypeDio`:  DIO pad number. This is the index of the various DIO_PAD_* registers
     * that control this pad.
     */
    uint16_t mio_out_or_direct_pad: 7;
    /** For `kDtPadTypeMio` pads: MIO pad number. This is the value to put in the MIO_PERIPH_INSEL
     * registers to connect a peripheral to this pad. Set to `kDtPadInselNone` if this pad is not an input.
     */
    uint16_t insel: 7;
  } __internal;
} __attribute__((packed)) dt_pad_t;


/** The pad is not an MIO output. */
static const dt_pinmux_mio_out_t kDtPadMioOutNone = k${top_name.as_camel_case()}PinmuxMioOutLast + 1;

/** The pad is not an MIO input. */
static const dt_pinmux_insel_t kDtPadInselNone = k${top_name.as_camel_case()}PinmuxInselLast + 1;

/** The pad is not a direct IO. */
static const dt_pinmux_direct_pad_t kDtPadDirectPadNone = k${top_name.as_camel_case()}DirectPadsLast + 1;

/**
 * Return the type of a `dt_pad_t`.
 *
 * @param dev A pad description.
 * @return The pad type (MIO, DIO, etc).
 */
static inline dt_pad_type_t dt_pad_type(dt_pad_t pad) {
  return (dt_pad_type_t)pad.__internal.type;
}

/**
 * Return the pad out number for an MIO pad.
 *
 * This is the index of the `MIO_OUT` registers that control this pad
 * (or the output part of this pad).
 *
 * @param dev A pad of type `kDtPadTypeMio`.
 * @return The pad out number of the MIO or `kDtPadMioOutNone`.
 *
 * NOTE This function only makes sense for pads of type `kDtPadTypeMio` which are
 * either inputs or inouts. For any other pad, this function will return `kDtPadMioOutNone`.
 */
static inline dt_pinmux_mio_out_t dt_pad_mio_out(dt_pad_t pad) {
  if (dt_pad_type(pad) != kDtPadTypeMio) {
    return kDtPadMioOutNone;
  }
  return (dt_pinmux_mio_out_t)pad.__internal.mio_out_or_direct_pad;
}

/**
 * Return the pad out number for an MIO pad.
 *
 * This is the index of the `MIO_PAD` registers that control this pad
 * (or the output part of this pad).
 *
 * @param dev A pad of type `kDtPadTypeMio`.
 * @return The pad out number of the MIO or `kDtPadMioOutNone`.
 *
 * NOTE This function only makes sense for pads of type `kDtPadTypeMio` which are
 * either inputs or inouts. For any other pad, this function will return `kDtPadMioOutNone`.
 */
static inline dt_pinmux_muxed_pad_t dt_pad_mio_pad(dt_pad_t pad) {
  // Same index as MIO_OUT.
  return (dt_pinmux_muxed_pad_t)dt_pad_mio_out(pad);
}

/**
 * Return the insel for an MIO pad.
 *
 * This is the value to put in the `MIO_PERIPH_INSEL` registers to connect a signal to this pad.
 *
 * @param dev A pad of type `kDtPadTypeMio`.
 * @return The insel of the MIO that this pad is connected to,
 * or `kDtPadInselNone`.
 *
 * NOTE This function only makes sense for pads of type `kDtPadTypeMio` which are
 * either inputs or inouts. For any other pad, this function will return `kDtPadInselNone`.
 */
static inline dt_pinmux_insel_t dt_pad_mio_insel(dt_pad_t pad) {
  if (dt_pad_type(pad) != kDtPadTypeMio) {
    return kDtPadInselNone;
  }
  return (dt_pinmux_insel_t)pad.__internal.insel;
}

/**
 * Return the direct pad number of a DIO pad.
 *
 * This is the index of the various `DIO_PAD_*` registers that control this pad.
 *
 * @param dev A pad of type `kDtPadTypeDio`.
 * @return The direct pad number of the DID that this pad is connected to,
 * or `kDtSignalDirectPadNone`.
 *
 * NOTE This function only makes sense for pads of type `kDtSignalTypeDio` which are
 * either outputs or inouts. For any other pad type, this function will return `kDtPadDirectPadNone`.
 */
static inline dt_pinmux_direct_pad_t dt_pad_dio_pad(dt_pad_t pad) {
  if (dt_pad_type(pad) != kDtPadTypeDio) {
    return kDtPadDirectPadNone;
  }
  return (dt_pinmux_direct_pad_t)pad.__internal.mio_out_or_direct_pad;
}

#endif  // ${include_guard}
