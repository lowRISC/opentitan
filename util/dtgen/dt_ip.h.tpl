// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Device table API auto-generated by `dtgen`
<%
    def snake_to_enum(s):
        out = "k"
        for p in s.split("_"):
            # If we're about to join two parts which would introduce adjacent
            # numbers, put an underscore between them.
            if out[-1:].isnumeric() and p[:1].isnumeric():
                out += "_" + p
            else:
                out += p.capitalize()
        return out

    device_name = block.name

    inouts, inputs, outputs = block.xputs
    device_pins = []
    for sig in inputs + outputs + inouts:
        if sig.bits.width() > 1:
            for bit in range(sig.bits.width()):
                device_pins.append(sig.name + str(bit))
        else:
            device_pins.append(sig.name)

    device_irqs = []
    for sig in block.interrupts:
        if sig.bits.width() > 1:
            for bit in range(sig.bits.width()):
                device_irqs.append(sig.name + str(bit))
        else:
            device_irqs.append(sig.name)

    device_reg_blocks = []
    for rb in block.reg_blocks.keys():
        if rb is None:
            device_reg_blocks.append("core")
        else:
            device_reg_blocks.append(rb)

    assert default_node in device_reg_blocks, "default node ({}) is invalid".format(default_node)

    device_clocks = []
    for clk in block.clocking.items:
        if clk.internal or clk.clock is None:
            continue
        if clk.clock_base_name == "":
            if clk.clock != "scan_clk_i":
                device_clocks.append("clk")
        else:
            device_clocks.append(clk.clock_base_name)

    include_guard = "OPENTITAN_DT_{}_H_".format(block.name.capitalize())
%>\

#ifndef ${include_guard}
#define ${include_guard}

#include "dt_api.h"
#include <stdint.h>

## List of register blocks.
typedef enum {
% for idx, rb in enumerate(device_reg_blocks):
  ${snake_to_enum(f"dt_{device_name}_reg_block_{rb}")} = ${str(idx)},
% endfor
  ${snake_to_enum(f"dt_{device_name}_reg_block_count")} = ${str(len(device_reg_blocks))},
  ${snake_to_enum(f"dt_{device_name}_reg_block_default")} = ${snake_to_enum(f"dt_{device_name}_reg_block_{default_node}")},
} dt_${device_name}_reg_block_t;

## List of IRQs.
% if len(device_irqs) > 0:
typedef enum {
%   for idx, irq in enumerate(device_irqs):
  // TODO add IRQ description?
  ${snake_to_enum(f"dt_{device_name}_irq_{irq}")} = ${str(idx)},
%   endfor
  ${snake_to_enum(f"dt_{device_name}_irq_count")} = ${str(len(device_irqs))},
} dt_${device_name}_irq_t;

% endif
## List of clocks.
% if len(device_clocks) > 0:
typedef enum {
% for idx, clk in enumerate(device_clocks):
  ${snake_to_enum(f"dt_{device_name}_clock_{clk}")} = ${str(idx)},
% endfor
  ${snake_to_enum(f"dt_{device_name}_clock_count")} = ${str(len(device_clocks))},
} dt_${device_name}_clock_t;

% endif
## List of pins.
% if len(device_pins) > 0:
typedef enum {
% for idx, pin in enumerate(device_pins):
  ${snake_to_enum(f"dt_{device_name}_pin_{pin}")} = ${str(idx)},
% endfor
  ${snake_to_enum(f"dt_{device_name}_pin_count")} = ${str(len(device_pins))},
} dt_${device_name}_pin_t;

% endif
## DT structure.
typedef struct dt_${device_name} {
  struct {
    dt_device_id_t device_id;
    uint32_t base_addrs[${snake_to_enum(f"dt_{device_name}_reg_block_count")}];
% if len(device_irqs) > 0:
    // This can be kDtPlicIrqIdNone if the block is connected to the PLIC.
    dt_plic_irq_id_t first_irq;
% endif
    dt_clock_t clocks[${snake_to_enum(f"dt_{device_name}_clock_count")}];
% if len(device_pins) > 0:
    dt_pin_t pins[${snake_to_enum(f"dt_{device_name}_pin_count")}];
% endif
  } __internal;
} dt_${device_name}_t;

/**
 * Get the device ID of an instance.
 *
 * @param dt Pointer to an instance of ${device_name}.
 * @return The device ID of that instance.
 */
static inline dt_device_id_t dt_${device_name}_device_id(
    const dt_${device_name}_t *dt) {
  return dt->__internal.device_id;
}

/**
 * Get the register base address of an instance.
 *
 * @param dt Pointer to an instance of ${device_name}.
 * @param reg_block The register block requested.
 * @return The register base address of the requested block.
 */
static inline uint32_t dt_${device_name}_reg_block(
    const dt_${device_name}_t *dt,
    dt_${device_name}_reg_block_t reg_block) {
  return dt->__internal.base_addrs[reg_block];
}

% if len(device_irqs) > 0:
/**
 * Get the PLIC ID of a ${device_name} IRQ for a given instance.
 *
 * If the instance is not connected to the PLIC, this function
 * will return `kDtPlicIrqIdNone`.
 *
 * @param dt Pointer to an instance of ${device_name}.
 * @param irq_type A ${device_name} IRQ.
 * @return The PLIC ID of the IRQ of this instance.
 */
static inline dt_plic_irq_id_t dt_${device_name}_irq_to_plic_id(
    const dt_${device_name}_t *dt,
    dt_${device_name}_irq_t irq) {
  if (dt->__internal.first_irq == kDtPlicIrqIdNone) {
    return kDtPlicIrqIdNone;
  }
  return (dt_plic_irq_id_t)((uint32_t)dt->__internal.first_irq + (uint32_t)irq);
}

/**
 * Convert a global IRQ ID to a local ${device_name} IRQ type.
 *
 * @param dt Pointer to an instance of ${device_name}.
 * @param irq A PLIC ID that belongs to this instance.
 * @return The ${device_name} IRQ, or `${snake_to_enum(f"dt_{device_name}_irq_type_count")}`.
 *
 * NOTE This function assumes that the PLIC ID belongs to the instance
 * of ${device_name} passed in parameter. In other words, it must be the case that
 * `dt_${device_name}_device_id(dt) == dt_plic_id_to_device_id(irq)`. Otherwise, this function
 * will return `${snake_to_enum(f"dt_{device_name}_irq_type_count")}`.
 */
static inline dt_${device_name}_irq_t dt_${device_name}_irq_from_plic_id(
    const dt_${device_name}_t *dt,
    dt_plic_irq_id_t irq) {
  dt_${device_name}_irq_t count = ${snake_to_enum(f"dt_{device_name}_irq_count")};
  if (irq < dt->__internal.first_irq || irq >= dt->__internal.first_irq + (dt_plic_irq_id_t)count) {
    return count;
  }
  return (dt_${device_name}_irq_t)(irq - dt->__internal.first_irq);
}

%endif
% if len(device_pins) > 0:
/**
 * Get the pin description of an instance.
 *
 * @param dt Pointer to an instance of ${device_name}.
 * @param pin Requested pin.
 * @return Description of the requested pin for this instance.
 */
static inline dt_pin_t dt_${device_name}_pin(
    const dt_${device_name}_t *dt,
    dt_${device_name}_pin_t pin) {
  return dt->__internal.pins[pin];
}
% endif
#endif  // ${include_guard}
