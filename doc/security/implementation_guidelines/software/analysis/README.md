# Guidelines for analysis of C/C++ source code

## Custom syntactical analysis

It may be useful to audit OpenTitan's C/C++ source code for proper use of certain functions.

### Recommendation: Avoid libclang bindings for Python

PR [#18719](https://github.com/lowRISC/opentitan/pull/18719) added an audit tool for `sec_mmio` functions.
The tool is written in Python and uses [libclang](https://github.com/sighingnow/libclang) to discover call sites of certain functions and analyze their parameters.
Note that "libclang" is also the name of LLVM's [C interface to Clang](https://clang.llvm.org/doxygen/group__CINDEX.html).

In PR [#19312](https://github.com/lowRISC/opentitan/pull/19312), we discovered that the Python libclang library behaves strangely when it hits a call site generated by a macro expansion.
Libclang seems to have a pointer to the `CALL_EXPR` node in the AST, but it's unable to correctly render the arguments' tokens as strings.
For more details, see issue [#19438](https://github.com/lowRISC/opentitan/issues/19438) and the upstream issue [sighingnow/libclang#61](https://github.com/sighingnow/libclang/issues/61).

As long as this issue is unresolved, future syntax analysis tools should avoid the Python libclang bindings.
The best alternative is probably to write a Clang plugin, e.g. [clang/examples/PrintFunctionNames/](https://github.com/llvm/llvm-project/tree/main/clang/examples/PrintFunctionNames) in the LLVM source tree.
However, note that there are plenty of reasons *not* to write a Clang plugin, as documented by the Chromium project in [docs/writing_clang_plugins.md](https://chromium.googlesource.com/chromium/src/+/main/docs/writing_clang_plugins.md), the primary reason being that the API is not stable.
