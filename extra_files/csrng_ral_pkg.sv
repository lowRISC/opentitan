// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package csrng_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class csrng_reg_intr_state;
  typedef class csrng_reg_intr_enable;
  typedef class csrng_reg_intr_test;
  typedef class csrng_reg_alert_test;
  typedef class csrng_reg_regwen;
  typedef class csrng_reg_ctrl;
  typedef class csrng_reg_cmd_req;
  typedef class csrng_reg_reseed_interval;
  typedef class csrng_reg_reseed_counter;
  typedef class csrng_reg_sw_cmd_sts;
  typedef class csrng_reg_genbits_vld;
  typedef class csrng_reg_genbits;
  typedef class csrng_reg_int_state_read_enable;
  typedef class csrng_reg_int_state_read_enable_regwen;
  typedef class csrng_reg_int_state_num;
  typedef class csrng_reg_int_state_val;
  typedef class csrng_reg_fips_force;
  typedef class csrng_reg_hw_exc_sts;
  typedef class csrng_reg_recov_alert_sts;
  typedef class csrng_reg_err_code;
  typedef class csrng_reg_err_code_test;
  typedef class csrng_reg_main_sm_state;
  typedef class csrng_reg_block;

  class csrng_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field cs_cmd_req_done;
    rand dv_base_reg_field cs_entropy_req;
    rand dv_base_reg_field cs_hw_inst_exc;
    rand dv_base_reg_field cs_fatal_err;

    `uvm_object_utils(csrng_reg_intr_state)

    function new(string       name = "csrng_reg_intr_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cs_cmd_req_done =
          (dv_base_reg_field::
           type_id::create("cs_cmd_req_done"));
      cs_cmd_req_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_cmd_req_done.set_original_access("W1C");
      cs_entropy_req =
          (dv_base_reg_field::
           type_id::create("cs_entropy_req"));
      cs_entropy_req.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_entropy_req.set_original_access("W1C");
      cs_hw_inst_exc =
          (dv_base_reg_field::
           type_id::create("cs_hw_inst_exc"));
      cs_hw_inst_exc.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_hw_inst_exc.set_original_access("W1C");
      cs_fatal_err =
          (dv_base_reg_field::
           type_id::create("cs_fatal_err"));
      cs_fatal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_fatal_err.set_original_access("W1C");
    endfunction : build
  endclass : csrng_reg_intr_state

  class csrng_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field cs_cmd_req_done;
    rand dv_base_reg_field cs_entropy_req;
    rand dv_base_reg_field cs_hw_inst_exc;
    rand dv_base_reg_field cs_fatal_err;

    `uvm_object_utils(csrng_reg_intr_enable)

    function new(string       name = "csrng_reg_intr_enable",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cs_cmd_req_done =
          (dv_base_reg_field::
           type_id::create("cs_cmd_req_done"));
      cs_cmd_req_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_cmd_req_done.set_original_access("RW");
      cs_entropy_req =
          (dv_base_reg_field::
           type_id::create("cs_entropy_req"));
      cs_entropy_req.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_entropy_req.set_original_access("RW");
      cs_hw_inst_exc =
          (dv_base_reg_field::
           type_id::create("cs_hw_inst_exc"));
      cs_hw_inst_exc.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_hw_inst_exc.set_original_access("RW");
      cs_fatal_err =
          (dv_base_reg_field::
           type_id::create("cs_fatal_err"));
      cs_fatal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_fatal_err.set_original_access("RW");
    endfunction : build
  endclass : csrng_reg_intr_enable

  class csrng_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field cs_cmd_req_done;
    rand dv_base_reg_field cs_entropy_req;
    rand dv_base_reg_field cs_hw_inst_exc;
    rand dv_base_reg_field cs_fatal_err;

    `uvm_object_utils(csrng_reg_intr_test)

    function new(string       name = "csrng_reg_intr_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cs_cmd_req_done =
          (dv_base_reg_field::
           type_id::create("cs_cmd_req_done"));
      cs_cmd_req_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_cmd_req_done.set_original_access("WO");
      cs_entropy_req =
          (dv_base_reg_field::
           type_id::create("cs_entropy_req"));
      cs_entropy_req.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_entropy_req.set_original_access("WO");
      cs_hw_inst_exc =
          (dv_base_reg_field::
           type_id::create("cs_hw_inst_exc"));
      cs_hw_inst_exc.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_hw_inst_exc.set_original_access("WO");
      cs_fatal_err =
          (dv_base_reg_field::
           type_id::create("cs_fatal_err"));
      cs_fatal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_fatal_err.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : csrng_reg_intr_test

  class csrng_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field recov_alert;
    rand dv_base_reg_field fatal_alert;

    `uvm_object_utils(csrng_reg_alert_test)

    function new(string       name = "csrng_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      recov_alert =
          (dv_base_reg_field::
           type_id::create("recov_alert"));
      recov_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      recov_alert.set_original_access("WO");
      fatal_alert =
          (dv_base_reg_field::
           type_id::create("fatal_alert"));
      fatal_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_alert.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : csrng_reg_alert_test

  class csrng_reg_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field regwen;

    `uvm_object_utils(csrng_reg_regwen)

    function new(string       name = "csrng_reg_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      regwen =
          (dv_base_reg_field::
           type_id::create("regwen"));
      regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      regwen.set_original_access("W0C");
    endfunction : build
  endclass : csrng_reg_regwen

  class csrng_reg_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable;
    rand dv_base_reg_field sw_app_enable;
    rand dv_base_reg_field read_int_state;
    rand dv_base_reg_field fips_force_enable;

    `uvm_object_utils(csrng_reg_ctrl)

    function new(string       name = "csrng_reg_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enable =
          (dv_base_reg_field::
           type_id::create("enable"));
      enable.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable.set_original_access("RW");
      enable.set_mubi_width(4);
      sw_app_enable =
          (dv_base_reg_field::
           type_id::create("sw_app_enable"));
      sw_app_enable.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sw_app_enable.set_original_access("RW");
      sw_app_enable.set_mubi_width(4);
      read_int_state =
          (dv_base_reg_field::
           type_id::create("read_int_state"));
      read_int_state.configure(
        .parent(this),
        .size(4),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      read_int_state.set_original_access("RW");
      read_int_state.set_mubi_width(4);
      fips_force_enable =
          (dv_base_reg_field::
           type_id::create("fips_force_enable"));
      fips_force_enable.configure(
        .parent(this),
        .size(4),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_force_enable.set_original_access("RW");
      fips_force_enable.set_mubi_width(4);
    endfunction : build
  endclass : csrng_reg_ctrl

  class csrng_reg_cmd_req extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmd_req;

    `uvm_object_utils(csrng_reg_cmd_req)

    function new(string       name = "csrng_reg_cmd_req",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmd_req =
          (dv_base_reg_field::
           type_id::create("cmd_req"));
      cmd_req.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_req.set_original_access("WO");
    endfunction : build
  endclass : csrng_reg_cmd_req

  class csrng_reg_reseed_interval extends dv_base_reg;
    // fields
    rand dv_base_reg_field reseed_interval;

    `uvm_object_utils(csrng_reg_reseed_interval)

    function new(string       name = "csrng_reg_reseed_interval",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      reseed_interval =
          (dv_base_reg_field::
           type_id::create("reseed_interval"));
      reseed_interval.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'hffffffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      reseed_interval.set_original_access("RW");
    endfunction : build
  endclass : csrng_reg_reseed_interval

  class csrng_reg_reseed_counter extends dv_base_reg;
    // fields
    rand dv_base_reg_field reseed_counter;

    `uvm_object_utils(csrng_reg_reseed_counter)

    function new(string       name = "csrng_reg_reseed_counter",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      reseed_counter =
          (dv_base_reg_field::
           type_id::create("reseed_counter_0"));
      reseed_counter.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      reseed_counter.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : csrng_reg_reseed_counter

  class csrng_reg_sw_cmd_sts extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmd_rdy;
    rand dv_base_reg_field cmd_ack;
    rand dv_base_reg_field cmd_sts;

    `uvm_object_utils(csrng_reg_sw_cmd_sts)

    function new(string       name = "csrng_reg_sw_cmd_sts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmd_rdy =
          (dv_base_reg_field::
           type_id::create("cmd_rdy"));
      cmd_rdy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_rdy.set_original_access("RO");
      cmd_ack =
          (dv_base_reg_field::
           type_id::create("cmd_ack"));
      cmd_ack.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_ack.set_original_access("RO");
      cmd_sts =
          (dv_base_reg_field::
           type_id::create("cmd_sts"));
      cmd_sts.configure(
        .parent(this),
        .size(3),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_sts.set_original_access("RO");
    endfunction : build
  endclass : csrng_reg_sw_cmd_sts

  class csrng_reg_genbits_vld extends dv_base_reg;
    // fields
    rand dv_base_reg_field genbits_vld;
    rand dv_base_reg_field genbits_fips;

    `uvm_object_utils(csrng_reg_genbits_vld)

    function new(string       name = "csrng_reg_genbits_vld",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      genbits_vld =
          (dv_base_reg_field::
           type_id::create("genbits_vld"));
      genbits_vld.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      genbits_vld.set_original_access("RO");
      genbits_fips =
          (dv_base_reg_field::
           type_id::create("genbits_fips"));
      genbits_fips.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      genbits_fips.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : csrng_reg_genbits_vld

  class csrng_reg_genbits extends dv_base_reg;
    // fields
    rand dv_base_reg_field genbits;

    `uvm_object_utils(csrng_reg_genbits)

    function new(string       name = "csrng_reg_genbits",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      genbits =
          (dv_base_reg_field::
           type_id::create("genbits"));
      genbits.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      genbits.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : csrng_reg_genbits

  class csrng_reg_int_state_read_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field int_state_read_enable;

    `uvm_object_utils(csrng_reg_int_state_read_enable)

    function new(string       name = "csrng_reg_int_state_read_enable",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      int_state_read_enable =
          (dv_base_reg_field::
           type_id::create("int_state_read_enable"));
      int_state_read_enable.configure(
        .parent(this),
        .size(3),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      int_state_read_enable.set_original_access("RW");
    endfunction : build
  endclass : csrng_reg_int_state_read_enable

  class csrng_reg_int_state_read_enable_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field int_state_read_enable_regwen;

    `uvm_object_utils(csrng_reg_int_state_read_enable_regwen)

    function new(string       name = "csrng_reg_int_state_read_enable_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      int_state_read_enable_regwen =
          (dv_base_reg_field::
           type_id::create("int_state_read_enable_regwen"));
      int_state_read_enable_regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      int_state_read_enable_regwen.set_original_access("W0C");
    endfunction : build
  endclass : csrng_reg_int_state_read_enable_regwen

  class csrng_reg_int_state_num extends dv_base_reg;
    // fields
    rand dv_base_reg_field int_state_num;

    `uvm_object_utils(csrng_reg_int_state_num)

    function new(string       name = "csrng_reg_int_state_num",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      int_state_num =
          (dv_base_reg_field::
           type_id::create("int_state_num"));
      int_state_num.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      int_state_num.set_original_access("RW");
    endfunction : build
  endclass : csrng_reg_int_state_num

  class csrng_reg_int_state_val extends dv_base_reg;
    // fields
    rand dv_base_reg_field int_state_val;

    `uvm_object_utils(csrng_reg_int_state_val)

    function new(string       name = "csrng_reg_int_state_val",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      int_state_val =
          (dv_base_reg_field::
           type_id::create("int_state_val"));
      int_state_val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      int_state_val.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : csrng_reg_int_state_val

  class csrng_reg_fips_force extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_force;

    `uvm_object_utils(csrng_reg_fips_force)

    function new(string       name = "csrng_reg_fips_force",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_force =
          (dv_base_reg_field::
           type_id::create("fips_force"));
      fips_force.configure(
        .parent(this),
        .size(3),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_force.set_original_access("RW");
    endfunction : build
  endclass : csrng_reg_fips_force

  class csrng_reg_hw_exc_sts extends dv_base_reg;
    // fields
    rand dv_base_reg_field hw_exc_sts;

    `uvm_object_utils(csrng_reg_hw_exc_sts)

    function new(string       name = "csrng_reg_hw_exc_sts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      hw_exc_sts =
          (dv_base_reg_field::
           type_id::create("hw_exc_sts"));
      hw_exc_sts.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hw_exc_sts.set_original_access("W0C");
    endfunction : build
  endclass : csrng_reg_hw_exc_sts

  class csrng_reg_recov_alert_sts extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable_field_alert;
    rand dv_base_reg_field sw_app_enable_field_alert;
    rand dv_base_reg_field read_int_state_field_alert;
    rand dv_base_reg_field fips_force_enable_field_alert;
    rand dv_base_reg_field acmd_flag0_field_alert;
    rand dv_base_reg_field cs_bus_cmp_alert;
    rand dv_base_reg_field cmd_stage_invalid_acmd_alert;
    rand dv_base_reg_field cmd_stage_invalid_cmd_seq_alert;
    rand dv_base_reg_field cmd_stage_reseed_cnt_alert;

    `uvm_object_utils(csrng_reg_recov_alert_sts)

    function new(string       name = "csrng_reg_recov_alert_sts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enable_field_alert =
          (dv_base_reg_field::
           type_id::create("enable_field_alert"));
      enable_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable_field_alert.set_original_access("W0C");
      sw_app_enable_field_alert =
          (dv_base_reg_field::
           type_id::create("sw_app_enable_field_alert"));
      sw_app_enable_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sw_app_enable_field_alert.set_original_access("W0C");
      read_int_state_field_alert =
          (dv_base_reg_field::
           type_id::create("read_int_state_field_alert"));
      read_int_state_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      read_int_state_field_alert.set_original_access("W0C");
      fips_force_enable_field_alert =
          (dv_base_reg_field::
           type_id::create("fips_force_enable_field_alert"));
      fips_force_enable_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_force_enable_field_alert.set_original_access("W0C");
      acmd_flag0_field_alert =
          (dv_base_reg_field::
           type_id::create("acmd_flag0_field_alert"));
      acmd_flag0_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acmd_flag0_field_alert.set_original_access("W0C");
      cs_bus_cmp_alert =
          (dv_base_reg_field::
           type_id::create("cs_bus_cmp_alert"));
      cs_bus_cmp_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cs_bus_cmp_alert.set_original_access("W0C");
      cmd_stage_invalid_acmd_alert =
          (dv_base_reg_field::
           type_id::create("cmd_stage_invalid_acmd_alert"));
      cmd_stage_invalid_acmd_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_stage_invalid_acmd_alert.set_original_access("W0C");
      cmd_stage_invalid_cmd_seq_alert =
          (dv_base_reg_field::
           type_id::create("cmd_stage_invalid_cmd_seq_alert"));
      cmd_stage_invalid_cmd_seq_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_stage_invalid_cmd_seq_alert.set_original_access("W0C");
      cmd_stage_reseed_cnt_alert =
          (dv_base_reg_field::
           type_id::create("cmd_stage_reseed_cnt_alert"));
      cmd_stage_reseed_cnt_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_stage_reseed_cnt_alert.set_original_access("W0C");
    endfunction : build
  endclass : csrng_reg_recov_alert_sts

  class csrng_reg_err_code extends dv_base_reg;
    // fields
    rand dv_base_reg_field sfifo_cmd_err;
    rand dv_base_reg_field sfifo_genbits_err;
    rand dv_base_reg_field sfifo_cmdreq_err;
    rand dv_base_reg_field sfifo_rcstage_err;
    rand dv_base_reg_field sfifo_keyvrc_err;
    rand dv_base_reg_field sfifo_updreq_err;
    rand dv_base_reg_field sfifo_bencreq_err;
    rand dv_base_reg_field sfifo_bencack_err;
    rand dv_base_reg_field sfifo_pdata_err;
    rand dv_base_reg_field sfifo_final_err;
    rand dv_base_reg_field sfifo_gbencack_err;
    rand dv_base_reg_field sfifo_grcstage_err;
    rand dv_base_reg_field sfifo_ggenreq_err;
    rand dv_base_reg_field sfifo_gadstage_err;
    rand dv_base_reg_field sfifo_ggenbits_err;
    rand dv_base_reg_field sfifo_blkenc_err;
    rand dv_base_reg_field cmd_stage_sm_err;
    rand dv_base_reg_field main_sm_err;
    rand dv_base_reg_field drbg_gen_sm_err;
    rand dv_base_reg_field drbg_updbe_sm_err;
    rand dv_base_reg_field drbg_updob_sm_err;
    rand dv_base_reg_field aes_cipher_sm_err;
    rand dv_base_reg_field cmd_gen_cnt_err;
    rand dv_base_reg_field fifo_write_err;
    rand dv_base_reg_field fifo_read_err;
    rand dv_base_reg_field fifo_state_err;

    `uvm_object_utils(csrng_reg_err_code)

    function new(string       name = "csrng_reg_err_code",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      sfifo_cmd_err =
          (dv_base_reg_field::
           type_id::create("sfifo_cmd_err"));
      sfifo_cmd_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_cmd_err.set_original_access("RO");
      sfifo_genbits_err =
          (dv_base_reg_field::
           type_id::create("sfifo_genbits_err"));
      sfifo_genbits_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_genbits_err.set_original_access("RO");
      sfifo_cmdreq_err =
          (dv_base_reg_field::
           type_id::create("sfifo_cmdreq_err"));
      sfifo_cmdreq_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_cmdreq_err.set_original_access("RO");
      sfifo_rcstage_err =
          (dv_base_reg_field::
           type_id::create("sfifo_rcstage_err"));
      sfifo_rcstage_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_rcstage_err.set_original_access("RO");
      sfifo_keyvrc_err =
          (dv_base_reg_field::
           type_id::create("sfifo_keyvrc_err"));
      sfifo_keyvrc_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_keyvrc_err.set_original_access("RO");
      sfifo_updreq_err =
          (dv_base_reg_field::
           type_id::create("sfifo_updreq_err"));
      sfifo_updreq_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_updreq_err.set_original_access("RO");
      sfifo_bencreq_err =
          (dv_base_reg_field::
           type_id::create("sfifo_bencreq_err"));
      sfifo_bencreq_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_bencreq_err.set_original_access("RO");
      sfifo_bencack_err =
          (dv_base_reg_field::
           type_id::create("sfifo_bencack_err"));
      sfifo_bencack_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_bencack_err.set_original_access("RO");
      sfifo_pdata_err =
          (dv_base_reg_field::
           type_id::create("sfifo_pdata_err"));
      sfifo_pdata_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_pdata_err.set_original_access("RO");
      sfifo_final_err =
          (dv_base_reg_field::
           type_id::create("sfifo_final_err"));
      sfifo_final_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_final_err.set_original_access("RO");
      sfifo_gbencack_err =
          (dv_base_reg_field::
           type_id::create("sfifo_gbencack_err"));
      sfifo_gbencack_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_gbencack_err.set_original_access("RO");
      sfifo_grcstage_err =
          (dv_base_reg_field::
           type_id::create("sfifo_grcstage_err"));
      sfifo_grcstage_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_grcstage_err.set_original_access("RO");
      sfifo_ggenreq_err =
          (dv_base_reg_field::
           type_id::create("sfifo_ggenreq_err"));
      sfifo_ggenreq_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_ggenreq_err.set_original_access("RO");
      sfifo_gadstage_err =
          (dv_base_reg_field::
           type_id::create("sfifo_gadstage_err"));
      sfifo_gadstage_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_gadstage_err.set_original_access("RO");
      sfifo_ggenbits_err =
          (dv_base_reg_field::
           type_id::create("sfifo_ggenbits_err"));
      sfifo_ggenbits_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_ggenbits_err.set_original_access("RO");
      sfifo_blkenc_err =
          (dv_base_reg_field::
           type_id::create("sfifo_blkenc_err"));
      sfifo_blkenc_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_blkenc_err.set_original_access("RO");
      cmd_stage_sm_err =
          (dv_base_reg_field::
           type_id::create("cmd_stage_sm_err"));
      cmd_stage_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_stage_sm_err.set_original_access("RO");
      main_sm_err =
          (dv_base_reg_field::
           type_id::create("main_sm_err"));
      main_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(21),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      main_sm_err.set_original_access("RO");
      drbg_gen_sm_err =
          (dv_base_reg_field::
           type_id::create("drbg_gen_sm_err"));
      drbg_gen_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(22),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      drbg_gen_sm_err.set_original_access("RO");
      drbg_updbe_sm_err =
          (dv_base_reg_field::
           type_id::create("drbg_updbe_sm_err"));
      drbg_updbe_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(23),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      drbg_updbe_sm_err.set_original_access("RO");
      drbg_updob_sm_err =
          (dv_base_reg_field::
           type_id::create("drbg_updob_sm_err"));
      drbg_updob_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(24),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      drbg_updob_sm_err.set_original_access("RO");
      aes_cipher_sm_err =
          (dv_base_reg_field::
           type_id::create("aes_cipher_sm_err"));
      aes_cipher_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(25),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      aes_cipher_sm_err.set_original_access("RO");
      cmd_gen_cnt_err =
          (dv_base_reg_field::
           type_id::create("cmd_gen_cnt_err"));
      cmd_gen_cnt_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(26),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_gen_cnt_err.set_original_access("RO");
      fifo_write_err =
          (dv_base_reg_field::
           type_id::create("fifo_write_err"));
      fifo_write_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(28),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_write_err.set_original_access("RO");
      fifo_read_err =
          (dv_base_reg_field::
           type_id::create("fifo_read_err"));
      fifo_read_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(29),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_read_err.set_original_access("RO");
      fifo_state_err =
          (dv_base_reg_field::
           type_id::create("fifo_state_err"));
      fifo_state_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_state_err.set_original_access("RO");
    endfunction : build
  endclass : csrng_reg_err_code

  class csrng_reg_err_code_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field err_code_test;

    `uvm_object_utils(csrng_reg_err_code_test)

    function new(string       name = "csrng_reg_err_code_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      err_code_test =
          (dv_base_reg_field::
           type_id::create("err_code_test"));
      err_code_test.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_code_test.set_original_access("RW");
    endfunction : build
  endclass : csrng_reg_err_code_test

  class csrng_reg_main_sm_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field main_sm_state;

    `uvm_object_utils(csrng_reg_main_sm_state)

    function new(string       name = "csrng_reg_main_sm_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      main_sm_state =
          (dv_base_reg_field::
           type_id::create("main_sm_state"));
      main_sm_state.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h4e),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      main_sm_state.set_original_access("RO");
    endfunction : build
  endclass : csrng_reg_main_sm_state

  class csrng_reg_block extends dv_base_reg_block;
    // registers
    rand csrng_reg_intr_state intr_state;
    rand csrng_reg_intr_enable intr_enable;
    rand csrng_reg_intr_test intr_test;
    rand csrng_reg_alert_test alert_test;
    rand csrng_reg_regwen regwen;
    rand csrng_reg_ctrl ctrl;
    rand csrng_reg_cmd_req cmd_req;
    rand csrng_reg_reseed_interval reseed_interval;
    rand csrng_reg_reseed_counter reseed_counter[3];
    rand csrng_reg_sw_cmd_sts sw_cmd_sts;
    rand csrng_reg_genbits_vld genbits_vld;
    rand csrng_reg_genbits genbits;
    rand csrng_reg_int_state_read_enable int_state_read_enable;
    rand csrng_reg_int_state_read_enable_regwen int_state_read_enable_regwen;
    rand csrng_reg_int_state_num int_state_num;
    rand csrng_reg_int_state_val int_state_val;
    rand csrng_reg_fips_force fips_force;
    rand csrng_reg_hw_exc_sts hw_exc_sts;
    rand csrng_reg_recov_alert_sts recov_alert_sts;
    rand csrng_reg_err_code err_code;
    rand csrng_reg_err_code_test err_code_test;
    rand csrng_reg_main_sm_state main_sm_state;

    `uvm_object_utils(csrng_reg_block)

    function new(string name = "csrng_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (csrng_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_cs_cmd_req_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_cs_entropy_req.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_cs_hw_inst_exc.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_cs_fatal_err.q",
          3, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (csrng_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_cs_cmd_req_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_cs_entropy_req.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_cs_hw_inst_exc.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_cs_fatal_err.q",
          3, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (csrng_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_cs_cmd_req_done.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_cs_entropy_req.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_cs_hw_inst_exc.qs",
          2, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_cs_fatal_err.qs",
          3, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (csrng_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_recov_alert.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_alert.qs",
          1, 1, 0, "BkdrRegPathRtl");

      regwen =
          (csrng_reg_regwen::
           type_id::create("regwen"));
      regwen.configure(.blk_parent(this));
      regwen.build(csr_excl);
      default_map.add_reg(.rg(regwen),
                          .offset(32'h10));
      regwen.add_hdl_path_slice(
          "u_reg.u_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      ctrl =
          (csrng_reg_ctrl::
           type_id::create("ctrl"));
      ctrl.configure(.blk_parent(this));
      ctrl.build(csr_excl);
      default_map.add_reg(.rg(ctrl),
                          .offset(32'h14));
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_enable.q",
          0, 4, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_sw_app_enable.q",
          4, 4, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_read_int_state.q",
          8, 4, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_fips_force_enable.q",
          12, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(ctrl.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      cmd_req =
          (csrng_reg_cmd_req::
           type_id::create("cmd_req"));
      cmd_req.configure(.blk_parent(this));
      cmd_req.build(csr_excl);
      default_map.add_reg(.rg(cmd_req),
                          .offset(32'h18));
      cmd_req.add_hdl_path_slice(
          "u_reg.u_cmd_req.q",
          0, 32, 0, "BkdrRegPathRtl");

      reseed_interval =
          (csrng_reg_reseed_interval::
           type_id::create("reseed_interval"));
      reseed_interval.configure(.blk_parent(this));
      reseed_interval.build(csr_excl);
      default_map.add_reg(.rg(reseed_interval),
                          .offset(32'h1c));
      reseed_interval.add_hdl_path_slice(
          "u_reg.u_reseed_interval.q",
          0, 32, 0, "BkdrRegPathRtl");

      reseed_counter[0] =
          (csrng_reg_reseed_counter::
           type_id::create("reseed_counter_0"));
      reseed_counter[0].configure(.blk_parent(this));
      reseed_counter[0].build(csr_excl);
      default_map.add_reg(.rg(reseed_counter[0]),
                          .offset(32'h20));
      reseed_counter[0].add_hdl_path_slice(
          "u_reg.u_reseed_counter_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      reseed_counter[1] =
          (csrng_reg_reseed_counter::
           type_id::create("reseed_counter_1"));
      reseed_counter[1].configure(.blk_parent(this));
      reseed_counter[1].build(csr_excl);
      default_map.add_reg(.rg(reseed_counter[1]),
                          .offset(32'h24));
      reseed_counter[1].add_hdl_path_slice(
          "u_reg.u_reseed_counter_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      reseed_counter[2] =
          (csrng_reg_reseed_counter::
           type_id::create("reseed_counter_2"));
      reseed_counter[2].configure(.blk_parent(this));
      reseed_counter[2].build(csr_excl);
      default_map.add_reg(.rg(reseed_counter[2]),
                          .offset(32'h28));
      reseed_counter[2].add_hdl_path_slice(
          "u_reg.u_reseed_counter_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      sw_cmd_sts =
          (csrng_reg_sw_cmd_sts::
           type_id::create("sw_cmd_sts"));
      sw_cmd_sts.configure(.blk_parent(this));
      sw_cmd_sts.build(csr_excl);
      default_map.add_reg(.rg(sw_cmd_sts),
                          .offset(32'h2c));
      sw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_sw_cmd_sts_cmd_rdy.q",
          1, 1, 0, "BkdrRegPathRtl");
      sw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_sw_cmd_sts_cmd_ack.q",
          2, 1, 0, "BkdrRegPathRtl");
      sw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_sw_cmd_sts_cmd_sts.q",
          3, 3, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_cmd_sts.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      genbits_vld =
          (csrng_reg_genbits_vld::
           type_id::create("genbits_vld"));
      genbits_vld.configure(.blk_parent(this));
      genbits_vld.build(csr_excl);
      default_map.add_reg(.rg(genbits_vld),
                          .offset(32'h30));
      genbits_vld.add_hdl_path_slice(
          "u_reg.u_genbits_vld_genbits_vld.qs",
          0, 1, 0, "BkdrRegPathRtl");
      genbits_vld.add_hdl_path_slice(
          "u_reg.u_genbits_vld_genbits_fips.qs",
          1, 1, 0, "BkdrRegPathRtl");

      genbits =
          (csrng_reg_genbits::
           type_id::create("genbits"));
      genbits.configure(.blk_parent(this));
      genbits.build(csr_excl);
      default_map.add_reg(.rg(genbits),
                          .offset(32'h34));
      genbits.add_hdl_path_slice(
          "u_reg.u_genbits.qs",
          0, 32, 0, "BkdrRegPathRtl");

      int_state_read_enable =
          (csrng_reg_int_state_read_enable::
           type_id::create("int_state_read_enable"));
      int_state_read_enable.configure(.blk_parent(this));
      int_state_read_enable.build(csr_excl);
      default_map.add_reg(.rg(int_state_read_enable),
                          .offset(32'h38));
      int_state_read_enable.add_hdl_path_slice(
          "u_reg.u_int_state_read_enable.q",
          0, 3, 0, "BkdrRegPathRtl");

      int_state_read_enable_regwen =
          (csrng_reg_int_state_read_enable_regwen::
           type_id::create("int_state_read_enable_regwen"));
      int_state_read_enable_regwen.configure(.blk_parent(this));
      int_state_read_enable_regwen.build(csr_excl);
      default_map.add_reg(.rg(int_state_read_enable_regwen),
                          .offset(32'h3c));
      int_state_read_enable_regwen.add_hdl_path_slice(
          "u_reg.u_int_state_read_enable_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      int_state_num =
          (csrng_reg_int_state_num::
           type_id::create("int_state_num"));
      int_state_num.configure(.blk_parent(this));
      int_state_num.build(csr_excl);
      default_map.add_reg(.rg(int_state_num),
                          .offset(32'h40));
      int_state_num.add_hdl_path_slice(
          "u_reg.u_int_state_num.q",
          0, 4, 0, "BkdrRegPathRtl");

      int_state_val =
          (csrng_reg_int_state_val::
           type_id::create("int_state_val"));
      int_state_val.configure(.blk_parent(this));
      int_state_val.build(csr_excl);
      default_map.add_reg(.rg(int_state_val),
                          .offset(32'h44));
      int_state_val.add_hdl_path_slice(
          "u_reg.u_int_state_val.qs",
          0, 32, 0, "BkdrRegPathRtl");

      fips_force =
          (csrng_reg_fips_force::
           type_id::create("fips_force"));
      fips_force.configure(.blk_parent(this));
      fips_force.build(csr_excl);
      default_map.add_reg(.rg(fips_force),
                          .offset(32'h48));
      fips_force.add_hdl_path_slice(
          "u_reg.u_fips_force.q",
          0, 3, 0, "BkdrRegPathRtl");

      hw_exc_sts =
          (csrng_reg_hw_exc_sts::
           type_id::create("hw_exc_sts"));
      hw_exc_sts.configure(.blk_parent(this));
      hw_exc_sts.build(csr_excl);
      default_map.add_reg(.rg(hw_exc_sts),
                          .offset(32'h4c));
      hw_exc_sts.add_hdl_path_slice(
          "u_reg.u_hw_exc_sts.q",
          0, 16, 0, "BkdrRegPathRtl");

      recov_alert_sts =
          (csrng_reg_recov_alert_sts::
           type_id::create("recov_alert_sts"));
      recov_alert_sts.configure(.blk_parent(this));
      recov_alert_sts.build(csr_excl);
      default_map.add_reg(.rg(recov_alert_sts),
                          .offset(32'h50));
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_enable_field_alert.q",
          0, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_sw_app_enable_field_alert.q",
          1, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_read_int_state_field_alert.q",
          2, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_fips_force_enable_field_alert.q",
          3, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_acmd_flag0_field_alert.q",
          4, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_cs_bus_cmp_alert.q",
          12, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_cmd_stage_invalid_acmd_alert.q",
          13, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_cmd_stage_invalid_cmd_seq_alert.q",
          14, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_cmd_stage_reseed_cnt_alert.q",
          15, 1, 0, "BkdrRegPathRtl");

      err_code =
          (csrng_reg_err_code::
           type_id::create("err_code"));
      err_code.configure(.blk_parent(this));
      err_code.build(csr_excl);
      default_map.add_reg(.rg(err_code),
                          .offset(32'h54));
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_cmd_err.q",
          0, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_genbits_err.q",
          1, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_cmdreq_err.q",
          2, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_rcstage_err.q",
          3, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_keyvrc_err.q",
          4, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_updreq_err.q",
          5, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_bencreq_err.q",
          6, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_bencack_err.q",
          7, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_pdata_err.q",
          8, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_final_err.q",
          9, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_gbencack_err.q",
          10, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_grcstage_err.q",
          11, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_ggenreq_err.q",
          12, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_gadstage_err.q",
          13, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_ggenbits_err.q",
          14, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_blkenc_err.q",
          15, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_cmd_stage_sm_err.q",
          20, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_main_sm_err.q",
          21, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_drbg_gen_sm_err.q",
          22, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_drbg_updbe_sm_err.q",
          23, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_drbg_updob_sm_err.q",
          24, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_aes_cipher_sm_err.q",
          25, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_cmd_gen_cnt_err.q",
          26, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_fifo_write_err.q",
          28, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_fifo_read_err.q",
          29, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_fifo_state_err.q",
          30, 1, 0, "BkdrRegPathRtl");

      err_code_test =
          (csrng_reg_err_code_test::
           type_id::create("err_code_test"));
      err_code_test.configure(.blk_parent(this));
      err_code_test.build(csr_excl);
      default_map.add_reg(.rg(err_code_test),
                          .offset(32'h58));
      err_code_test.add_hdl_path_slice(
          "u_reg.u_err_code_test.q",
          0, 5, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(err_code_test.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      main_sm_state =
          (csrng_reg_main_sm_state::
           type_id::create("main_sm_state"));
      main_sm_state.configure(.blk_parent(this));
      main_sm_state.build(csr_excl);
      default_map.add_reg(.rg(main_sm_state),
                          .offset(32'h5c));
      main_sm_state.add_hdl_path_slice(
          "u_reg.u_main_sm_state.q",
          0, 8, 0, "BkdrRegPathRtl");

      // assign locked reg to its regwen reg
      regwen.add_lockable_reg_or_fld(ctrl);
      int_state_read_enable_regwen.add_lockable_reg_or_fld(int_state_read_enable);
      regwen.add_lockable_reg_or_fld(fips_force);
      regwen.add_lockable_reg_or_fld(err_code_test);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : csrng_reg_block

endpackage

