// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package sram_ctrl_regs_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class sram_ctrl_regs_reg_alert_test;
  typedef class sram_ctrl_regs_reg_status;
  typedef class sram_ctrl_regs_reg_exec_regwen;
  typedef class sram_ctrl_regs_reg_exec;
  typedef class sram_ctrl_regs_reg_ctrl_regwen;
  typedef class sram_ctrl_regs_reg_ctrl;
  typedef class sram_ctrl_regs_reg_scr_key_rotated;
  typedef class sram_ctrl_regs_reg_readback_regwen;
  typedef class sram_ctrl_regs_reg_readback;
  typedef class sram_ctrl_regs_reg_block;

  class sram_ctrl_regs_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_error;

    `uvm_object_utils(sram_ctrl_regs_reg_alert_test)

    function new(string       name = "sram_ctrl_regs_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_error =
          (dv_base_reg_field::
           type_id::create("fatal_error"));
      fatal_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_error.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : sram_ctrl_regs_reg_alert_test

  class sram_ctrl_regs_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field bus_integ_error;
    rand dv_base_reg_field init_error;
    rand dv_base_reg_field escalated;
    rand dv_base_reg_field scr_key_valid;
    rand dv_base_reg_field scr_key_seed_valid;
    rand dv_base_reg_field init_done;
    rand dv_base_reg_field readback_error;
    rand dv_base_reg_field sram_alert;

    `uvm_object_utils(sram_ctrl_regs_reg_status)

    function new(string       name = "sram_ctrl_regs_reg_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      bus_integ_error =
          (dv_base_reg_field::
           type_id::create("bus_integ_error"));
      bus_integ_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus_integ_error.set_original_access("RO");
      init_error =
          (dv_base_reg_field::
           type_id::create("init_error"));
      init_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      init_error.set_original_access("RO");
      escalated =
          (dv_base_reg_field::
           type_id::create("escalated"));
      escalated.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      escalated.set_original_access("RO");
      scr_key_valid =
          (dv_base_reg_field::
           type_id::create("scr_key_valid"));
      scr_key_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      scr_key_valid.set_original_access("RO");
      scr_key_seed_valid =
          (dv_base_reg_field::
           type_id::create("scr_key_seed_valid"));
      scr_key_seed_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      scr_key_seed_valid.set_original_access("RO");
      init_done =
          (dv_base_reg_field::
           type_id::create("init_done"));
      init_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      init_done.set_original_access("RO");
      readback_error =
          (dv_base_reg_field::
           type_id::create("readback_error"));
      readback_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      readback_error.set_original_access("RO");
      sram_alert =
          (dv_base_reg_field::
           type_id::create("sram_alert"));
      sram_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sram_alert.set_original_access("RO");
    endfunction : build
  endclass : sram_ctrl_regs_reg_status

  class sram_ctrl_regs_reg_exec_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field exec_regwen;

    `uvm_object_utils(sram_ctrl_regs_reg_exec_regwen)

    function new(string       name = "sram_ctrl_regs_reg_exec_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      exec_regwen =
          (dv_base_reg_field::
           type_id::create("exec_regwen"));
      exec_regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      exec_regwen.set_original_access("W0C");
    endfunction : build
  endclass : sram_ctrl_regs_reg_exec_regwen

  class sram_ctrl_regs_reg_exec extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(sram_ctrl_regs_reg_exec)

    function new(string       name = "sram_ctrl_regs_reg_exec",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
      en.set_mubi_width(4);
    endfunction : build
  endclass : sram_ctrl_regs_reg_exec

  class sram_ctrl_regs_reg_ctrl_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field ctrl_regwen;

    `uvm_object_utils(sram_ctrl_regs_reg_ctrl_regwen)

    function new(string       name = "sram_ctrl_regs_reg_ctrl_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ctrl_regwen =
          (dv_base_reg_field::
           type_id::create("ctrl_regwen"));
      ctrl_regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ctrl_regwen.set_original_access("W0C");
    endfunction : build
  endclass : sram_ctrl_regs_reg_ctrl_regwen

  class sram_ctrl_regs_reg_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field renew_scr_key;
    rand dv_base_reg_field init;

    `uvm_object_utils(sram_ctrl_regs_reg_ctrl)

    function new(string       name = "sram_ctrl_regs_reg_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      renew_scr_key =
          (dv_base_reg_field::
           type_id::create("renew_scr_key"));
      renew_scr_key.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      renew_scr_key.set_original_access("WO");
      init =
          (dv_base_reg_field::
           type_id::create("init"));
      init.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      init.set_original_access("WO");
    endfunction : build
  endclass : sram_ctrl_regs_reg_ctrl

  class sram_ctrl_regs_reg_scr_key_rotated extends dv_base_reg;
    // fields
    rand dv_base_reg_field success;

    `uvm_object_utils(sram_ctrl_regs_reg_scr_key_rotated)

    function new(string       name = "sram_ctrl_regs_reg_scr_key_rotated",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      success =
          (dv_base_reg_field::
           type_id::create("success"));
      success.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("W1C"),
        .volatile(1),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      success.set_original_access("RW");
      success.set_mubi_width(4);
    endfunction : build
  endclass : sram_ctrl_regs_reg_scr_key_rotated

  class sram_ctrl_regs_reg_readback_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field readback_regwen;

    `uvm_object_utils(sram_ctrl_regs_reg_readback_regwen)

    function new(string       name = "sram_ctrl_regs_reg_readback_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      readback_regwen =
          (dv_base_reg_field::
           type_id::create("readback_regwen"));
      readback_regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      readback_regwen.set_original_access("W0C");
    endfunction : build
  endclass : sram_ctrl_regs_reg_readback_regwen

  class sram_ctrl_regs_reg_readback extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(sram_ctrl_regs_reg_readback)

    function new(string       name = "sram_ctrl_regs_reg_readback",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
      en.set_mubi_width(4);
    endfunction : build
  endclass : sram_ctrl_regs_reg_readback

  class sram_ctrl_regs_reg_block extends dv_base_reg_block;
    // registers
    rand sram_ctrl_regs_reg_alert_test alert_test;
    rand sram_ctrl_regs_reg_status status;
    rand sram_ctrl_regs_reg_exec_regwen exec_regwen;
    rand sram_ctrl_regs_reg_exec exec;
    rand sram_ctrl_regs_reg_ctrl_regwen ctrl_regwen;
    rand sram_ctrl_regs_reg_ctrl ctrl;
    rand sram_ctrl_regs_reg_scr_key_rotated scr_key_rotated;
    rand sram_ctrl_regs_reg_readback_regwen readback_regwen;
    rand sram_ctrl_regs_reg_readback readback;

    `uvm_object_utils(sram_ctrl_regs_reg_block)

    function new(string name = "sram_ctrl_regs_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      alert_test =
          (sram_ctrl_regs_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'h0));
      alert_test.add_hdl_path_slice(
          "u_reg_regs.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      status =
          (sram_ctrl_regs_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h4));
      status.add_hdl_path_slice(
          "u_reg_regs.u_status_bus_integ_error.q",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_regs.u_status_init_error.q",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_regs.u_status_escalated.q",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_regs.u_status_scr_key_valid.q",
          3, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_regs.u_status_scr_key_seed_valid.q",
          4, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_regs.u_status_init_done.q",
          5, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_regs.u_status_readback_error.q",
          6, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_regs.u_status_sram_alert.q",
          7, 1, 0, "BkdrRegPathRtl");

      exec_regwen =
          (sram_ctrl_regs_reg_exec_regwen::
           type_id::create("exec_regwen"));
      exec_regwen.configure(.blk_parent(this));
      exec_regwen.build(csr_excl);
      default_map.add_reg(.rg(exec_regwen),
                          .offset(32'h8));
      exec_regwen.add_hdl_path_slice(
          "u_reg_regs.u_exec_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      exec =
          (sram_ctrl_regs_reg_exec::
           type_id::create("exec"));
      exec.configure(.blk_parent(this));
      exec.build(csr_excl);
      default_map.add_reg(.rg(exec),
                          .offset(32'hc));
      exec.add_hdl_path_slice(
          "u_reg_regs.u_exec.q",
          0, 4, 0, "BkdrRegPathRtl");

      ctrl_regwen =
          (sram_ctrl_regs_reg_ctrl_regwen::
           type_id::create("ctrl_regwen"));
      ctrl_regwen.configure(.blk_parent(this));
      ctrl_regwen.build(csr_excl);
      default_map.add_reg(.rg(ctrl_regwen),
                          .offset(32'h10));
      ctrl_regwen.add_hdl_path_slice(
          "u_reg_regs.u_ctrl_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      ctrl =
          (sram_ctrl_regs_reg_ctrl::
           type_id::create("ctrl"));
      ctrl.configure(.blk_parent(this));
      ctrl.build(csr_excl);
      default_map.add_reg(.rg(ctrl),
                          .offset(32'h14));
      ctrl.add_hdl_path_slice(
          "u_reg_regs.u_ctrl_renew_scr_key.q",
          0, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg_regs.u_ctrl_init.q",
          1, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(ctrl.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      scr_key_rotated =
          (sram_ctrl_regs_reg_scr_key_rotated::
           type_id::create("scr_key_rotated"));
      scr_key_rotated.configure(.blk_parent(this));
      scr_key_rotated.build(csr_excl);
      default_map.add_reg(.rg(scr_key_rotated),
                          .offset(32'h18));
      scr_key_rotated.add_hdl_path_slice(
          "u_reg_regs.u_scr_key_rotated.q",
          0, 4, 0, "BkdrRegPathRtl");

      readback_regwen =
          (sram_ctrl_regs_reg_readback_regwen::
           type_id::create("readback_regwen"));
      readback_regwen.configure(.blk_parent(this));
      readback_regwen.build(csr_excl);
      default_map.add_reg(.rg(readback_regwen),
                          .offset(32'h1c));
      readback_regwen.add_hdl_path_slice(
          "u_reg_regs.u_readback_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(readback_regwen.get_full_name(),
                        CsrExclAll, CsrAllTests);
      readback =
          (sram_ctrl_regs_reg_readback::
           type_id::create("readback"));
      readback.configure(.blk_parent(this));
      readback.build(csr_excl);
      default_map.add_reg(.rg(readback),
                          .offset(32'h20));
      readback.add_hdl_path_slice(
          "u_reg_regs.u_readback.q",
          0, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(readback.get_full_name(),
                        CsrExclAll, CsrAllTests);
      // assign locked reg to its regwen reg
      exec_regwen.add_lockable_reg_or_fld(exec);
      ctrl_regwen.add_lockable_reg_or_fld(ctrl);
      readback_regwen.add_lockable_reg_or_fld(readback);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : sram_ctrl_regs_reg_block

endpackage

