// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package i2c_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class i2c_reg_intr_state;
  typedef class i2c_reg_intr_enable;
  typedef class i2c_reg_intr_test;
  typedef class i2c_reg_alert_test;
  typedef class i2c_reg_ctrl;
  typedef class i2c_reg_status;
  typedef class i2c_reg_rdata;
  typedef class i2c_reg_fdata;
  typedef class i2c_reg_fifo_ctrl;
  typedef class i2c_reg_host_fifo_config;
  typedef class i2c_reg_target_fifo_config;
  typedef class i2c_reg_host_fifo_status;
  typedef class i2c_reg_target_fifo_status;
  typedef class i2c_reg_ovrd;
  typedef class i2c_reg_val;
  typedef class i2c_reg_timing0;
  typedef class i2c_reg_timing1;
  typedef class i2c_reg_timing2;
  typedef class i2c_reg_timing3;
  typedef class i2c_reg_timing4;
  typedef class i2c_reg_timeout_ctrl;
  typedef class i2c_reg_target_id;
  typedef class i2c_reg_acqdata;
  typedef class i2c_reg_txdata;
  typedef class i2c_reg_host_timeout_ctrl;
  typedef class i2c_reg_target_timeout_ctrl;
  typedef class i2c_reg_target_nack_count;
  typedef class i2c_reg_target_ack_ctrl;
  typedef class i2c_reg_acq_fifo_next_data;
  typedef class i2c_reg_host_nack_handler_timeout;
  typedef class i2c_reg_controller_events;
  typedef class i2c_reg_target_events;
  typedef class i2c_reg_block;

  class i2c_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field fmt_threshold;
    rand dv_base_reg_field rx_threshold;
    rand dv_base_reg_field acq_threshold;
    rand dv_base_reg_field rx_overflow;
    rand dv_base_reg_field controller_halt;
    rand dv_base_reg_field scl_interference;
    rand dv_base_reg_field sda_interference;
    rand dv_base_reg_field stretch_timeout;
    rand dv_base_reg_field sda_unstable;
    rand dv_base_reg_field cmd_complete;
    rand dv_base_reg_field tx_stretch;
    rand dv_base_reg_field tx_threshold;
    rand dv_base_reg_field acq_stretch;
    rand dv_base_reg_field unexp_stop;
    rand dv_base_reg_field host_timeout;

    `uvm_object_utils(i2c_reg_intr_state)

    function new(string       name = "i2c_reg_intr_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fmt_threshold =
          (dv_base_reg_field::
           type_id::create("fmt_threshold"));
      fmt_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fmt_threshold.set_original_access("RO");
      rx_threshold =
          (dv_base_reg_field::
           type_id::create("rx_threshold"));
      rx_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_threshold.set_original_access("RO");
      acq_threshold =
          (dv_base_reg_field::
           type_id::create("acq_threshold"));
      acq_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acq_threshold.set_original_access("RO");
      rx_overflow =
          (dv_base_reg_field::
           type_id::create("rx_overflow"));
      rx_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_overflow.set_original_access("W1C");
      controller_halt =
          (dv_base_reg_field::
           type_id::create("controller_halt"));
      controller_halt.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      controller_halt.set_original_access("RO");
      scl_interference =
          (dv_base_reg_field::
           type_id::create("scl_interference"));
      scl_interference.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      scl_interference.set_original_access("W1C");
      sda_interference =
          (dv_base_reg_field::
           type_id::create("sda_interference"));
      sda_interference.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sda_interference.set_original_access("W1C");
      stretch_timeout =
          (dv_base_reg_field::
           type_id::create("stretch_timeout"));
      stretch_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      stretch_timeout.set_original_access("W1C");
      sda_unstable =
          (dv_base_reg_field::
           type_id::create("sda_unstable"));
      sda_unstable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sda_unstable.set_original_access("W1C");
      cmd_complete =
          (dv_base_reg_field::
           type_id::create("cmd_complete"));
      cmd_complete.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_complete.set_original_access("W1C");
      tx_stretch =
          (dv_base_reg_field::
           type_id::create("tx_stretch"));
      tx_stretch.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_stretch.set_original_access("RO");
      tx_threshold =
          (dv_base_reg_field::
           type_id::create("tx_threshold"));
      tx_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_threshold.set_original_access("RO");
      acq_stretch =
          (dv_base_reg_field::
           type_id::create("acq_stretch"));
      acq_stretch.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acq_stretch.set_original_access("RO");
      unexp_stop =
          (dv_base_reg_field::
           type_id::create("unexp_stop"));
      unexp_stop.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      unexp_stop.set_original_access("W1C");
      host_timeout =
          (dv_base_reg_field::
           type_id::create("host_timeout"));
      host_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      host_timeout.set_original_access("W1C");
    endfunction : build
  endclass : i2c_reg_intr_state

  class i2c_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field fmt_threshold;
    rand dv_base_reg_field rx_threshold;
    rand dv_base_reg_field acq_threshold;
    rand dv_base_reg_field rx_overflow;
    rand dv_base_reg_field controller_halt;
    rand dv_base_reg_field scl_interference;
    rand dv_base_reg_field sda_interference;
    rand dv_base_reg_field stretch_timeout;
    rand dv_base_reg_field sda_unstable;
    rand dv_base_reg_field cmd_complete;
    rand dv_base_reg_field tx_stretch;
    rand dv_base_reg_field tx_threshold;
    rand dv_base_reg_field acq_stretch;
    rand dv_base_reg_field unexp_stop;
    rand dv_base_reg_field host_timeout;

    `uvm_object_utils(i2c_reg_intr_enable)

    function new(string       name = "i2c_reg_intr_enable",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fmt_threshold =
          (dv_base_reg_field::
           type_id::create("fmt_threshold"));
      fmt_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fmt_threshold.set_original_access("RW");
      rx_threshold =
          (dv_base_reg_field::
           type_id::create("rx_threshold"));
      rx_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_threshold.set_original_access("RW");
      acq_threshold =
          (dv_base_reg_field::
           type_id::create("acq_threshold"));
      acq_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acq_threshold.set_original_access("RW");
      rx_overflow =
          (dv_base_reg_field::
           type_id::create("rx_overflow"));
      rx_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_overflow.set_original_access("RW");
      controller_halt =
          (dv_base_reg_field::
           type_id::create("controller_halt"));
      controller_halt.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      controller_halt.set_original_access("RW");
      scl_interference =
          (dv_base_reg_field::
           type_id::create("scl_interference"));
      scl_interference.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      scl_interference.set_original_access("RW");
      sda_interference =
          (dv_base_reg_field::
           type_id::create("sda_interference"));
      sda_interference.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sda_interference.set_original_access("RW");
      stretch_timeout =
          (dv_base_reg_field::
           type_id::create("stretch_timeout"));
      stretch_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      stretch_timeout.set_original_access("RW");
      sda_unstable =
          (dv_base_reg_field::
           type_id::create("sda_unstable"));
      sda_unstable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sda_unstable.set_original_access("RW");
      cmd_complete =
          (dv_base_reg_field::
           type_id::create("cmd_complete"));
      cmd_complete.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_complete.set_original_access("RW");
      tx_stretch =
          (dv_base_reg_field::
           type_id::create("tx_stretch"));
      tx_stretch.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_stretch.set_original_access("RW");
      tx_threshold =
          (dv_base_reg_field::
           type_id::create("tx_threshold"));
      tx_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_threshold.set_original_access("RW");
      acq_stretch =
          (dv_base_reg_field::
           type_id::create("acq_stretch"));
      acq_stretch.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acq_stretch.set_original_access("RW");
      unexp_stop =
          (dv_base_reg_field::
           type_id::create("unexp_stop"));
      unexp_stop.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      unexp_stop.set_original_access("RW");
      host_timeout =
          (dv_base_reg_field::
           type_id::create("host_timeout"));
      host_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      host_timeout.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_intr_enable

  class i2c_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fmt_threshold;
    rand dv_base_reg_field rx_threshold;
    rand dv_base_reg_field acq_threshold;
    rand dv_base_reg_field rx_overflow;
    rand dv_base_reg_field controller_halt;
    rand dv_base_reg_field scl_interference;
    rand dv_base_reg_field sda_interference;
    rand dv_base_reg_field stretch_timeout;
    rand dv_base_reg_field sda_unstable;
    rand dv_base_reg_field cmd_complete;
    rand dv_base_reg_field tx_stretch;
    rand dv_base_reg_field tx_threshold;
    rand dv_base_reg_field acq_stretch;
    rand dv_base_reg_field unexp_stop;
    rand dv_base_reg_field host_timeout;

    `uvm_object_utils(i2c_reg_intr_test)

    function new(string       name = "i2c_reg_intr_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fmt_threshold =
          (dv_base_reg_field::
           type_id::create("fmt_threshold"));
      fmt_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fmt_threshold.set_original_access("WO");
      rx_threshold =
          (dv_base_reg_field::
           type_id::create("rx_threshold"));
      rx_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_threshold.set_original_access("WO");
      acq_threshold =
          (dv_base_reg_field::
           type_id::create("acq_threshold"));
      acq_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acq_threshold.set_original_access("WO");
      rx_overflow =
          (dv_base_reg_field::
           type_id::create("rx_overflow"));
      rx_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_overflow.set_original_access("WO");
      controller_halt =
          (dv_base_reg_field::
           type_id::create("controller_halt"));
      controller_halt.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      controller_halt.set_original_access("WO");
      scl_interference =
          (dv_base_reg_field::
           type_id::create("scl_interference"));
      scl_interference.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      scl_interference.set_original_access("WO");
      sda_interference =
          (dv_base_reg_field::
           type_id::create("sda_interference"));
      sda_interference.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sda_interference.set_original_access("WO");
      stretch_timeout =
          (dv_base_reg_field::
           type_id::create("stretch_timeout"));
      stretch_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      stretch_timeout.set_original_access("WO");
      sda_unstable =
          (dv_base_reg_field::
           type_id::create("sda_unstable"));
      sda_unstable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sda_unstable.set_original_access("WO");
      cmd_complete =
          (dv_base_reg_field::
           type_id::create("cmd_complete"));
      cmd_complete.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_complete.set_original_access("WO");
      tx_stretch =
          (dv_base_reg_field::
           type_id::create("tx_stretch"));
      tx_stretch.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_stretch.set_original_access("WO");
      tx_threshold =
          (dv_base_reg_field::
           type_id::create("tx_threshold"));
      tx_threshold.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_threshold.set_original_access("WO");
      acq_stretch =
          (dv_base_reg_field::
           type_id::create("acq_stretch"));
      acq_stretch.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acq_stretch.set_original_access("WO");
      unexp_stop =
          (dv_base_reg_field::
           type_id::create("unexp_stop"));
      unexp_stop.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      unexp_stop.set_original_access("WO");
      host_timeout =
          (dv_base_reg_field::
           type_id::create("host_timeout"));
      host_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      host_timeout.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_intr_test

  class i2c_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(i2c_reg_alert_test)

    function new(string       name = "i2c_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_alert_test

  class i2c_reg_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field enablehost;
    rand dv_base_reg_field enabletarget;
    rand dv_base_reg_field llpbk;
    rand dv_base_reg_field nack_addr_after_timeout;
    rand dv_base_reg_field ack_ctrl_en;
    rand dv_base_reg_field multi_controller_monitor_en;
    rand dv_base_reg_field tx_stretch_ctrl_en;

    `uvm_object_utils(i2c_reg_ctrl)

    function new(string       name = "i2c_reg_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enablehost =
          (dv_base_reg_field::
           type_id::create("enablehost"));
      enablehost.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enablehost.set_original_access("RW");
      enabletarget =
          (dv_base_reg_field::
           type_id::create("enabletarget"));
      enabletarget.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enabletarget.set_original_access("RW");
      llpbk =
          (dv_base_reg_field::
           type_id::create("llpbk"));
      llpbk.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      llpbk.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(llpbk.get_full_name(), CsrExclWrite, CsrAllTests);
      nack_addr_after_timeout =
          (dv_base_reg_field::
           type_id::create("nack_addr_after_timeout"));
      nack_addr_after_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nack_addr_after_timeout.set_original_access("RW");
      ack_ctrl_en =
          (dv_base_reg_field::
           type_id::create("ack_ctrl_en"));
      ack_ctrl_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ack_ctrl_en.set_original_access("RW");
      multi_controller_monitor_en =
          (dv_base_reg_field::
           type_id::create("multi_controller_monitor_en"));
      multi_controller_monitor_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      multi_controller_monitor_en.set_original_access("RW");
      tx_stretch_ctrl_en =
          (dv_base_reg_field::
           type_id::create("tx_stretch_ctrl_en"));
      tx_stretch_ctrl_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_stretch_ctrl_en.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_ctrl

  class i2c_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field fmtfull;
    rand dv_base_reg_field rxfull;
    rand dv_base_reg_field fmtempty;
    rand dv_base_reg_field hostidle;
    rand dv_base_reg_field targetidle;
    rand dv_base_reg_field rxempty;
    rand dv_base_reg_field txfull;
    rand dv_base_reg_field acqfull;
    rand dv_base_reg_field txempty;
    rand dv_base_reg_field acqempty;
    rand dv_base_reg_field ack_ctrl_stretch;

    `uvm_object_utils(i2c_reg_status)

    function new(string       name = "i2c_reg_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fmtfull =
          (dv_base_reg_field::
           type_id::create("fmtfull"));
      fmtfull.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fmtfull.set_original_access("RO");
      rxfull =
          (dv_base_reg_field::
           type_id::create("rxfull"));
      rxfull.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxfull.set_original_access("RO");
      fmtempty =
          (dv_base_reg_field::
           type_id::create("fmtempty"));
      fmtempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fmtempty.set_original_access("RO");
      hostidle =
          (dv_base_reg_field::
           type_id::create("hostidle"));
      hostidle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hostidle.set_original_access("RO");
      targetidle =
          (dv_base_reg_field::
           type_id::create("targetidle"));
      targetidle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      targetidle.set_original_access("RO");
      rxempty =
          (dv_base_reg_field::
           type_id::create("rxempty"));
      rxempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxempty.set_original_access("RO");
      txfull =
          (dv_base_reg_field::
           type_id::create("txfull"));
      txfull.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txfull.set_original_access("RO");
      acqfull =
          (dv_base_reg_field::
           type_id::create("acqfull"));
      acqfull.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acqfull.set_original_access("RO");
      txempty =
          (dv_base_reg_field::
           type_id::create("txempty"));
      txempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txempty.set_original_access("RO");
      acqempty =
          (dv_base_reg_field::
           type_id::create("acqempty"));
      acqempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acqempty.set_original_access("RO");
      ack_ctrl_stretch =
          (dv_base_reg_field::
           type_id::create("ack_ctrl_stretch"));
      ack_ctrl_stretch.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ack_ctrl_stretch.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_status

  class i2c_reg_rdata extends dv_base_reg;
    // fields
    rand dv_base_reg_field rdata;

    `uvm_object_utils(i2c_reg_rdata)

    function new(string       name = "i2c_reg_rdata",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rdata =
          (dv_base_reg_field::
           type_id::create("rdata"));
      rdata.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rdata.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_rdata

  class i2c_reg_fdata extends dv_base_reg;
    // fields
    rand dv_base_reg_field fbyte;
    rand dv_base_reg_field start;
    rand dv_base_reg_field stop;
    rand dv_base_reg_field readb;
    rand dv_base_reg_field rcont;
    rand dv_base_reg_field nakok;

    `uvm_object_utils(i2c_reg_fdata)

    function new(string       name = "i2c_reg_fdata",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fbyte =
          (dv_base_reg_field::
           type_id::create("fbyte"));
      fbyte.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fbyte.set_original_access("WO");
      start =
          (dv_base_reg_field::
           type_id::create("start"));
      start.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      start.set_original_access("WO");
      stop =
          (dv_base_reg_field::
           type_id::create("stop"));
      stop.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      stop.set_original_access("WO");
      readb =
          (dv_base_reg_field::
           type_id::create("readb"));
      readb.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      readb.set_original_access("WO");
      rcont =
          (dv_base_reg_field::
           type_id::create("rcont"));
      rcont.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rcont.set_original_access("WO");
      nakok =
          (dv_base_reg_field::
           type_id::create("nakok"));
      nakok.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nakok.set_original_access("WO");
    endfunction : build
  endclass : i2c_reg_fdata

  class i2c_reg_fifo_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field rxrst;
    rand dv_base_reg_field fmtrst;
    rand dv_base_reg_field acqrst;
    rand dv_base_reg_field txrst;

    `uvm_object_utils(i2c_reg_fifo_ctrl)

    function new(string       name = "i2c_reg_fifo_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rxrst =
          (dv_base_reg_field::
           type_id::create("rxrst"));
      rxrst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxrst.set_original_access("WO");
      fmtrst =
          (dv_base_reg_field::
           type_id::create("fmtrst"));
      fmtrst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fmtrst.set_original_access("WO");
      acqrst =
          (dv_base_reg_field::
           type_id::create("acqrst"));
      acqrst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acqrst.set_original_access("WO");
      txrst =
          (dv_base_reg_field::
           type_id::create("txrst"));
      txrst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txrst.set_original_access("WO");
    endfunction : build
  endclass : i2c_reg_fifo_ctrl

  class i2c_reg_host_fifo_config extends dv_base_reg;
    // fields
    rand dv_base_reg_field rx_thresh;
    rand dv_base_reg_field fmt_thresh;

    `uvm_object_utils(i2c_reg_host_fifo_config)

    function new(string       name = "i2c_reg_host_fifo_config",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rx_thresh =
          (dv_base_reg_field::
           type_id::create("rx_thresh"));
      rx_thresh.configure(
        .parent(this),
        .size(12),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_thresh.set_original_access("RW");
      fmt_thresh =
          (dv_base_reg_field::
           type_id::create("fmt_thresh"));
      fmt_thresh.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fmt_thresh.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_host_fifo_config

  class i2c_reg_target_fifo_config extends dv_base_reg;
    // fields
    rand dv_base_reg_field tx_thresh;
    rand dv_base_reg_field acq_thresh;

    `uvm_object_utils(i2c_reg_target_fifo_config)

    function new(string       name = "i2c_reg_target_fifo_config",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tx_thresh =
          (dv_base_reg_field::
           type_id::create("tx_thresh"));
      tx_thresh.configure(
        .parent(this),
        .size(12),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_thresh.set_original_access("RW");
      acq_thresh =
          (dv_base_reg_field::
           type_id::create("acq_thresh"));
      acq_thresh.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acq_thresh.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_target_fifo_config

  class i2c_reg_host_fifo_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field fmtlvl;
    rand dv_base_reg_field rxlvl;

    `uvm_object_utils(i2c_reg_host_fifo_status)

    function new(string       name = "i2c_reg_host_fifo_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fmtlvl =
          (dv_base_reg_field::
           type_id::create("fmtlvl"));
      fmtlvl.configure(
        .parent(this),
        .size(12),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fmtlvl.set_original_access("RO");
      rxlvl =
          (dv_base_reg_field::
           type_id::create("rxlvl"));
      rxlvl.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxlvl.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_host_fifo_status

  class i2c_reg_target_fifo_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field txlvl;
    rand dv_base_reg_field acqlvl;

    `uvm_object_utils(i2c_reg_target_fifo_status)

    function new(string       name = "i2c_reg_target_fifo_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      txlvl =
          (dv_base_reg_field::
           type_id::create("txlvl"));
      txlvl.configure(
        .parent(this),
        .size(12),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txlvl.set_original_access("RO");
      acqlvl =
          (dv_base_reg_field::
           type_id::create("acqlvl"));
      acqlvl.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acqlvl.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_target_fifo_status

  class i2c_reg_ovrd extends dv_base_reg;
    // fields
    rand dv_base_reg_field txovrden;
    rand dv_base_reg_field sclval;
    rand dv_base_reg_field sdaval;

    `uvm_object_utils(i2c_reg_ovrd)

    function new(string       name = "i2c_reg_ovrd",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      txovrden =
          (dv_base_reg_field::
           type_id::create("txovrden"));
      txovrden.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txovrden.set_original_access("RW");
      sclval =
          (dv_base_reg_field::
           type_id::create("sclval"));
      sclval.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sclval.set_original_access("RW");
      sdaval =
          (dv_base_reg_field::
           type_id::create("sdaval"));
      sdaval.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sdaval.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_ovrd

  class i2c_reg_val extends dv_base_reg;
    // fields
    rand dv_base_reg_field scl_rx;
    rand dv_base_reg_field sda_rx;

    `uvm_object_utils(i2c_reg_val)

    function new(string       name = "i2c_reg_val",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      scl_rx =
          (dv_base_reg_field::
           type_id::create("scl_rx"));
      scl_rx.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      scl_rx.set_original_access("RO");
      sda_rx =
          (dv_base_reg_field::
           type_id::create("sda_rx"));
      sda_rx.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sda_rx.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_val

  class i2c_reg_timing0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field thigh;
    rand dv_base_reg_field tlow;

    `uvm_object_utils(i2c_reg_timing0)

    function new(string       name = "i2c_reg_timing0",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      thigh =
          (dv_base_reg_field::
           type_id::create("thigh"));
      thigh.configure(
        .parent(this),
        .size(13),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      thigh.set_original_access("RW");
      tlow =
          (dv_base_reg_field::
           type_id::create("tlow"));
      tlow.configure(
        .parent(this),
        .size(13),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tlow.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_timing0

  class i2c_reg_timing1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field t_r;
    rand dv_base_reg_field t_f;

    `uvm_object_utils(i2c_reg_timing1)

    function new(string       name = "i2c_reg_timing1",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      t_r =
          (dv_base_reg_field::
           type_id::create("t_r"));
      t_r.configure(
        .parent(this),
        .size(10),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      t_r.set_original_access("RW");
      t_f =
          (dv_base_reg_field::
           type_id::create("t_f"));
      t_f.configure(
        .parent(this),
        .size(9),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      t_f.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_timing1

  class i2c_reg_timing2 extends dv_base_reg;
    // fields
    rand dv_base_reg_field tsu_sta;
    rand dv_base_reg_field thd_sta;

    `uvm_object_utils(i2c_reg_timing2)

    function new(string       name = "i2c_reg_timing2",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tsu_sta =
          (dv_base_reg_field::
           type_id::create("tsu_sta"));
      tsu_sta.configure(
        .parent(this),
        .size(13),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tsu_sta.set_original_access("RW");
      thd_sta =
          (dv_base_reg_field::
           type_id::create("thd_sta"));
      thd_sta.configure(
        .parent(this),
        .size(13),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      thd_sta.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_timing2

  class i2c_reg_timing3 extends dv_base_reg;
    // fields
    rand dv_base_reg_field tsu_dat;
    rand dv_base_reg_field thd_dat;

    `uvm_object_utils(i2c_reg_timing3)

    function new(string       name = "i2c_reg_timing3",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tsu_dat =
          (dv_base_reg_field::
           type_id::create("tsu_dat"));
      tsu_dat.configure(
        .parent(this),
        .size(9),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tsu_dat.set_original_access("RW");
      thd_dat =
          (dv_base_reg_field::
           type_id::create("thd_dat"));
      thd_dat.configure(
        .parent(this),
        .size(13),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      thd_dat.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_timing3

  class i2c_reg_timing4 extends dv_base_reg;
    // fields
    rand dv_base_reg_field tsu_sto;
    rand dv_base_reg_field t_buf;

    `uvm_object_utils(i2c_reg_timing4)

    function new(string       name = "i2c_reg_timing4",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tsu_sto =
          (dv_base_reg_field::
           type_id::create("tsu_sto"));
      tsu_sto.configure(
        .parent(this),
        .size(13),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tsu_sto.set_original_access("RW");
      t_buf =
          (dv_base_reg_field::
           type_id::create("t_buf"));
      t_buf.configure(
        .parent(this),
        .size(13),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      t_buf.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_timing4

  class i2c_reg_timeout_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;
    rand dv_base_reg_field mode;
    rand dv_base_reg_field en;

    `uvm_object_utils(i2c_reg_timeout_ctrl)

    function new(string       name = "i2c_reg_timeout_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val"));
      val.configure(
        .parent(this),
        .size(30),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
      mode =
          (dv_base_reg_field::
           type_id::create("mode"));
      mode.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mode.set_original_access("RW");
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_timeout_ctrl

  class i2c_reg_target_id extends dv_base_reg;
    // fields
    rand dv_base_reg_field address0;
    rand dv_base_reg_field mask0;
    rand dv_base_reg_field address1;
    rand dv_base_reg_field mask1;

    `uvm_object_utils(i2c_reg_target_id)

    function new(string       name = "i2c_reg_target_id",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      address0 =
          (dv_base_reg_field::
           type_id::create("address0"));
      address0.configure(
        .parent(this),
        .size(7),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      address0.set_original_access("RW");
      mask0 =
          (dv_base_reg_field::
           type_id::create("mask0"));
      mask0.configure(
        .parent(this),
        .size(7),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mask0.set_original_access("RW");
      address1 =
          (dv_base_reg_field::
           type_id::create("address1"));
      address1.configure(
        .parent(this),
        .size(7),
        .lsb_pos(14),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      address1.set_original_access("RW");
      mask1 =
          (dv_base_reg_field::
           type_id::create("mask1"));
      mask1.configure(
        .parent(this),
        .size(7),
        .lsb_pos(21),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mask1.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_target_id

  class i2c_reg_acqdata extends dv_base_reg;
    // fields
    rand dv_base_reg_field abyte;
    rand dv_base_reg_field signal;

    `uvm_object_utils(i2c_reg_acqdata)

    function new(string       name = "i2c_reg_acqdata",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      abyte =
          (dv_base_reg_field::
           type_id::create("abyte"));
      abyte.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      abyte.set_original_access("RO");
      signal =
          (dv_base_reg_field::
           type_id::create("signal"));
      signal.configure(
        .parent(this),
        .size(3),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      signal.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_acqdata

  class i2c_reg_txdata extends dv_base_reg;
    // fields
    rand dv_base_reg_field txdata;

    `uvm_object_utils(i2c_reg_txdata)

    function new(string       name = "i2c_reg_txdata",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      txdata =
          (dv_base_reg_field::
           type_id::create("txdata"));
      txdata.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txdata.set_original_access("WO");
    endfunction : build
  endclass : i2c_reg_txdata

  class i2c_reg_host_timeout_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field host_timeout_ctrl;

    `uvm_object_utils(i2c_reg_host_timeout_ctrl)

    function new(string       name = "i2c_reg_host_timeout_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      host_timeout_ctrl =
          (dv_base_reg_field::
           type_id::create("host_timeout_ctrl"));
      host_timeout_ctrl.configure(
        .parent(this),
        .size(20),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      host_timeout_ctrl.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_host_timeout_ctrl

  class i2c_reg_target_timeout_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;
    rand dv_base_reg_field en;

    `uvm_object_utils(i2c_reg_target_timeout_ctrl)

    function new(string       name = "i2c_reg_target_timeout_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val"));
      val.configure(
        .parent(this),
        .size(31),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_target_timeout_ctrl

  class i2c_reg_target_nack_count extends dv_base_reg;
    // fields
    rand dv_base_reg_field target_nack_count;

    `uvm_object_utils(i2c_reg_target_nack_count)

    function new(string       name = "i2c_reg_target_nack_count",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      target_nack_count =
          (dv_base_reg_field::
           type_id::create("target_nack_count"));
      target_nack_count.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RC"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      target_nack_count.set_original_access("RC");
    endfunction : build
  endclass : i2c_reg_target_nack_count

  class i2c_reg_target_ack_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field nbytes;
    rand dv_base_reg_field nack;

    `uvm_object_utils(i2c_reg_target_ack_ctrl)

    function new(string       name = "i2c_reg_target_ack_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      nbytes =
          (dv_base_reg_field::
           type_id::create("nbytes"));
      nbytes.configure(
        .parent(this),
        .size(9),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nbytes.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(nbytes.get_full_name(), CsrExclWriteCheck, CsrNonInitTests);
      nack =
          (dv_base_reg_field::
           type_id::create("nack"));
      nack.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nack.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_target_ack_ctrl

  class i2c_reg_acq_fifo_next_data extends dv_base_reg;
    // fields
    rand dv_base_reg_field acq_fifo_next_data;

    `uvm_object_utils(i2c_reg_acq_fifo_next_data)

    function new(string       name = "i2c_reg_acq_fifo_next_data",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      acq_fifo_next_data =
          (dv_base_reg_field::
           type_id::create("acq_fifo_next_data"));
      acq_fifo_next_data.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      acq_fifo_next_data.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : i2c_reg_acq_fifo_next_data

  class i2c_reg_host_nack_handler_timeout extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;
    rand dv_base_reg_field en;

    `uvm_object_utils(i2c_reg_host_nack_handler_timeout)

    function new(string       name = "i2c_reg_host_nack_handler_timeout",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val"));
      val.configure(
        .parent(this),
        .size(31),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
    endfunction : build
  endclass : i2c_reg_host_nack_handler_timeout

  class i2c_reg_controller_events extends dv_base_reg;
    // fields
    rand dv_base_reg_field nack;
    rand dv_base_reg_field unhandled_nack_timeout;
    rand dv_base_reg_field bus_timeout;
    rand dv_base_reg_field arbitration_lost;

    `uvm_object_utils(i2c_reg_controller_events)

    function new(string       name = "i2c_reg_controller_events",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      nack =
          (dv_base_reg_field::
           type_id::create("nack"));
      nack.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nack.set_original_access("W1C");
      unhandled_nack_timeout =
          (dv_base_reg_field::
           type_id::create("unhandled_nack_timeout"));
      unhandled_nack_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      unhandled_nack_timeout.set_original_access("W1C");
      bus_timeout =
          (dv_base_reg_field::
           type_id::create("bus_timeout"));
      bus_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus_timeout.set_original_access("W1C");
      arbitration_lost =
          (dv_base_reg_field::
           type_id::create("arbitration_lost"));
      arbitration_lost.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      arbitration_lost.set_original_access("W1C");
    endfunction : build
  endclass : i2c_reg_controller_events

  class i2c_reg_target_events extends dv_base_reg;
    // fields
    rand dv_base_reg_field tx_pending;
    rand dv_base_reg_field bus_timeout;
    rand dv_base_reg_field arbitration_lost;

    `uvm_object_utils(i2c_reg_target_events)

    function new(string       name = "i2c_reg_target_events",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tx_pending =
          (dv_base_reg_field::
           type_id::create("tx_pending"));
      tx_pending.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_pending.set_original_access("W1C");
      bus_timeout =
          (dv_base_reg_field::
           type_id::create("bus_timeout"));
      bus_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus_timeout.set_original_access("W1C");
      arbitration_lost =
          (dv_base_reg_field::
           type_id::create("arbitration_lost"));
      arbitration_lost.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      arbitration_lost.set_original_access("W1C");
    endfunction : build
  endclass : i2c_reg_target_events

  class i2c_reg_block extends dv_base_reg_block;
    // registers
    rand i2c_reg_intr_state intr_state;
    rand i2c_reg_intr_enable intr_enable;
    rand i2c_reg_intr_test intr_test;
    rand i2c_reg_alert_test alert_test;
    rand i2c_reg_ctrl ctrl;
    rand i2c_reg_status status;
    rand i2c_reg_rdata rdata;
    rand i2c_reg_fdata fdata;
    rand i2c_reg_fifo_ctrl fifo_ctrl;
    rand i2c_reg_host_fifo_config host_fifo_config;
    rand i2c_reg_target_fifo_config target_fifo_config;
    rand i2c_reg_host_fifo_status host_fifo_status;
    rand i2c_reg_target_fifo_status target_fifo_status;
    rand i2c_reg_ovrd ovrd;
    rand i2c_reg_val val;
    rand i2c_reg_timing0 timing0;
    rand i2c_reg_timing1 timing1;
    rand i2c_reg_timing2 timing2;
    rand i2c_reg_timing3 timing3;
    rand i2c_reg_timing4 timing4;
    rand i2c_reg_timeout_ctrl timeout_ctrl;
    rand i2c_reg_target_id target_id;
    rand i2c_reg_acqdata acqdata;
    rand i2c_reg_txdata txdata;
    rand i2c_reg_host_timeout_ctrl host_timeout_ctrl;
    rand i2c_reg_target_timeout_ctrl target_timeout_ctrl;
    rand i2c_reg_target_nack_count target_nack_count;
    rand i2c_reg_target_ack_ctrl target_ack_ctrl;
    rand i2c_reg_acq_fifo_next_data acq_fifo_next_data;
    rand i2c_reg_host_nack_handler_timeout host_nack_handler_timeout;
    rand i2c_reg_controller_events controller_events;
    rand i2c_reg_target_events target_events;

    `uvm_object_utils(i2c_reg_block)

    function new(string name = "i2c_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (i2c_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_fmt_threshold.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_threshold.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_acq_threshold.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_overflow.q",
          3, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_controller_halt.q",
          4, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_scl_interference.q",
          5, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_sda_interference.q",
          6, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_stretch_timeout.q",
          7, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_sda_unstable.q",
          8, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_cmd_complete.q",
          9, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_tx_stretch.q",
          10, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_tx_threshold.q",
          11, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_acq_stretch.q",
          12, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_unexp_stop.q",
          13, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_host_timeout.q",
          14, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (i2c_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_fmt_threshold.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_threshold.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_acq_threshold.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_overflow.q",
          3, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_controller_halt.q",
          4, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_scl_interference.q",
          5, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_sda_interference.q",
          6, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_stretch_timeout.q",
          7, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_sda_unstable.q",
          8, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_cmd_complete.q",
          9, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_tx_stretch.q",
          10, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_tx_threshold.q",
          11, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_acq_stretch.q",
          12, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_unexp_stop.q",
          13, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_host_timeout.q",
          14, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (i2c_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_fmt_threshold.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_threshold.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_acq_threshold.qs",
          2, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_overflow.qs",
          3, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_controller_halt.qs",
          4, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_scl_interference.qs",
          5, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_sda_interference.qs",
          6, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_stretch_timeout.qs",
          7, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_sda_unstable.qs",
          8, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_cmd_complete.qs",
          9, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_tx_stretch.qs",
          10, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_tx_threshold.qs",
          11, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_acq_stretch.qs",
          12, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_unexp_stop.qs",
          13, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_host_timeout.qs",
          14, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (i2c_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      ctrl =
          (i2c_reg_ctrl::
           type_id::create("ctrl"));
      ctrl.configure(.blk_parent(this));
      ctrl.build(csr_excl);
      default_map.add_reg(.rg(ctrl),
                          .offset(32'h10));
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_enablehost.q",
          0, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_enabletarget.q",
          1, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_llpbk.q",
          2, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_nack_addr_after_timeout.q",
          3, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_ack_ctrl_en.q",
          4, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_multi_controller_monitor_en.q",
          5, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_tx_stretch_ctrl_en.q",
          6, 1, 0, "BkdrRegPathRtl");

      status =
          (i2c_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h14));
      status.add_hdl_path_slice(
          "u_reg.u_status_fmtfull.qs",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxfull.qs",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_fmtempty.qs",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_hostidle.qs",
          3, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_targetidle.qs",
          4, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxempty.qs",
          5, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_txfull.qs",
          6, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_acqfull.qs",
          7, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_txempty.qs",
          8, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_acqempty.qs",
          9, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_ack_ctrl_stretch.qs",
          10, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(status.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      rdata =
          (i2c_reg_rdata::
           type_id::create("rdata"));
      rdata.configure(.blk_parent(this));
      rdata.build(csr_excl);
      default_map.add_reg(.rg(rdata),
                          .offset(32'h18));
      rdata.add_hdl_path_slice(
          "u_reg.u_rdata.qs",
          0, 8, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(rdata.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      fdata =
          (i2c_reg_fdata::
           type_id::create("fdata"));
      fdata.configure(.blk_parent(this));
      fdata.build(csr_excl);
      default_map.add_reg(.rg(fdata),
                          .offset(32'h1c));
      fdata.add_hdl_path_slice(
          "u_reg.u_fdata_fbyte.q",
          0, 8, 0, "BkdrRegPathRtl");
      fdata.add_hdl_path_slice(
          "u_reg.u_fdata_start.q",
          8, 1, 0, "BkdrRegPathRtl");
      fdata.add_hdl_path_slice(
          "u_reg.u_fdata_stop.q",
          9, 1, 0, "BkdrRegPathRtl");
      fdata.add_hdl_path_slice(
          "u_reg.u_fdata_readb.q",
          10, 1, 0, "BkdrRegPathRtl");
      fdata.add_hdl_path_slice(
          "u_reg.u_fdata_rcont.q",
          11, 1, 0, "BkdrRegPathRtl");
      fdata.add_hdl_path_slice(
          "u_reg.u_fdata_nakok.q",
          12, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(fdata.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      fifo_ctrl =
          (i2c_reg_fifo_ctrl::
           type_id::create("fifo_ctrl"));
      fifo_ctrl.configure(.blk_parent(this));
      fifo_ctrl.build(csr_excl);
      default_map.add_reg(.rg(fifo_ctrl),
                          .offset(32'h20));
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_rxrst.q",
          0, 1, 0, "BkdrRegPathRtl");
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_fmtrst.q",
          1, 1, 0, "BkdrRegPathRtl");
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_acqrst.q",
          7, 1, 0, "BkdrRegPathRtl");
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_txrst.q",
          8, 1, 0, "BkdrRegPathRtl");

      host_fifo_config =
          (i2c_reg_host_fifo_config::
           type_id::create("host_fifo_config"));
      host_fifo_config.configure(.blk_parent(this));
      host_fifo_config.build(csr_excl);
      default_map.add_reg(.rg(host_fifo_config),
                          .offset(32'h24));
      host_fifo_config.add_hdl_path_slice(
          "u_reg.u_host_fifo_config_rx_thresh.q",
          0, 12, 0, "BkdrRegPathRtl");
      host_fifo_config.add_hdl_path_slice(
          "u_reg.u_host_fifo_config_fmt_thresh.q",
          16, 12, 0, "BkdrRegPathRtl");

      target_fifo_config =
          (i2c_reg_target_fifo_config::
           type_id::create("target_fifo_config"));
      target_fifo_config.configure(.blk_parent(this));
      target_fifo_config.build(csr_excl);
      default_map.add_reg(.rg(target_fifo_config),
                          .offset(32'h28));
      target_fifo_config.add_hdl_path_slice(
          "u_reg.u_target_fifo_config_tx_thresh.q",
          0, 12, 0, "BkdrRegPathRtl");
      target_fifo_config.add_hdl_path_slice(
          "u_reg.u_target_fifo_config_acq_thresh.q",
          16, 12, 0, "BkdrRegPathRtl");

      host_fifo_status =
          (i2c_reg_host_fifo_status::
           type_id::create("host_fifo_status"));
      host_fifo_status.configure(.blk_parent(this));
      host_fifo_status.build(csr_excl);
      default_map.add_reg(.rg(host_fifo_status),
                          .offset(32'h2c));
      host_fifo_status.add_hdl_path_slice(
          "u_reg.u_host_fifo_status_fmtlvl.qs",
          0, 12, 0, "BkdrRegPathRtl");
      host_fifo_status.add_hdl_path_slice(
          "u_reg.u_host_fifo_status_rxlvl.qs",
          16, 12, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(host_fifo_status.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      target_fifo_status =
          (i2c_reg_target_fifo_status::
           type_id::create("target_fifo_status"));
      target_fifo_status.configure(.blk_parent(this));
      target_fifo_status.build(csr_excl);
      default_map.add_reg(.rg(target_fifo_status),
                          .offset(32'h30));
      target_fifo_status.add_hdl_path_slice(
          "u_reg.u_target_fifo_status_txlvl.qs",
          0, 12, 0, "BkdrRegPathRtl");
      target_fifo_status.add_hdl_path_slice(
          "u_reg.u_target_fifo_status_acqlvl.qs",
          16, 12, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(target_fifo_status.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      ovrd =
          (i2c_reg_ovrd::
           type_id::create("ovrd"));
      ovrd.configure(.blk_parent(this));
      ovrd.build(csr_excl);
      default_map.add_reg(.rg(ovrd),
                          .offset(32'h34));
      ovrd.add_hdl_path_slice(
          "u_reg.u_ovrd_txovrden.q",
          0, 1, 0, "BkdrRegPathRtl");
      ovrd.add_hdl_path_slice(
          "u_reg.u_ovrd_sclval.q",
          1, 1, 0, "BkdrRegPathRtl");
      ovrd.add_hdl_path_slice(
          "u_reg.u_ovrd_sdaval.q",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(ovrd.get_full_name(),
                        CsrExclWriteCheck, CsrRwTest);
      val =
          (i2c_reg_val::
           type_id::create("val"));
      val.configure(.blk_parent(this));
      val.build(csr_excl);
      default_map.add_reg(.rg(val),
                          .offset(32'h38));
      val.add_hdl_path_slice(
          "u_reg.u_val_scl_rx.qs",
          0, 16, 0, "BkdrRegPathRtl");
      val.add_hdl_path_slice(
          "u_reg.u_val_sda_rx.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(val.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      timing0 =
          (i2c_reg_timing0::
           type_id::create("timing0"));
      timing0.configure(.blk_parent(this));
      timing0.build(csr_excl);
      default_map.add_reg(.rg(timing0),
                          .offset(32'h3c));
      timing0.add_hdl_path_slice(
          "u_reg.u_timing0_thigh.q",
          0, 13, 0, "BkdrRegPathRtl");
      timing0.add_hdl_path_slice(
          "u_reg.u_timing0_tlow.q",
          16, 13, 0, "BkdrRegPathRtl");

      timing1 =
          (i2c_reg_timing1::
           type_id::create("timing1"));
      timing1.configure(.blk_parent(this));
      timing1.build(csr_excl);
      default_map.add_reg(.rg(timing1),
                          .offset(32'h40));
      timing1.add_hdl_path_slice(
          "u_reg.u_timing1_t_r.q",
          0, 10, 0, "BkdrRegPathRtl");
      timing1.add_hdl_path_slice(
          "u_reg.u_timing1_t_f.q",
          16, 9, 0, "BkdrRegPathRtl");

      timing2 =
          (i2c_reg_timing2::
           type_id::create("timing2"));
      timing2.configure(.blk_parent(this));
      timing2.build(csr_excl);
      default_map.add_reg(.rg(timing2),
                          .offset(32'h44));
      timing2.add_hdl_path_slice(
          "u_reg.u_timing2_tsu_sta.q",
          0, 13, 0, "BkdrRegPathRtl");
      timing2.add_hdl_path_slice(
          "u_reg.u_timing2_thd_sta.q",
          16, 13, 0, "BkdrRegPathRtl");

      timing3 =
          (i2c_reg_timing3::
           type_id::create("timing3"));
      timing3.configure(.blk_parent(this));
      timing3.build(csr_excl);
      default_map.add_reg(.rg(timing3),
                          .offset(32'h48));
      timing3.add_hdl_path_slice(
          "u_reg.u_timing3_tsu_dat.q",
          0, 9, 0, "BkdrRegPathRtl");
      timing3.add_hdl_path_slice(
          "u_reg.u_timing3_thd_dat.q",
          16, 13, 0, "BkdrRegPathRtl");

      timing4 =
          (i2c_reg_timing4::
           type_id::create("timing4"));
      timing4.configure(.blk_parent(this));
      timing4.build(csr_excl);
      default_map.add_reg(.rg(timing4),
                          .offset(32'h4c));
      timing4.add_hdl_path_slice(
          "u_reg.u_timing4_tsu_sto.q",
          0, 13, 0, "BkdrRegPathRtl");
      timing4.add_hdl_path_slice(
          "u_reg.u_timing4_t_buf.q",
          16, 13, 0, "BkdrRegPathRtl");

      timeout_ctrl =
          (i2c_reg_timeout_ctrl::
           type_id::create("timeout_ctrl"));
      timeout_ctrl.configure(.blk_parent(this));
      timeout_ctrl.build(csr_excl);
      default_map.add_reg(.rg(timeout_ctrl),
                          .offset(32'h50));
      timeout_ctrl.add_hdl_path_slice(
          "u_reg.u_timeout_ctrl_val.q",
          0, 30, 0, "BkdrRegPathRtl");
      timeout_ctrl.add_hdl_path_slice(
          "u_reg.u_timeout_ctrl_mode.q",
          30, 1, 0, "BkdrRegPathRtl");
      timeout_ctrl.add_hdl_path_slice(
          "u_reg.u_timeout_ctrl_en.q",
          31, 1, 0, "BkdrRegPathRtl");

      target_id =
          (i2c_reg_target_id::
           type_id::create("target_id"));
      target_id.configure(.blk_parent(this));
      target_id.build(csr_excl);
      default_map.add_reg(.rg(target_id),
                          .offset(32'h54));
      target_id.add_hdl_path_slice(
          "u_reg.u_target_id_address0.q",
          0, 7, 0, "BkdrRegPathRtl");
      target_id.add_hdl_path_slice(
          "u_reg.u_target_id_mask0.q",
          7, 7, 0, "BkdrRegPathRtl");
      target_id.add_hdl_path_slice(
          "u_reg.u_target_id_address1.q",
          14, 7, 0, "BkdrRegPathRtl");
      target_id.add_hdl_path_slice(
          "u_reg.u_target_id_mask1.q",
          21, 7, 0, "BkdrRegPathRtl");

      acqdata =
          (i2c_reg_acqdata::
           type_id::create("acqdata"));
      acqdata.configure(.blk_parent(this));
      acqdata.build(csr_excl);
      default_map.add_reg(.rg(acqdata),
                          .offset(32'h58));
      acqdata.add_hdl_path_slice(
          "u_reg.u_acqdata_abyte.qs",
          0, 8, 0, "BkdrRegPathRtl");
      acqdata.add_hdl_path_slice(
          "u_reg.u_acqdata_signal.qs",
          8, 3, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(acqdata.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      txdata =
          (i2c_reg_txdata::
           type_id::create("txdata"));
      txdata.configure(.blk_parent(this));
      txdata.build(csr_excl);
      default_map.add_reg(.rg(txdata),
                          .offset(32'h5c));
      txdata.add_hdl_path_slice(
          "u_reg.u_txdata.q",
          0, 8, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(txdata.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      host_timeout_ctrl =
          (i2c_reg_host_timeout_ctrl::
           type_id::create("host_timeout_ctrl"));
      host_timeout_ctrl.configure(.blk_parent(this));
      host_timeout_ctrl.build(csr_excl);
      default_map.add_reg(.rg(host_timeout_ctrl),
                          .offset(32'h60));
      host_timeout_ctrl.add_hdl_path_slice(
          "u_reg.u_host_timeout_ctrl.q",
          0, 20, 0, "BkdrRegPathRtl");

      target_timeout_ctrl =
          (i2c_reg_target_timeout_ctrl::
           type_id::create("target_timeout_ctrl"));
      target_timeout_ctrl.configure(.blk_parent(this));
      target_timeout_ctrl.build(csr_excl);
      default_map.add_reg(.rg(target_timeout_ctrl),
                          .offset(32'h64));
      target_timeout_ctrl.add_hdl_path_slice(
          "u_reg.u_target_timeout_ctrl_val.q",
          0, 31, 0, "BkdrRegPathRtl");
      target_timeout_ctrl.add_hdl_path_slice(
          "u_reg.u_target_timeout_ctrl_en.q",
          31, 1, 0, "BkdrRegPathRtl");

      target_nack_count =
          (i2c_reg_target_nack_count::
           type_id::create("target_nack_count"));
      target_nack_count.configure(.blk_parent(this));
      target_nack_count.build(csr_excl);
      default_map.add_reg(.rg(target_nack_count),
                          .offset(32'h68));
      target_nack_count.add_hdl_path_slice(
          "u_reg.u_target_nack_count.q",
          0, 8, 0, "BkdrRegPathRtl");

      target_ack_ctrl =
          (i2c_reg_target_ack_ctrl::
           type_id::create("target_ack_ctrl"));
      target_ack_ctrl.configure(.blk_parent(this));
      target_ack_ctrl.build(csr_excl);
      default_map.add_reg(.rg(target_ack_ctrl),
                          .offset(32'h6c));
      target_ack_ctrl.add_hdl_path_slice(
          "u_reg.u_target_ack_ctrl_nbytes.qs",
          0, 9, 0, "BkdrRegPathRtl");
      target_ack_ctrl.add_hdl_path_slice(
          "u_reg.u_target_ack_ctrl_nack.qs",
          31, 1, 0, "BkdrRegPathRtl");

      acq_fifo_next_data =
          (i2c_reg_acq_fifo_next_data::
           type_id::create("acq_fifo_next_data"));
      acq_fifo_next_data.configure(.blk_parent(this));
      acq_fifo_next_data.build(csr_excl);
      default_map.add_reg(.rg(acq_fifo_next_data),
                          .offset(32'h70));
      acq_fifo_next_data.add_hdl_path_slice(
          "u_reg.u_acq_fifo_next_data.qs",
          0, 8, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(acq_fifo_next_data.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      host_nack_handler_timeout =
          (i2c_reg_host_nack_handler_timeout::
           type_id::create("host_nack_handler_timeout"));
      host_nack_handler_timeout.configure(.blk_parent(this));
      host_nack_handler_timeout.build(csr_excl);
      default_map.add_reg(.rg(host_nack_handler_timeout),
                          .offset(32'h74));
      host_nack_handler_timeout.add_hdl_path_slice(
          "u_reg.u_host_nack_handler_timeout_val.q",
          0, 31, 0, "BkdrRegPathRtl");
      host_nack_handler_timeout.add_hdl_path_slice(
          "u_reg.u_host_nack_handler_timeout_en.q",
          31, 1, 0, "BkdrRegPathRtl");

      controller_events =
          (i2c_reg_controller_events::
           type_id::create("controller_events"));
      controller_events.configure(.blk_parent(this));
      controller_events.build(csr_excl);
      default_map.add_reg(.rg(controller_events),
                          .offset(32'h78));
      controller_events.add_hdl_path_slice(
          "u_reg.u_controller_events_nack.q",
          0, 1, 0, "BkdrRegPathRtl");
      controller_events.add_hdl_path_slice(
          "u_reg.u_controller_events_unhandled_nack_timeout.q",
          1, 1, 0, "BkdrRegPathRtl");
      controller_events.add_hdl_path_slice(
          "u_reg.u_controller_events_bus_timeout.q",
          2, 1, 0, "BkdrRegPathRtl");
      controller_events.add_hdl_path_slice(
          "u_reg.u_controller_events_arbitration_lost.q",
          3, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(controller_events.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      target_events =
          (i2c_reg_target_events::
           type_id::create("target_events"));
      target_events.configure(.blk_parent(this));
      target_events.build(csr_excl);
      default_map.add_reg(.rg(target_events),
                          .offset(32'h7c));
      target_events.add_hdl_path_slice(
          "u_reg.u_target_events_tx_pending.q",
          0, 1, 0, "BkdrRegPathRtl");
      target_events.add_hdl_path_slice(
          "u_reg.u_target_events_bus_timeout.q",
          1, 1, 0, "BkdrRegPathRtl");
      target_events.add_hdl_path_slice(
          "u_reg.u_target_events_arbitration_lost.q",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(target_events.get_full_name(),
                        CsrExclCheck, CsrAllTests);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : i2c_reg_block

endpackage

