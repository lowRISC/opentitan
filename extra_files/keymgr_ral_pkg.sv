// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package keymgr_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class keymgr_reg_intr_state;
  typedef class keymgr_reg_intr_enable;
  typedef class keymgr_reg_intr_test;
  typedef class keymgr_reg_alert_test;
  typedef class keymgr_reg_cfg_regwen;
  typedef class keymgr_reg_start;
  typedef class keymgr_reg_control_shadowed;
  typedef class keymgr_reg_sideload_clear;
  typedef class keymgr_reg_reseed_interval_regwen;
  typedef class keymgr_reg_reseed_interval_shadowed;
  typedef class keymgr_reg_sw_binding_regwen;
  typedef class keymgr_reg_sealing_sw_binding;
  typedef class keymgr_reg_attest_sw_binding;
  typedef class keymgr_reg_salt;
  typedef class keymgr_reg_key_version;
  typedef class keymgr_reg_max_creator_key_ver_regwen;
  typedef class keymgr_reg_max_creator_key_ver_shadowed;
  typedef class keymgr_reg_max_owner_int_key_ver_regwen;
  typedef class keymgr_reg_max_owner_int_key_ver_shadowed;
  typedef class keymgr_reg_max_owner_key_ver_regwen;
  typedef class keymgr_reg_max_owner_key_ver_shadowed;
  typedef class keymgr_reg_sw_share0_output;
  typedef class keymgr_reg_sw_share1_output;
  typedef class keymgr_reg_working_state;
  typedef class keymgr_reg_op_status;
  typedef class keymgr_reg_err_code;
  typedef class keymgr_reg_fault_status;
  typedef class keymgr_reg_debug;
  typedef class keymgr_reg_block;

  class keymgr_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field op_done;

    `uvm_object_utils(keymgr_reg_intr_state)

    function new(string       name = "keymgr_reg_intr_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      op_done =
          (dv_base_reg_field::
           type_id::create("op_done"));
      op_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      op_done.set_original_access("W1C");
    endfunction : build
  endclass : keymgr_reg_intr_state

  class keymgr_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field op_done;

    `uvm_object_utils(keymgr_reg_intr_enable)

    function new(string       name = "keymgr_reg_intr_enable",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      op_done =
          (dv_base_reg_field::
           type_id::create("op_done"));
      op_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      op_done.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_intr_enable

  class keymgr_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field op_done;

    `uvm_object_utils(keymgr_reg_intr_test)

    function new(string       name = "keymgr_reg_intr_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      op_done =
          (dv_base_reg_field::
           type_id::create("op_done"));
      op_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      op_done.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : keymgr_reg_intr_test

  class keymgr_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field recov_operation_err;
    rand dv_base_reg_field fatal_fault_err;

    `uvm_object_utils(keymgr_reg_alert_test)

    function new(string       name = "keymgr_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      recov_operation_err =
          (dv_base_reg_field::
           type_id::create("recov_operation_err"));
      recov_operation_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      recov_operation_err.set_original_access("WO");
      fatal_fault_err =
          (dv_base_reg_field::
           type_id::create("fatal_fault_err"));
      fatal_fault_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault_err.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : keymgr_reg_alert_test

  class keymgr_reg_cfg_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(keymgr_reg_cfg_regwen)

    function new(string       name = "keymgr_reg_cfg_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : keymgr_reg_cfg_regwen

  class keymgr_reg_start extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(keymgr_reg_start)

    function new(string       name = "keymgr_reg_start",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(en.get_full_name(), CsrExclWrite, CsrNonInitTests);
    endfunction : build
  endclass : keymgr_reg_start

  class keymgr_reg_control_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field operation;
    rand dv_base_reg_field cdi_sel;
    rand dv_base_reg_field dest_sel;

    `uvm_object_utils(keymgr_reg_control_shadowed)

    function new(string       name = "keymgr_reg_control_shadowed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      operation =
          (dv_base_reg_field::
           type_id::create("operation"));
      operation.configure(
        .parent(this),
        .size(3),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      operation.set_original_access("RW");
      cdi_sel =
          (dv_base_reg_field::
           type_id::create("cdi_sel"));
      cdi_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cdi_sel.set_original_access("RW");
      dest_sel =
          (dv_base_reg_field::
           type_id::create("dest_sel"));
      dest_sel.configure(
        .parent(this),
        .size(2),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dest_sel.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_control_shadowed

  class keymgr_reg_sideload_clear extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_sideload_clear)

    function new(string       name = "keymgr_reg_sideload_clear",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val"));
      val.configure(
        .parent(this),
        .size(3),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_sideload_clear

  class keymgr_reg_reseed_interval_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(keymgr_reg_reseed_interval_regwen)

    function new(string       name = "keymgr_reg_reseed_interval_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("W0C");
    endfunction : build
  endclass : keymgr_reg_reseed_interval_regwen

  class keymgr_reg_reseed_interval_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_reseed_interval_shadowed)

    function new(string       name = "keymgr_reg_reseed_interval_shadowed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val"));
      val.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h100),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_reseed_interval_shadowed

  class keymgr_reg_sw_binding_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(keymgr_reg_sw_binding_regwen)

    function new(string       name = "keymgr_reg_sw_binding_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("W0C");
      set_is_ext_reg(1);
    endfunction : build
  endclass : keymgr_reg_sw_binding_regwen

  class keymgr_reg_sealing_sw_binding extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_sealing_sw_binding)

    function new(string       name = "keymgr_reg_sealing_sw_binding",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val_0"));
      val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_sealing_sw_binding

  class keymgr_reg_attest_sw_binding extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_attest_sw_binding)

    function new(string       name = "keymgr_reg_attest_sw_binding",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val_0"));
      val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_attest_sw_binding

  class keymgr_reg_salt extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_salt)

    function new(string       name = "keymgr_reg_salt",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val_0"));
      val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_salt

  class keymgr_reg_key_version extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_key_version)

    function new(string       name = "keymgr_reg_key_version",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val_0"));
      val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_key_version

  class keymgr_reg_max_creator_key_ver_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(keymgr_reg_max_creator_key_ver_regwen)

    function new(string       name = "keymgr_reg_max_creator_key_ver_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("W0C");
    endfunction : build
  endclass : keymgr_reg_max_creator_key_ver_regwen

  class keymgr_reg_max_creator_key_ver_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_max_creator_key_ver_shadowed)

    function new(string       name = "keymgr_reg_max_creator_key_ver_shadowed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val"));
      val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_max_creator_key_ver_shadowed

  class keymgr_reg_max_owner_int_key_ver_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(keymgr_reg_max_owner_int_key_ver_regwen)

    function new(string       name = "keymgr_reg_max_owner_int_key_ver_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("W0C");
    endfunction : build
  endclass : keymgr_reg_max_owner_int_key_ver_regwen

  class keymgr_reg_max_owner_int_key_ver_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_max_owner_int_key_ver_shadowed)

    function new(string       name = "keymgr_reg_max_owner_int_key_ver_shadowed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val"));
      val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_max_owner_int_key_ver_shadowed

  class keymgr_reg_max_owner_key_ver_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(keymgr_reg_max_owner_key_ver_regwen)

    function new(string       name = "keymgr_reg_max_owner_key_ver_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("W0C");
    endfunction : build
  endclass : keymgr_reg_max_owner_key_ver_regwen

  class keymgr_reg_max_owner_key_ver_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_max_owner_key_ver_shadowed)

    function new(string       name = "keymgr_reg_max_owner_key_ver_shadowed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val"));
      val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
    endfunction : build
  endclass : keymgr_reg_max_owner_key_ver_shadowed

  class keymgr_reg_sw_share0_output extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_sw_share0_output)

    function new(string       name = "keymgr_reg_sw_share0_output",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val_0"));
      val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RC"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RC");
    endfunction : build
  endclass : keymgr_reg_sw_share0_output

  class keymgr_reg_sw_share1_output extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;

    `uvm_object_utils(keymgr_reg_sw_share1_output)

    function new(string       name = "keymgr_reg_sw_share1_output",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val_0"));
      val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RC"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RC");
    endfunction : build
  endclass : keymgr_reg_sw_share1_output

  class keymgr_reg_working_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field state;

    `uvm_object_utils(keymgr_reg_working_state)

    function new(string       name = "keymgr_reg_working_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      state =
          (dv_base_reg_field::
           type_id::create("state"));
      state.configure(
        .parent(this),
        .size(3),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      state.set_original_access("RO");
    endfunction : build
  endclass : keymgr_reg_working_state

  class keymgr_reg_op_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field status;

    `uvm_object_utils(keymgr_reg_op_status)

    function new(string       name = "keymgr_reg_op_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      status =
          (dv_base_reg_field::
           type_id::create("status"));
      status.configure(
        .parent(this),
        .size(2),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      status.set_original_access("W1C");
    endfunction : build
  endclass : keymgr_reg_op_status

  class keymgr_reg_err_code extends dv_base_reg;
    // fields
    rand dv_base_reg_field invalid_op;
    rand dv_base_reg_field invalid_kmac_input;
    rand dv_base_reg_field invalid_shadow_update;

    `uvm_object_utils(keymgr_reg_err_code)

    function new(string       name = "keymgr_reg_err_code",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      invalid_op =
          (dv_base_reg_field::
           type_id::create("invalid_op"));
      invalid_op.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_op.set_original_access("W1C");
      invalid_kmac_input =
          (dv_base_reg_field::
           type_id::create("invalid_kmac_input"));
      invalid_kmac_input.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_kmac_input.set_original_access("W1C");
      invalid_shadow_update =
          (dv_base_reg_field::
           type_id::create("invalid_shadow_update"));
      invalid_shadow_update.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_shadow_update.set_original_access("W1C");
    endfunction : build
  endclass : keymgr_reg_err_code

  class keymgr_reg_fault_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmd;
    rand dv_base_reg_field kmac_fsm;
    rand dv_base_reg_field kmac_done;
    rand dv_base_reg_field kmac_op;
    rand dv_base_reg_field kmac_out;
    rand dv_base_reg_field regfile_intg;
    rand dv_base_reg_field shadow;
    rand dv_base_reg_field ctrl_fsm_intg;
    rand dv_base_reg_field ctrl_fsm_chk;
    rand dv_base_reg_field ctrl_fsm_cnt;
    rand dv_base_reg_field reseed_cnt;
    rand dv_base_reg_field side_ctrl_fsm;
    rand dv_base_reg_field side_ctrl_sel;
    rand dv_base_reg_field key_ecc;

    `uvm_object_utils(keymgr_reg_fault_status)

    function new(string       name = "keymgr_reg_fault_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmd =
          (dv_base_reg_field::
           type_id::create("cmd"));
      cmd.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd.set_original_access("RO");
      kmac_fsm =
          (dv_base_reg_field::
           type_id::create("kmac_fsm"));
      kmac_fsm.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_fsm.set_original_access("RO");
      kmac_done =
          (dv_base_reg_field::
           type_id::create("kmac_done"));
      kmac_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_done.set_original_access("RO");
      kmac_op =
          (dv_base_reg_field::
           type_id::create("kmac_op"));
      kmac_op.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_op.set_original_access("RO");
      kmac_out =
          (dv_base_reg_field::
           type_id::create("kmac_out"));
      kmac_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_out.set_original_access("RO");
      regfile_intg =
          (dv_base_reg_field::
           type_id::create("regfile_intg"));
      regfile_intg.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      regfile_intg.set_original_access("RO");
      shadow =
          (dv_base_reg_field::
           type_id::create("shadow"));
      shadow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      shadow.set_original_access("RO");
      ctrl_fsm_intg =
          (dv_base_reg_field::
           type_id::create("ctrl_fsm_intg"));
      ctrl_fsm_intg.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ctrl_fsm_intg.set_original_access("RO");
      ctrl_fsm_chk =
          (dv_base_reg_field::
           type_id::create("ctrl_fsm_chk"));
      ctrl_fsm_chk.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ctrl_fsm_chk.set_original_access("RO");
      ctrl_fsm_cnt =
          (dv_base_reg_field::
           type_id::create("ctrl_fsm_cnt"));
      ctrl_fsm_cnt.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ctrl_fsm_cnt.set_original_access("RO");
      reseed_cnt =
          (dv_base_reg_field::
           type_id::create("reseed_cnt"));
      reseed_cnt.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      reseed_cnt.set_original_access("RO");
      side_ctrl_fsm =
          (dv_base_reg_field::
           type_id::create("side_ctrl_fsm"));
      side_ctrl_fsm.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      side_ctrl_fsm.set_original_access("RO");
      side_ctrl_sel =
          (dv_base_reg_field::
           type_id::create("side_ctrl_sel"));
      side_ctrl_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      side_ctrl_sel.set_original_access("RO");
      key_ecc =
          (dv_base_reg_field::
           type_id::create("key_ecc"));
      key_ecc.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_ecc.set_original_access("RO");
    endfunction : build
  endclass : keymgr_reg_fault_status

  class keymgr_reg_debug extends dv_base_reg;
    // fields
    rand dv_base_reg_field invalid_creator_seed;
    rand dv_base_reg_field invalid_owner_seed;
    rand dv_base_reg_field invalid_dev_id;
    rand dv_base_reg_field invalid_health_state;
    rand dv_base_reg_field invalid_key_version;
    rand dv_base_reg_field invalid_key;
    rand dv_base_reg_field invalid_digest;

    `uvm_object_utils(keymgr_reg_debug)

    function new(string       name = "keymgr_reg_debug",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      invalid_creator_seed =
          (dv_base_reg_field::
           type_id::create("invalid_creator_seed"));
      invalid_creator_seed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_creator_seed.set_original_access("W0C");
      invalid_owner_seed =
          (dv_base_reg_field::
           type_id::create("invalid_owner_seed"));
      invalid_owner_seed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_owner_seed.set_original_access("W0C");
      invalid_dev_id =
          (dv_base_reg_field::
           type_id::create("invalid_dev_id"));
      invalid_dev_id.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_dev_id.set_original_access("W0C");
      invalid_health_state =
          (dv_base_reg_field::
           type_id::create("invalid_health_state"));
      invalid_health_state.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_health_state.set_original_access("W0C");
      invalid_key_version =
          (dv_base_reg_field::
           type_id::create("invalid_key_version"));
      invalid_key_version.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_key_version.set_original_access("W0C");
      invalid_key =
          (dv_base_reg_field::
           type_id::create("invalid_key"));
      invalid_key.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_key.set_original_access("W0C");
      invalid_digest =
          (dv_base_reg_field::
           type_id::create("invalid_digest"));
      invalid_digest.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_digest.set_original_access("W0C");
    endfunction : build
  endclass : keymgr_reg_debug

  class keymgr_reg_block extends dv_base_reg_block;
    // registers
    rand keymgr_reg_intr_state intr_state;
    rand keymgr_reg_intr_enable intr_enable;
    rand keymgr_reg_intr_test intr_test;
    rand keymgr_reg_alert_test alert_test;
    rand keymgr_reg_cfg_regwen cfg_regwen;
    rand keymgr_reg_start start;
    rand keymgr_reg_control_shadowed control_shadowed;
    rand keymgr_reg_sideload_clear sideload_clear;
    rand keymgr_reg_reseed_interval_regwen reseed_interval_regwen;
    rand keymgr_reg_reseed_interval_shadowed reseed_interval_shadowed;
    rand keymgr_reg_sw_binding_regwen sw_binding_regwen;
    rand keymgr_reg_sealing_sw_binding sealing_sw_binding[8];
    rand keymgr_reg_attest_sw_binding attest_sw_binding[8];
    rand keymgr_reg_salt salt[8];
    rand keymgr_reg_key_version key_version[1];
    rand keymgr_reg_max_creator_key_ver_regwen max_creator_key_ver_regwen;
    rand keymgr_reg_max_creator_key_ver_shadowed max_creator_key_ver_shadowed;
    rand keymgr_reg_max_owner_int_key_ver_regwen max_owner_int_key_ver_regwen;
    rand keymgr_reg_max_owner_int_key_ver_shadowed max_owner_int_key_ver_shadowed;
    rand keymgr_reg_max_owner_key_ver_regwen max_owner_key_ver_regwen;
    rand keymgr_reg_max_owner_key_ver_shadowed max_owner_key_ver_shadowed;
    rand keymgr_reg_sw_share0_output sw_share0_output[8];
    rand keymgr_reg_sw_share1_output sw_share1_output[8];
    rand keymgr_reg_working_state working_state;
    rand keymgr_reg_op_status op_status;
    rand keymgr_reg_err_code err_code;
    rand keymgr_reg_fault_status fault_status;
    rand keymgr_reg_debug debug;

    `uvm_object_utils(keymgr_reg_block)

    function new(string name = "keymgr_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (keymgr_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (keymgr_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable.q",
          0, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (keymgr_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (keymgr_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_recov_operation_err.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_fault_err.qs",
          1, 1, 0, "BkdrRegPathRtl");

      cfg_regwen =
          (keymgr_reg_cfg_regwen::
           type_id::create("cfg_regwen"));
      cfg_regwen.configure(.blk_parent(this));
      cfg_regwen.build(csr_excl);
      default_map.add_reg(.rg(cfg_regwen),
                          .offset(32'h10));
      cfg_regwen.add_hdl_path_slice(
          "u_reg.u_cfg_regwen.qs",
          0, 1, 0, "BkdrRegPathRtl");

      start =
          (keymgr_reg_start::
           type_id::create("start"));
      start.configure(.blk_parent(this));
      start.build(csr_excl);
      default_map.add_reg(.rg(start),
                          .offset(32'h14));
      start.add_hdl_path_slice(
          "u_reg.u_start.q",
          0, 1, 0, "BkdrRegPathRtl");

      control_shadowed =
          (keymgr_reg_control_shadowed::
           type_id::create("control_shadowed"));
      control_shadowed.configure(.blk_parent(this));
      control_shadowed.build(csr_excl);
      default_map.add_reg(.rg(control_shadowed),
                          .offset(32'h18));
      control_shadowed.add_update_err_alert("recov_operation_err");

      control_shadowed.add_storage_err_alert("fatal_fault_err");

      control_shadowed.add_hdl_path_slice(
          "u_reg.u_control_shadowed_operation.committed_reg.q",
          4, 3, 0, "BkdrRegPathRtl");
      control_shadowed.add_hdl_path_slice(
          "u_reg.u_control_shadowed_operation.shadow_reg.q",
          4, 3, 0, "BkdrRegPathRtlShadow");
      control_shadowed.add_hdl_path_slice(
          "u_reg.u_control_shadowed_cdi_sel.committed_reg.q",
          7, 1, 0, "BkdrRegPathRtl");
      control_shadowed.add_hdl_path_slice(
          "u_reg.u_control_shadowed_cdi_sel.shadow_reg.q",
          7, 1, 0, "BkdrRegPathRtlShadow");
      control_shadowed.add_hdl_path_slice(
          "u_reg.u_control_shadowed_dest_sel.committed_reg.q",
          12, 2, 0, "BkdrRegPathRtl");
      control_shadowed.add_hdl_path_slice(
          "u_reg.u_control_shadowed_dest_sel.shadow_reg.q",
          12, 2, 0, "BkdrRegPathRtlShadow");

      control_shadowed.set_is_shadowed();
      sideload_clear =
          (keymgr_reg_sideload_clear::
           type_id::create("sideload_clear"));
      sideload_clear.configure(.blk_parent(this));
      sideload_clear.build(csr_excl);
      default_map.add_reg(.rg(sideload_clear),
                          .offset(32'h1c));
      sideload_clear.add_hdl_path_slice(
          "u_reg.u_sideload_clear.q",
          0, 3, 0, "BkdrRegPathRtl");

      reseed_interval_regwen =
          (keymgr_reg_reseed_interval_regwen::
           type_id::create("reseed_interval_regwen"));
      reseed_interval_regwen.configure(.blk_parent(this));
      reseed_interval_regwen.build(csr_excl);
      default_map.add_reg(.rg(reseed_interval_regwen),
                          .offset(32'h20));
      reseed_interval_regwen.add_hdl_path_slice(
          "u_reg.u_reseed_interval_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      reseed_interval_shadowed =
          (keymgr_reg_reseed_interval_shadowed::
           type_id::create("reseed_interval_shadowed"));
      reseed_interval_shadowed.configure(.blk_parent(this));
      reseed_interval_shadowed.build(csr_excl);
      default_map.add_reg(.rg(reseed_interval_shadowed),
                          .offset(32'h24));
      reseed_interval_shadowed.add_update_err_alert("recov_operation_err");

      reseed_interval_shadowed.add_storage_err_alert("fatal_fault_err");

      reseed_interval_shadowed.add_hdl_path_slice(
          "u_reg.u_reseed_interval_shadowed.committed_reg.q",
          0, 16, 0, "BkdrRegPathRtl");
      reseed_interval_shadowed.add_hdl_path_slice(
          "u_reg.u_reseed_interval_shadowed.shadow_reg.q",
          0, 16, 0, "BkdrRegPathRtlShadow");

      reseed_interval_shadowed.set_is_shadowed();
      sw_binding_regwen =
          (keymgr_reg_sw_binding_regwen::
           type_id::create("sw_binding_regwen"));
      sw_binding_regwen.configure(.blk_parent(this));
      sw_binding_regwen.build(csr_excl);
      default_map.add_reg(.rg(sw_binding_regwen),
                          .offset(32'h28));
      sw_binding_regwen.add_hdl_path_slice(
          "u_reg.u_sw_binding_regwen.qs",
          0, 1, 0, "BkdrRegPathRtl");

      sealing_sw_binding[0] =
          (keymgr_reg_sealing_sw_binding::
           type_id::create("sealing_sw_binding_0"));
      sealing_sw_binding[0].configure(.blk_parent(this));
      sealing_sw_binding[0].build(csr_excl);
      default_map.add_reg(.rg(sealing_sw_binding[0]),
                          .offset(32'h2c));
      sealing_sw_binding[0].add_hdl_path_slice(
          "u_reg.u_sealing_sw_binding_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      sealing_sw_binding[1] =
          (keymgr_reg_sealing_sw_binding::
           type_id::create("sealing_sw_binding_1"));
      sealing_sw_binding[1].configure(.blk_parent(this));
      sealing_sw_binding[1].build(csr_excl);
      default_map.add_reg(.rg(sealing_sw_binding[1]),
                          .offset(32'h30));
      sealing_sw_binding[1].add_hdl_path_slice(
          "u_reg.u_sealing_sw_binding_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      sealing_sw_binding[2] =
          (keymgr_reg_sealing_sw_binding::
           type_id::create("sealing_sw_binding_2"));
      sealing_sw_binding[2].configure(.blk_parent(this));
      sealing_sw_binding[2].build(csr_excl);
      default_map.add_reg(.rg(sealing_sw_binding[2]),
                          .offset(32'h34));
      sealing_sw_binding[2].add_hdl_path_slice(
          "u_reg.u_sealing_sw_binding_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      sealing_sw_binding[3] =
          (keymgr_reg_sealing_sw_binding::
           type_id::create("sealing_sw_binding_3"));
      sealing_sw_binding[3].configure(.blk_parent(this));
      sealing_sw_binding[3].build(csr_excl);
      default_map.add_reg(.rg(sealing_sw_binding[3]),
                          .offset(32'h38));
      sealing_sw_binding[3].add_hdl_path_slice(
          "u_reg.u_sealing_sw_binding_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      sealing_sw_binding[4] =
          (keymgr_reg_sealing_sw_binding::
           type_id::create("sealing_sw_binding_4"));
      sealing_sw_binding[4].configure(.blk_parent(this));
      sealing_sw_binding[4].build(csr_excl);
      default_map.add_reg(.rg(sealing_sw_binding[4]),
                          .offset(32'h3c));
      sealing_sw_binding[4].add_hdl_path_slice(
          "u_reg.u_sealing_sw_binding_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      sealing_sw_binding[5] =
          (keymgr_reg_sealing_sw_binding::
           type_id::create("sealing_sw_binding_5"));
      sealing_sw_binding[5].configure(.blk_parent(this));
      sealing_sw_binding[5].build(csr_excl);
      default_map.add_reg(.rg(sealing_sw_binding[5]),
                          .offset(32'h40));
      sealing_sw_binding[5].add_hdl_path_slice(
          "u_reg.u_sealing_sw_binding_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      sealing_sw_binding[6] =
          (keymgr_reg_sealing_sw_binding::
           type_id::create("sealing_sw_binding_6"));
      sealing_sw_binding[6].configure(.blk_parent(this));
      sealing_sw_binding[6].build(csr_excl);
      default_map.add_reg(.rg(sealing_sw_binding[6]),
                          .offset(32'h44));
      sealing_sw_binding[6].add_hdl_path_slice(
          "u_reg.u_sealing_sw_binding_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      sealing_sw_binding[7] =
          (keymgr_reg_sealing_sw_binding::
           type_id::create("sealing_sw_binding_7"));
      sealing_sw_binding[7].configure(.blk_parent(this));
      sealing_sw_binding[7].build(csr_excl);
      default_map.add_reg(.rg(sealing_sw_binding[7]),
                          .offset(32'h48));
      sealing_sw_binding[7].add_hdl_path_slice(
          "u_reg.u_sealing_sw_binding_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      attest_sw_binding[0] =
          (keymgr_reg_attest_sw_binding::
           type_id::create("attest_sw_binding_0"));
      attest_sw_binding[0].configure(.blk_parent(this));
      attest_sw_binding[0].build(csr_excl);
      default_map.add_reg(.rg(attest_sw_binding[0]),
                          .offset(32'h4c));
      attest_sw_binding[0].add_hdl_path_slice(
          "u_reg.u_attest_sw_binding_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      attest_sw_binding[1] =
          (keymgr_reg_attest_sw_binding::
           type_id::create("attest_sw_binding_1"));
      attest_sw_binding[1].configure(.blk_parent(this));
      attest_sw_binding[1].build(csr_excl);
      default_map.add_reg(.rg(attest_sw_binding[1]),
                          .offset(32'h50));
      attest_sw_binding[1].add_hdl_path_slice(
          "u_reg.u_attest_sw_binding_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      attest_sw_binding[2] =
          (keymgr_reg_attest_sw_binding::
           type_id::create("attest_sw_binding_2"));
      attest_sw_binding[2].configure(.blk_parent(this));
      attest_sw_binding[2].build(csr_excl);
      default_map.add_reg(.rg(attest_sw_binding[2]),
                          .offset(32'h54));
      attest_sw_binding[2].add_hdl_path_slice(
          "u_reg.u_attest_sw_binding_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      attest_sw_binding[3] =
          (keymgr_reg_attest_sw_binding::
           type_id::create("attest_sw_binding_3"));
      attest_sw_binding[3].configure(.blk_parent(this));
      attest_sw_binding[3].build(csr_excl);
      default_map.add_reg(.rg(attest_sw_binding[3]),
                          .offset(32'h58));
      attest_sw_binding[3].add_hdl_path_slice(
          "u_reg.u_attest_sw_binding_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      attest_sw_binding[4] =
          (keymgr_reg_attest_sw_binding::
           type_id::create("attest_sw_binding_4"));
      attest_sw_binding[4].configure(.blk_parent(this));
      attest_sw_binding[4].build(csr_excl);
      default_map.add_reg(.rg(attest_sw_binding[4]),
                          .offset(32'h5c));
      attest_sw_binding[4].add_hdl_path_slice(
          "u_reg.u_attest_sw_binding_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      attest_sw_binding[5] =
          (keymgr_reg_attest_sw_binding::
           type_id::create("attest_sw_binding_5"));
      attest_sw_binding[5].configure(.blk_parent(this));
      attest_sw_binding[5].build(csr_excl);
      default_map.add_reg(.rg(attest_sw_binding[5]),
                          .offset(32'h60));
      attest_sw_binding[5].add_hdl_path_slice(
          "u_reg.u_attest_sw_binding_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      attest_sw_binding[6] =
          (keymgr_reg_attest_sw_binding::
           type_id::create("attest_sw_binding_6"));
      attest_sw_binding[6].configure(.blk_parent(this));
      attest_sw_binding[6].build(csr_excl);
      default_map.add_reg(.rg(attest_sw_binding[6]),
                          .offset(32'h64));
      attest_sw_binding[6].add_hdl_path_slice(
          "u_reg.u_attest_sw_binding_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      attest_sw_binding[7] =
          (keymgr_reg_attest_sw_binding::
           type_id::create("attest_sw_binding_7"));
      attest_sw_binding[7].configure(.blk_parent(this));
      attest_sw_binding[7].build(csr_excl);
      default_map.add_reg(.rg(attest_sw_binding[7]),
                          .offset(32'h68));
      attest_sw_binding[7].add_hdl_path_slice(
          "u_reg.u_attest_sw_binding_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      salt[0] =
          (keymgr_reg_salt::
           type_id::create("salt_0"));
      salt[0].configure(.blk_parent(this));
      salt[0].build(csr_excl);
      default_map.add_reg(.rg(salt[0]),
                          .offset(32'h6c));
      salt[0].add_hdl_path_slice(
          "u_reg.u_salt_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      salt[1] =
          (keymgr_reg_salt::
           type_id::create("salt_1"));
      salt[1].configure(.blk_parent(this));
      salt[1].build(csr_excl);
      default_map.add_reg(.rg(salt[1]),
                          .offset(32'h70));
      salt[1].add_hdl_path_slice(
          "u_reg.u_salt_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      salt[2] =
          (keymgr_reg_salt::
           type_id::create("salt_2"));
      salt[2].configure(.blk_parent(this));
      salt[2].build(csr_excl);
      default_map.add_reg(.rg(salt[2]),
                          .offset(32'h74));
      salt[2].add_hdl_path_slice(
          "u_reg.u_salt_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      salt[3] =
          (keymgr_reg_salt::
           type_id::create("salt_3"));
      salt[3].configure(.blk_parent(this));
      salt[3].build(csr_excl);
      default_map.add_reg(.rg(salt[3]),
                          .offset(32'h78));
      salt[3].add_hdl_path_slice(
          "u_reg.u_salt_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      salt[4] =
          (keymgr_reg_salt::
           type_id::create("salt_4"));
      salt[4].configure(.blk_parent(this));
      salt[4].build(csr_excl);
      default_map.add_reg(.rg(salt[4]),
                          .offset(32'h7c));
      salt[4].add_hdl_path_slice(
          "u_reg.u_salt_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      salt[5] =
          (keymgr_reg_salt::
           type_id::create("salt_5"));
      salt[5].configure(.blk_parent(this));
      salt[5].build(csr_excl);
      default_map.add_reg(.rg(salt[5]),
                          .offset(32'h80));
      salt[5].add_hdl_path_slice(
          "u_reg.u_salt_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      salt[6] =
          (keymgr_reg_salt::
           type_id::create("salt_6"));
      salt[6].configure(.blk_parent(this));
      salt[6].build(csr_excl);
      default_map.add_reg(.rg(salt[6]),
                          .offset(32'h84));
      salt[6].add_hdl_path_slice(
          "u_reg.u_salt_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      salt[7] =
          (keymgr_reg_salt::
           type_id::create("salt_7"));
      salt[7].configure(.blk_parent(this));
      salt[7].build(csr_excl);
      default_map.add_reg(.rg(salt[7]),
                          .offset(32'h88));
      salt[7].add_hdl_path_slice(
          "u_reg.u_salt_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      key_version[0] =
          (keymgr_reg_key_version::
           type_id::create("key_version"));
      key_version[0].configure(.blk_parent(this));
      key_version[0].build(csr_excl);
      default_map.add_reg(.rg(key_version[0]),
                          .offset(32'h8c));
      key_version[0].add_hdl_path_slice(
          "u_reg.u_key_version.q",
          0, 32, 0, "BkdrRegPathRtl");

      max_creator_key_ver_regwen =
          (keymgr_reg_max_creator_key_ver_regwen::
           type_id::create("max_creator_key_ver_regwen"));
      max_creator_key_ver_regwen.configure(.blk_parent(this));
      max_creator_key_ver_regwen.build(csr_excl);
      default_map.add_reg(.rg(max_creator_key_ver_regwen),
                          .offset(32'h90));
      max_creator_key_ver_regwen.add_hdl_path_slice(
          "u_reg.u_max_creator_key_ver_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      max_creator_key_ver_shadowed =
          (keymgr_reg_max_creator_key_ver_shadowed::
           type_id::create("max_creator_key_ver_shadowed"));
      max_creator_key_ver_shadowed.configure(.blk_parent(this));
      max_creator_key_ver_shadowed.build(csr_excl);
      default_map.add_reg(.rg(max_creator_key_ver_shadowed),
                          .offset(32'h94));
      max_creator_key_ver_shadowed.add_update_err_alert("recov_operation_err");

      max_creator_key_ver_shadowed.add_storage_err_alert("fatal_fault_err");

      max_creator_key_ver_shadowed.add_hdl_path_slice(
          "u_reg.u_max_creator_key_ver_shadowed.committed_reg.q",
          0, 32, 0, "BkdrRegPathRtl");
      max_creator_key_ver_shadowed.add_hdl_path_slice(
          "u_reg.u_max_creator_key_ver_shadowed.shadow_reg.q",
          0, 32, 0, "BkdrRegPathRtlShadow");

      max_creator_key_ver_shadowed.set_is_shadowed();
      max_owner_int_key_ver_regwen =
          (keymgr_reg_max_owner_int_key_ver_regwen::
           type_id::create("max_owner_int_key_ver_regwen"));
      max_owner_int_key_ver_regwen.configure(.blk_parent(this));
      max_owner_int_key_ver_regwen.build(csr_excl);
      default_map.add_reg(.rg(max_owner_int_key_ver_regwen),
                          .offset(32'h98));
      max_owner_int_key_ver_regwen.add_hdl_path_slice(
          "u_reg.u_max_owner_int_key_ver_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      max_owner_int_key_ver_shadowed =
          (keymgr_reg_max_owner_int_key_ver_shadowed::
           type_id::create("max_owner_int_key_ver_shadowed"));
      max_owner_int_key_ver_shadowed.configure(.blk_parent(this));
      max_owner_int_key_ver_shadowed.build(csr_excl);
      default_map.add_reg(.rg(max_owner_int_key_ver_shadowed),
                          .offset(32'h9c));
      max_owner_int_key_ver_shadowed.add_update_err_alert("recov_operation_err");

      max_owner_int_key_ver_shadowed.add_storage_err_alert("fatal_fault_err");

      max_owner_int_key_ver_shadowed.add_hdl_path_slice(
          "u_reg.u_max_owner_int_key_ver_shadowed.committed_reg.q",
          0, 32, 0, "BkdrRegPathRtl");
      max_owner_int_key_ver_shadowed.add_hdl_path_slice(
          "u_reg.u_max_owner_int_key_ver_shadowed.shadow_reg.q",
          0, 32, 0, "BkdrRegPathRtlShadow");

      max_owner_int_key_ver_shadowed.set_is_shadowed();
      max_owner_key_ver_regwen =
          (keymgr_reg_max_owner_key_ver_regwen::
           type_id::create("max_owner_key_ver_regwen"));
      max_owner_key_ver_regwen.configure(.blk_parent(this));
      max_owner_key_ver_regwen.build(csr_excl);
      default_map.add_reg(.rg(max_owner_key_ver_regwen),
                          .offset(32'ha0));
      max_owner_key_ver_regwen.add_hdl_path_slice(
          "u_reg.u_max_owner_key_ver_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      max_owner_key_ver_shadowed =
          (keymgr_reg_max_owner_key_ver_shadowed::
           type_id::create("max_owner_key_ver_shadowed"));
      max_owner_key_ver_shadowed.configure(.blk_parent(this));
      max_owner_key_ver_shadowed.build(csr_excl);
      default_map.add_reg(.rg(max_owner_key_ver_shadowed),
                          .offset(32'ha4));
      max_owner_key_ver_shadowed.add_update_err_alert("recov_operation_err");

      max_owner_key_ver_shadowed.add_storage_err_alert("fatal_fault_err");

      max_owner_key_ver_shadowed.add_hdl_path_slice(
          "u_reg.u_max_owner_key_ver_shadowed.committed_reg.q",
          0, 32, 0, "BkdrRegPathRtl");
      max_owner_key_ver_shadowed.add_hdl_path_slice(
          "u_reg.u_max_owner_key_ver_shadowed.shadow_reg.q",
          0, 32, 0, "BkdrRegPathRtlShadow");

      max_owner_key_ver_shadowed.set_is_shadowed();
      sw_share0_output[0] =
          (keymgr_reg_sw_share0_output::
           type_id::create("sw_share0_output_0"));
      sw_share0_output[0].configure(.blk_parent(this));
      sw_share0_output[0].build(csr_excl);
      default_map.add_reg(.rg(sw_share0_output[0]),
                          .offset(32'ha8));
      sw_share0_output[0].add_hdl_path_slice(
          "u_reg.u_sw_share0_output_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share0_output[0].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share0_output[1] =
          (keymgr_reg_sw_share0_output::
           type_id::create("sw_share0_output_1"));
      sw_share0_output[1].configure(.blk_parent(this));
      sw_share0_output[1].build(csr_excl);
      default_map.add_reg(.rg(sw_share0_output[1]),
                          .offset(32'hac));
      sw_share0_output[1].add_hdl_path_slice(
          "u_reg.u_sw_share0_output_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share0_output[1].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share0_output[2] =
          (keymgr_reg_sw_share0_output::
           type_id::create("sw_share0_output_2"));
      sw_share0_output[2].configure(.blk_parent(this));
      sw_share0_output[2].build(csr_excl);
      default_map.add_reg(.rg(sw_share0_output[2]),
                          .offset(32'hb0));
      sw_share0_output[2].add_hdl_path_slice(
          "u_reg.u_sw_share0_output_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share0_output[2].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share0_output[3] =
          (keymgr_reg_sw_share0_output::
           type_id::create("sw_share0_output_3"));
      sw_share0_output[3].configure(.blk_parent(this));
      sw_share0_output[3].build(csr_excl);
      default_map.add_reg(.rg(sw_share0_output[3]),
                          .offset(32'hb4));
      sw_share0_output[3].add_hdl_path_slice(
          "u_reg.u_sw_share0_output_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share0_output[3].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share0_output[4] =
          (keymgr_reg_sw_share0_output::
           type_id::create("sw_share0_output_4"));
      sw_share0_output[4].configure(.blk_parent(this));
      sw_share0_output[4].build(csr_excl);
      default_map.add_reg(.rg(sw_share0_output[4]),
                          .offset(32'hb8));
      sw_share0_output[4].add_hdl_path_slice(
          "u_reg.u_sw_share0_output_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share0_output[4].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share0_output[5] =
          (keymgr_reg_sw_share0_output::
           type_id::create("sw_share0_output_5"));
      sw_share0_output[5].configure(.blk_parent(this));
      sw_share0_output[5].build(csr_excl);
      default_map.add_reg(.rg(sw_share0_output[5]),
                          .offset(32'hbc));
      sw_share0_output[5].add_hdl_path_slice(
          "u_reg.u_sw_share0_output_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share0_output[5].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share0_output[6] =
          (keymgr_reg_sw_share0_output::
           type_id::create("sw_share0_output_6"));
      sw_share0_output[6].configure(.blk_parent(this));
      sw_share0_output[6].build(csr_excl);
      default_map.add_reg(.rg(sw_share0_output[6]),
                          .offset(32'hc0));
      sw_share0_output[6].add_hdl_path_slice(
          "u_reg.u_sw_share0_output_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share0_output[6].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share0_output[7] =
          (keymgr_reg_sw_share0_output::
           type_id::create("sw_share0_output_7"));
      sw_share0_output[7].configure(.blk_parent(this));
      sw_share0_output[7].build(csr_excl);
      default_map.add_reg(.rg(sw_share0_output[7]),
                          .offset(32'hc4));
      sw_share0_output[7].add_hdl_path_slice(
          "u_reg.u_sw_share0_output_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share0_output[7].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share1_output[0] =
          (keymgr_reg_sw_share1_output::
           type_id::create("sw_share1_output_0"));
      sw_share1_output[0].configure(.blk_parent(this));
      sw_share1_output[0].build(csr_excl);
      default_map.add_reg(.rg(sw_share1_output[0]),
                          .offset(32'hc8));
      sw_share1_output[0].add_hdl_path_slice(
          "u_reg.u_sw_share1_output_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share1_output[0].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share1_output[1] =
          (keymgr_reg_sw_share1_output::
           type_id::create("sw_share1_output_1"));
      sw_share1_output[1].configure(.blk_parent(this));
      sw_share1_output[1].build(csr_excl);
      default_map.add_reg(.rg(sw_share1_output[1]),
                          .offset(32'hcc));
      sw_share1_output[1].add_hdl_path_slice(
          "u_reg.u_sw_share1_output_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share1_output[1].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share1_output[2] =
          (keymgr_reg_sw_share1_output::
           type_id::create("sw_share1_output_2"));
      sw_share1_output[2].configure(.blk_parent(this));
      sw_share1_output[2].build(csr_excl);
      default_map.add_reg(.rg(sw_share1_output[2]),
                          .offset(32'hd0));
      sw_share1_output[2].add_hdl_path_slice(
          "u_reg.u_sw_share1_output_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share1_output[2].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share1_output[3] =
          (keymgr_reg_sw_share1_output::
           type_id::create("sw_share1_output_3"));
      sw_share1_output[3].configure(.blk_parent(this));
      sw_share1_output[3].build(csr_excl);
      default_map.add_reg(.rg(sw_share1_output[3]),
                          .offset(32'hd4));
      sw_share1_output[3].add_hdl_path_slice(
          "u_reg.u_sw_share1_output_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share1_output[3].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share1_output[4] =
          (keymgr_reg_sw_share1_output::
           type_id::create("sw_share1_output_4"));
      sw_share1_output[4].configure(.blk_parent(this));
      sw_share1_output[4].build(csr_excl);
      default_map.add_reg(.rg(sw_share1_output[4]),
                          .offset(32'hd8));
      sw_share1_output[4].add_hdl_path_slice(
          "u_reg.u_sw_share1_output_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share1_output[4].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share1_output[5] =
          (keymgr_reg_sw_share1_output::
           type_id::create("sw_share1_output_5"));
      sw_share1_output[5].configure(.blk_parent(this));
      sw_share1_output[5].build(csr_excl);
      default_map.add_reg(.rg(sw_share1_output[5]),
                          .offset(32'hdc));
      sw_share1_output[5].add_hdl_path_slice(
          "u_reg.u_sw_share1_output_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share1_output[5].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share1_output[6] =
          (keymgr_reg_sw_share1_output::
           type_id::create("sw_share1_output_6"));
      sw_share1_output[6].configure(.blk_parent(this));
      sw_share1_output[6].build(csr_excl);
      default_map.add_reg(.rg(sw_share1_output[6]),
                          .offset(32'he0));
      sw_share1_output[6].add_hdl_path_slice(
          "u_reg.u_sw_share1_output_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share1_output[6].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      sw_share1_output[7] =
          (keymgr_reg_sw_share1_output::
           type_id::create("sw_share1_output_7"));
      sw_share1_output[7].configure(.blk_parent(this));
      sw_share1_output[7].build(csr_excl);
      default_map.add_reg(.rg(sw_share1_output[7]),
                          .offset(32'he4));
      sw_share1_output[7].add_hdl_path_slice(
          "u_reg.u_sw_share1_output_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_share1_output[7].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      working_state =
          (keymgr_reg_working_state::
           type_id::create("working_state"));
      working_state.configure(.blk_parent(this));
      working_state.build(csr_excl);
      default_map.add_reg(.rg(working_state),
                          .offset(32'he8));
      working_state.add_hdl_path_slice(
          "u_reg.u_working_state.q",
          0, 3, 0, "BkdrRegPathRtl");

      op_status =
          (keymgr_reg_op_status::
           type_id::create("op_status"));
      op_status.configure(.blk_parent(this));
      op_status.build(csr_excl);
      default_map.add_reg(.rg(op_status),
                          .offset(32'hec));
      op_status.add_hdl_path_slice(
          "u_reg.u_op_status.q",
          0, 2, 0, "BkdrRegPathRtl");

      err_code =
          (keymgr_reg_err_code::
           type_id::create("err_code"));
      err_code.configure(.blk_parent(this));
      err_code.build(csr_excl);
      default_map.add_reg(.rg(err_code),
                          .offset(32'hf0));
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_invalid_op.q",
          0, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_invalid_kmac_input.q",
          1, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_invalid_shadow_update.q",
          2, 1, 0, "BkdrRegPathRtl");

      fault_status =
          (keymgr_reg_fault_status::
           type_id::create("fault_status"));
      fault_status.configure(.blk_parent(this));
      fault_status.build(csr_excl);
      default_map.add_reg(.rg(fault_status),
                          .offset(32'hf4));
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_cmd.q",
          0, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_kmac_fsm.q",
          1, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_kmac_done.q",
          2, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_kmac_op.q",
          3, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_kmac_out.q",
          4, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_regfile_intg.q",
          5, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_shadow.q",
          6, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_ctrl_fsm_intg.q",
          7, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_ctrl_fsm_chk.q",
          8, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_ctrl_fsm_cnt.q",
          9, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_reseed_cnt.q",
          10, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_side_ctrl_fsm.q",
          11, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_side_ctrl_sel.q",
          12, 1, 0, "BkdrRegPathRtl");
      fault_status.add_hdl_path_slice(
          "u_reg.u_fault_status_key_ecc.q",
          13, 1, 0, "BkdrRegPathRtl");

      debug =
          (keymgr_reg_debug::
           type_id::create("debug"));
      debug.configure(.blk_parent(this));
      debug.build(csr_excl);
      default_map.add_reg(.rg(debug),
                          .offset(32'hf8));
      debug.add_hdl_path_slice(
          "u_reg.u_debug_invalid_creator_seed.q",
          0, 1, 0, "BkdrRegPathRtl");
      debug.add_hdl_path_slice(
          "u_reg.u_debug_invalid_owner_seed.q",
          1, 1, 0, "BkdrRegPathRtl");
      debug.add_hdl_path_slice(
          "u_reg.u_debug_invalid_dev_id.q",
          2, 1, 0, "BkdrRegPathRtl");
      debug.add_hdl_path_slice(
          "u_reg.u_debug_invalid_health_state.q",
          3, 1, 0, "BkdrRegPathRtl");
      debug.add_hdl_path_slice(
          "u_reg.u_debug_invalid_key_version.q",
          4, 1, 0, "BkdrRegPathRtl");
      debug.add_hdl_path_slice(
          "u_reg.u_debug_invalid_key.q",
          5, 1, 0, "BkdrRegPathRtl");
      debug.add_hdl_path_slice(
          "u_reg.u_debug_invalid_digest.q",
          6, 1, 0, "BkdrRegPathRtl");

      // assign locked reg to its regwen reg
      cfg_regwen.add_lockable_reg_or_fld(start);
      cfg_regwen.add_lockable_reg_or_fld(control_shadowed);
      cfg_regwen.add_lockable_reg_or_fld(sideload_clear);
      reseed_interval_regwen.add_lockable_reg_or_fld(reseed_interval_shadowed);
      sw_binding_regwen.add_lockable_reg_or_fld(sealing_sw_binding[0]);
      sw_binding_regwen.add_lockable_reg_or_fld(sealing_sw_binding[1]);
      sw_binding_regwen.add_lockable_reg_or_fld(sealing_sw_binding[2]);
      sw_binding_regwen.add_lockable_reg_or_fld(sealing_sw_binding[3]);
      sw_binding_regwen.add_lockable_reg_or_fld(sealing_sw_binding[4]);
      sw_binding_regwen.add_lockable_reg_or_fld(sealing_sw_binding[5]);
      sw_binding_regwen.add_lockable_reg_or_fld(sealing_sw_binding[6]);
      sw_binding_regwen.add_lockable_reg_or_fld(sealing_sw_binding[7]);
      sw_binding_regwen.add_lockable_reg_or_fld(attest_sw_binding[0]);
      sw_binding_regwen.add_lockable_reg_or_fld(attest_sw_binding[1]);
      sw_binding_regwen.add_lockable_reg_or_fld(attest_sw_binding[2]);
      sw_binding_regwen.add_lockable_reg_or_fld(attest_sw_binding[3]);
      sw_binding_regwen.add_lockable_reg_or_fld(attest_sw_binding[4]);
      sw_binding_regwen.add_lockable_reg_or_fld(attest_sw_binding[5]);
      sw_binding_regwen.add_lockable_reg_or_fld(attest_sw_binding[6]);
      sw_binding_regwen.add_lockable_reg_or_fld(attest_sw_binding[7]);
      cfg_regwen.add_lockable_reg_or_fld(salt[0]);
      cfg_regwen.add_lockable_reg_or_fld(salt[1]);
      cfg_regwen.add_lockable_reg_or_fld(salt[2]);
      cfg_regwen.add_lockable_reg_or_fld(salt[3]);
      cfg_regwen.add_lockable_reg_or_fld(salt[4]);
      cfg_regwen.add_lockable_reg_or_fld(salt[5]);
      cfg_regwen.add_lockable_reg_or_fld(salt[6]);
      cfg_regwen.add_lockable_reg_or_fld(salt[7]);
      cfg_regwen.add_lockable_reg_or_fld(key_version[0]);
      max_creator_key_ver_regwen.add_lockable_reg_or_fld(max_creator_key_ver_shadowed);
      max_owner_int_key_ver_regwen.add_lockable_reg_or_fld(max_owner_int_key_ver_shadowed);
      max_owner_key_ver_regwen.add_lockable_reg_or_fld(max_owner_key_ver_shadowed);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : keymgr_reg_block

endpackage

