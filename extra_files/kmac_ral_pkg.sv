// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package kmac_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class kmac_reg_intr_state;
  typedef class kmac_reg_intr_enable;
  typedef class kmac_reg_intr_test;
  typedef class kmac_reg_alert_test;
  typedef class kmac_reg_cfg_regwen;
  typedef class kmac_reg_cfg_shadowed;
  typedef class kmac_reg_cmd;
  typedef class kmac_reg_status;
  typedef class kmac_reg_entropy_period;
  typedef class kmac_reg_entropy_refresh_hash_cnt;
  typedef class kmac_reg_entropy_refresh_threshold_shadowed;
  typedef class kmac_reg_entropy_seed;
  typedef class kmac_reg_key_share0;
  typedef class kmac_reg_key_share1;
  typedef class kmac_reg_key_len;
  typedef class kmac_reg_prefix;
  typedef class kmac_reg_err_code;
  typedef class kmac_mem_state;
  typedef class kmac_mem_msg_fifo;
  typedef class kmac_reg_block;

  class kmac_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field kmac_done;
    rand dv_base_reg_field fifo_empty;
    rand dv_base_reg_field kmac_err;

    `uvm_object_utils(kmac_reg_intr_state)

    function new(string       name = "kmac_reg_intr_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      kmac_done =
          (dv_base_reg_field::
           type_id::create("kmac_done"));
      kmac_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_done.set_original_access("W1C");
      fifo_empty =
          (dv_base_reg_field::
           type_id::create("fifo_empty"));
      fifo_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_empty.set_original_access("RO");
      kmac_err =
          (dv_base_reg_field::
           type_id::create("kmac_err"));
      kmac_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_err.set_original_access("W1C");
    endfunction : build
  endclass : kmac_reg_intr_state

  class kmac_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field kmac_done;
    rand dv_base_reg_field fifo_empty;
    rand dv_base_reg_field kmac_err;

    `uvm_object_utils(kmac_reg_intr_enable)

    function new(string       name = "kmac_reg_intr_enable",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      kmac_done =
          (dv_base_reg_field::
           type_id::create("kmac_done"));
      kmac_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_done.set_original_access("RW");
      fifo_empty =
          (dv_base_reg_field::
           type_id::create("fifo_empty"));
      fifo_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_empty.set_original_access("RW");
      kmac_err =
          (dv_base_reg_field::
           type_id::create("kmac_err"));
      kmac_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_err.set_original_access("RW");
    endfunction : build
  endclass : kmac_reg_intr_enable

  class kmac_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field kmac_done;
    rand dv_base_reg_field fifo_empty;
    rand dv_base_reg_field kmac_err;

    `uvm_object_utils(kmac_reg_intr_test)

    function new(string       name = "kmac_reg_intr_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      kmac_done =
          (dv_base_reg_field::
           type_id::create("kmac_done"));
      kmac_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_done.set_original_access("WO");
      fifo_empty =
          (dv_base_reg_field::
           type_id::create("fifo_empty"));
      fifo_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_empty.set_original_access("WO");
      kmac_err =
          (dv_base_reg_field::
           type_id::create("kmac_err"));
      kmac_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_err.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : kmac_reg_intr_test

  class kmac_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field recov_operation_err;
    rand dv_base_reg_field fatal_fault_err;

    `uvm_object_utils(kmac_reg_alert_test)

    function new(string       name = "kmac_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      recov_operation_err =
          (dv_base_reg_field::
           type_id::create("recov_operation_err"));
      recov_operation_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      recov_operation_err.set_original_access("WO");
      fatal_fault_err =
          (dv_base_reg_field::
           type_id::create("fatal_fault_err"));
      fatal_fault_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault_err.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : kmac_reg_alert_test

  class kmac_reg_cfg_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;

    `uvm_object_utils(kmac_reg_cfg_regwen)

    function new(string       name = "kmac_reg_cfg_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : kmac_reg_cfg_regwen

  class kmac_reg_cfg_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field kmac_en;
    rand dv_base_reg_field kstrength;
    rand dv_base_reg_field mode;
    rand dv_base_reg_field msg_endianness;
    rand dv_base_reg_field state_endianness;
    rand dv_base_reg_field sideload;
    rand dv_base_reg_field entropy_mode;
    rand dv_base_reg_field entropy_fast_process;
    rand dv_base_reg_field msg_mask;
    rand dv_base_reg_field entropy_ready;
    rand dv_base_reg_field en_unsupported_modestrength;

    `uvm_object_utils(kmac_reg_cfg_shadowed)

    function new(string       name = "kmac_reg_cfg_shadowed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      kmac_en =
          (dv_base_reg_field::
           type_id::create("kmac_en"));
      kmac_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kmac_en.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(kmac_en.get_full_name(), CsrExclWrite, CsrNonInitTests);
      kstrength =
          (dv_base_reg_field::
           type_id::create("kstrength"));
      kstrength.configure(
        .parent(this),
        .size(3),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      kstrength.set_original_access("RW");
      // create field tags
      mode =
          (dv_base_reg_field::
           type_id::create("mode"));
      mode.configure(
        .parent(this),
        .size(2),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mode.set_original_access("RW");
      // create field tags
      msg_endianness =
          (dv_base_reg_field::
           type_id::create("msg_endianness"));
      msg_endianness.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      msg_endianness.set_original_access("RW");
      // create field tags
      state_endianness =
          (dv_base_reg_field::
           type_id::create("state_endianness"));
      state_endianness.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      state_endianness.set_original_access("RW");
      // create field tags
      sideload =
          (dv_base_reg_field::
           type_id::create("sideload"));
      sideload.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sideload.set_original_access("RW");
      // create field tags
      entropy_mode =
          (dv_base_reg_field::
           type_id::create("entropy_mode"));
      entropy_mode.configure(
        .parent(this),
        .size(2),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      entropy_mode.set_original_access("RW");
      // create field tags
      entropy_fast_process =
          (dv_base_reg_field::
           type_id::create("entropy_fast_process"));
      entropy_fast_process.configure(
        .parent(this),
        .size(1),
        .lsb_pos(19),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      entropy_fast_process.set_original_access("RW");
      // create field tags
      msg_mask =
          (dv_base_reg_field::
           type_id::create("msg_mask"));
      msg_mask.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      msg_mask.set_original_access("RW");
      entropy_ready =
          (dv_base_reg_field::
           type_id::create("entropy_ready"));
      entropy_ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(24),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      entropy_ready.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(entropy_ready.get_full_name(), CsrExclWrite, CsrAllTests);
      en_unsupported_modestrength =
          (dv_base_reg_field::
           type_id::create("en_unsupported_modestrength"));
      en_unsupported_modestrength.configure(
        .parent(this),
        .size(1),
        .lsb_pos(26),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en_unsupported_modestrength.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(en_unsupported_modestrength.get_full_name(), CsrExclWrite, CsrAllTests);
    endfunction : build
  endclass : kmac_reg_cfg_shadowed

  class kmac_reg_cmd extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmd;
    rand dv_base_reg_field entropy_req;
    rand dv_base_reg_field hash_cnt_clr;
    rand dv_base_reg_field err_processed;

    `uvm_object_utils(kmac_reg_cmd)

    function new(string       name = "kmac_reg_cmd",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmd =
          (dv_base_reg_field::
           type_id::create("cmd"));
      cmd.configure(
        .parent(this),
        .size(6),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd.set_original_access("W1C");
      entropy_req =
          (dv_base_reg_field::
           type_id::create("entropy_req"));
      entropy_req.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      entropy_req.set_original_access("W1C");
      hash_cnt_clr =
          (dv_base_reg_field::
           type_id::create("hash_cnt_clr"));
      hash_cnt_clr.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hash_cnt_clr.set_original_access("W1C");
      err_processed =
          (dv_base_reg_field::
           type_id::create("err_processed"));
      err_processed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_processed.set_original_access("W1C");
      set_is_ext_reg(1);
    endfunction : build
  endclass : kmac_reg_cmd

  class kmac_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field sha3_idle;
    rand dv_base_reg_field sha3_absorb;
    rand dv_base_reg_field sha3_squeeze;
    rand dv_base_reg_field fifo_depth;
    rand dv_base_reg_field fifo_empty;
    rand dv_base_reg_field fifo_full;
    rand dv_base_reg_field alert_fatal_fault;
    rand dv_base_reg_field alert_recov_ctrl_update_err;

    `uvm_object_utils(kmac_reg_status)

    function new(string       name = "kmac_reg_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      sha3_idle =
          (dv_base_reg_field::
           type_id::create("sha3_idle"));
      sha3_idle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_idle.set_original_access("RO");
      sha3_absorb =
          (dv_base_reg_field::
           type_id::create("sha3_absorb"));
      sha3_absorb.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_absorb.set_original_access("RO");
      sha3_squeeze =
          (dv_base_reg_field::
           type_id::create("sha3_squeeze"));
      sha3_squeeze.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_squeeze.set_original_access("RO");
      fifo_depth =
          (dv_base_reg_field::
           type_id::create("fifo_depth"));
      fifo_depth.configure(
        .parent(this),
        .size(5),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_depth.set_original_access("RO");
      fifo_empty =
          (dv_base_reg_field::
           type_id::create("fifo_empty"));
      fifo_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_empty.set_original_access("RO");
      fifo_full =
          (dv_base_reg_field::
           type_id::create("fifo_full"));
      fifo_full.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_full.set_original_access("RO");
      alert_fatal_fault =
          (dv_base_reg_field::
           type_id::create("alert_fatal_fault"));
      alert_fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      alert_fatal_fault.set_original_access("RO");
      alert_recov_ctrl_update_err =
          (dv_base_reg_field::
           type_id::create("alert_recov_ctrl_update_err"));
      alert_recov_ctrl_update_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      alert_recov_ctrl_update_err.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : kmac_reg_status

  class kmac_reg_entropy_period extends dv_base_reg;
    // fields
    rand dv_base_reg_field prescaler;
    rand dv_base_reg_field wait_timer;

    `uvm_object_utils(kmac_reg_entropy_period)

    function new(string       name = "kmac_reg_entropy_period",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      prescaler =
          (dv_base_reg_field::
           type_id::create("prescaler"));
      prescaler.configure(
        .parent(this),
        .size(10),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      prescaler.set_original_access("RW");
      wait_timer =
          (dv_base_reg_field::
           type_id::create("wait_timer"));
      wait_timer.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wait_timer.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(wait_timer.get_full_name(), CsrExclWrite, CsrNonInitTests);
    endfunction : build
  endclass : kmac_reg_entropy_period

  class kmac_reg_entropy_refresh_hash_cnt extends dv_base_reg;
    // fields
    rand dv_base_reg_field hash_cnt;

    `uvm_object_utils(kmac_reg_entropy_refresh_hash_cnt)

    function new(string       name = "kmac_reg_entropy_refresh_hash_cnt",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      hash_cnt =
          (dv_base_reg_field::
           type_id::create("hash_cnt"));
      hash_cnt.configure(
        .parent(this),
        .size(10),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hash_cnt.set_original_access("RO");
    endfunction : build
  endclass : kmac_reg_entropy_refresh_hash_cnt

  class kmac_reg_entropy_refresh_threshold_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field threshold;

    `uvm_object_utils(kmac_reg_entropy_refresh_threshold_shadowed)

    function new(string       name = "kmac_reg_entropy_refresh_threshold_shadowed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      threshold =
          (dv_base_reg_field::
           type_id::create("threshold"));
      threshold.configure(
        .parent(this),
        .size(10),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      threshold.set_original_access("RW");
    endfunction : build
  endclass : kmac_reg_entropy_refresh_threshold_shadowed

  class kmac_reg_entropy_seed extends dv_base_reg;
    // fields
    rand dv_base_reg_field seed;

    `uvm_object_utils(kmac_reg_entropy_seed)

    function new(string       name = "kmac_reg_entropy_seed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      seed =
          (dv_base_reg_field::
           type_id::create("seed"));
      seed.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      seed.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : kmac_reg_entropy_seed

  class kmac_reg_key_share0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field key;

    `uvm_object_utils(kmac_reg_key_share0)

    function new(string       name = "kmac_reg_key_share0",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key =
          (dv_base_reg_field::
           type_id::create("key_0"));
      key.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : kmac_reg_key_share0

  class kmac_reg_key_share1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field key;

    `uvm_object_utils(kmac_reg_key_share1)

    function new(string       name = "kmac_reg_key_share1",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key =
          (dv_base_reg_field::
           type_id::create("key_0"));
      key.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : kmac_reg_key_share1

  class kmac_reg_key_len extends dv_base_reg;
    // fields
    rand dv_base_reg_field len;

    `uvm_object_utils(kmac_reg_key_len)

    function new(string       name = "kmac_reg_key_len",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      len =
          (dv_base_reg_field::
           type_id::create("len"));
      len.configure(
        .parent(this),
        .size(3),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      len.set_original_access("WO");
    endfunction : build
  endclass : kmac_reg_key_len

  class kmac_reg_prefix extends dv_base_reg;
    // fields
    rand dv_base_reg_field prefix;

    `uvm_object_utils(kmac_reg_prefix)

    function new(string       name = "kmac_reg_prefix",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      prefix =
          (dv_base_reg_field::
           type_id::create("prefix_0"));
      prefix.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      prefix.set_original_access("RW");
    endfunction : build
  endclass : kmac_reg_prefix

  class kmac_reg_err_code extends dv_base_reg;
    // fields
    rand dv_base_reg_field err_code;

    `uvm_object_utils(kmac_reg_err_code)

    function new(string       name = "kmac_reg_err_code",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      err_code =
          (dv_base_reg_field::
           type_id::create("err_code"));
      err_code.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_code.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(err_code.get_full_name(), CsrExclWriteCheck, CsrNonInitTests);
    endfunction : build
  endclass : kmac_reg_err_code

  class kmac_mem_state extends dv_base_mem;

    `uvm_object_utils(kmac_mem_state)

    function new(string           name = "kmac_mem_state",
                 longint unsigned size = 128,
                 int unsigned     n_bits = 32,
                 string           access = "RO",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
    endfunction : new

  endclass : kmac_mem_state


  class kmac_mem_msg_fifo extends dv_base_mem;

    `uvm_object_utils(kmac_mem_msg_fifo)

    function new(string           name = "kmac_mem_msg_fifo",
                 longint unsigned size = 512,
                 int unsigned     n_bits = 32,
                 string           access = "WO",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
      set_mem_partial_write_support(1);
    endfunction : new

  endclass : kmac_mem_msg_fifo


  class kmac_reg_block extends dv_base_reg_block;
    // registers
    rand kmac_reg_intr_state intr_state;
    rand kmac_reg_intr_enable intr_enable;
    rand kmac_reg_intr_test intr_test;
    rand kmac_reg_alert_test alert_test;
    rand kmac_reg_cfg_regwen cfg_regwen;
    rand kmac_reg_cfg_shadowed cfg_shadowed;
    rand kmac_reg_cmd cmd;
    rand kmac_reg_status status;
    rand kmac_reg_entropy_period entropy_period;
    rand kmac_reg_entropy_refresh_hash_cnt entropy_refresh_hash_cnt;
    rand kmac_reg_entropy_refresh_threshold_shadowed entropy_refresh_threshold_shadowed;
    rand kmac_reg_entropy_seed entropy_seed;
    rand kmac_reg_key_share0 key_share0[16];
    rand kmac_reg_key_share1 key_share1[16];
    rand kmac_reg_key_len key_len;
    rand kmac_reg_prefix prefix[11];
    rand kmac_reg_err_code err_code;
    // memories
    rand kmac_mem_state state;
    rand kmac_mem_msg_fifo msg_fifo;

    `uvm_object_utils(kmac_reg_block)

    function new(string name = "kmac_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (kmac_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_kmac_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_fifo_empty.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_kmac_err.q",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (kmac_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_kmac_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_fifo_empty.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_kmac_err.q",
          2, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (kmac_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_kmac_done.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_fifo_empty.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_kmac_err.qs",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (kmac_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_recov_operation_err.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_fault_err.qs",
          1, 1, 0, "BkdrRegPathRtl");

      cfg_regwen =
          (kmac_reg_cfg_regwen::
           type_id::create("cfg_regwen"));
      cfg_regwen.configure(.blk_parent(this));
      cfg_regwen.build(csr_excl);
      default_map.add_reg(.rg(cfg_regwen),
                          .offset(32'h10));
      cfg_regwen.add_hdl_path_slice(
          "u_reg.u_cfg_regwen.qs",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(cfg_regwen.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      cfg_shadowed =
          (kmac_reg_cfg_shadowed::
           type_id::create("cfg_shadowed"));
      cfg_shadowed.configure(.blk_parent(this));
      cfg_shadowed.build(csr_excl);
      default_map.add_reg(.rg(cfg_shadowed),
                          .offset(32'h14));
      cfg_shadowed.add_update_err_alert("recov_operation_err");

      cfg_shadowed.add_storage_err_alert("fatal_fault_err");

      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_kmac_en.committed_reg.q",
          0, 1, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_kmac_en.shadow_reg.q",
          0, 1, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_kstrength.committed_reg.q",
          1, 3, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_kstrength.shadow_reg.q",
          1, 3, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_mode.committed_reg.q",
          4, 2, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_mode.shadow_reg.q",
          4, 2, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_msg_endianness.committed_reg.q",
          8, 1, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_msg_endianness.shadow_reg.q",
          8, 1, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_state_endianness.committed_reg.q",
          9, 1, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_state_endianness.shadow_reg.q",
          9, 1, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_sideload.committed_reg.q",
          12, 1, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_sideload.shadow_reg.q",
          12, 1, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_entropy_mode.committed_reg.q",
          16, 2, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_entropy_mode.shadow_reg.q",
          16, 2, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_entropy_fast_process.committed_reg.q",
          19, 1, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_entropy_fast_process.shadow_reg.q",
          19, 1, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_msg_mask.committed_reg.q",
          20, 1, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_msg_mask.shadow_reg.q",
          20, 1, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_entropy_ready.committed_reg.q",
          24, 1, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_entropy_ready.shadow_reg.q",
          24, 1, 0, "BkdrRegPathRtlShadow");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_en_unsupported_modestrength.committed_reg.q",
          26, 1, 0, "BkdrRegPathRtl");
      cfg_shadowed.add_hdl_path_slice(
          "u_reg.u_cfg_shadowed_en_unsupported_modestrength.shadow_reg.q",
          26, 1, 0, "BkdrRegPathRtlShadow");

      cfg_shadowed.set_is_shadowed();
      // create register tags
      cmd =
          (kmac_reg_cmd::
           type_id::create("cmd"));
      cmd.configure(.blk_parent(this));
      cmd.build(csr_excl);
      default_map.add_reg(.rg(cmd),
                          .offset(32'h18));
      cmd.add_hdl_path_slice(
          "u_reg.u_cmd_cmd.qs",
          0, 6, 0, "BkdrRegPathRtl");
      cmd.add_hdl_path_slice(
          "u_reg.u_cmd_entropy_req.qs",
          8, 1, 0, "BkdrRegPathRtl");
      cmd.add_hdl_path_slice(
          "u_reg.u_cmd_hash_cnt_clr.qs",
          9, 1, 0, "BkdrRegPathRtl");
      cmd.add_hdl_path_slice(
          "u_reg.u_cmd_err_processed.qs",
          10, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(cmd.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      status =
          (kmac_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h1c));
      status.add_hdl_path_slice(
          "u_reg.u_status_sha3_idle.qs",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_sha3_absorb.qs",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_sha3_squeeze.qs",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_fifo_depth.qs",
          8, 5, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_fifo_empty.qs",
          14, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_fifo_full.qs",
          15, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_alert_fatal_fault.qs",
          16, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_alert_recov_ctrl_update_err.qs",
          17, 1, 0, "BkdrRegPathRtl");

      entropy_period =
          (kmac_reg_entropy_period::
           type_id::create("entropy_period"));
      entropy_period.configure(.blk_parent(this));
      entropy_period.build(csr_excl);
      default_map.add_reg(.rg(entropy_period),
                          .offset(32'h20));
      entropy_period.add_hdl_path_slice(
          "u_reg.u_entropy_period_prescaler.q",
          0, 10, 0, "BkdrRegPathRtl");
      entropy_period.add_hdl_path_slice(
          "u_reg.u_entropy_period_wait_timer.q",
          16, 16, 0, "BkdrRegPathRtl");

      entropy_refresh_hash_cnt =
          (kmac_reg_entropy_refresh_hash_cnt::
           type_id::create("entropy_refresh_hash_cnt"));
      entropy_refresh_hash_cnt.configure(.blk_parent(this));
      entropy_refresh_hash_cnt.build(csr_excl);
      default_map.add_reg(.rg(entropy_refresh_hash_cnt),
                          .offset(32'h24));
      entropy_refresh_hash_cnt.add_hdl_path_slice(
          "u_reg.u_entropy_refresh_hash_cnt.q",
          0, 10, 0, "BkdrRegPathRtl");

      entropy_refresh_threshold_shadowed =
          (kmac_reg_entropy_refresh_threshold_shadowed::
           type_id::create("entropy_refresh_threshold_shadowed"));
      entropy_refresh_threshold_shadowed.configure(.blk_parent(this));
      entropy_refresh_threshold_shadowed.build(csr_excl);
      default_map.add_reg(.rg(entropy_refresh_threshold_shadowed),
                          .offset(32'h28));
      entropy_refresh_threshold_shadowed.add_update_err_alert("recov_operation_err");

      entropy_refresh_threshold_shadowed.add_storage_err_alert("fatal_fault_err");

      entropy_refresh_threshold_shadowed.add_hdl_path_slice(
          "u_reg.u_entropy_refresh_threshold_shadowed.committed_reg.q",
          0, 10, 0, "BkdrRegPathRtl");
      entropy_refresh_threshold_shadowed.add_hdl_path_slice(
          "u_reg.u_entropy_refresh_threshold_shadowed.shadow_reg.q",
          0, 10, 0, "BkdrRegPathRtlShadow");

      entropy_refresh_threshold_shadowed.set_is_shadowed();
      entropy_seed =
          (kmac_reg_entropy_seed::
           type_id::create("entropy_seed"));
      entropy_seed.configure(.blk_parent(this));
      entropy_seed.build(csr_excl);
      default_map.add_reg(.rg(entropy_seed),
                          .offset(32'h2c));
      entropy_seed.add_hdl_path_slice(
          "u_reg.u_entropy_seed.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[0] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_0"));
      key_share0[0].configure(.blk_parent(this));
      key_share0[0].build(csr_excl);
      default_map.add_reg(.rg(key_share0[0]),
                          .offset(32'h30));
      key_share0[0].add_hdl_path_slice(
          "u_reg.u_key_share0_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[1] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_1"));
      key_share0[1].configure(.blk_parent(this));
      key_share0[1].build(csr_excl);
      default_map.add_reg(.rg(key_share0[1]),
                          .offset(32'h34));
      key_share0[1].add_hdl_path_slice(
          "u_reg.u_key_share0_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[2] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_2"));
      key_share0[2].configure(.blk_parent(this));
      key_share0[2].build(csr_excl);
      default_map.add_reg(.rg(key_share0[2]),
                          .offset(32'h38));
      key_share0[2].add_hdl_path_slice(
          "u_reg.u_key_share0_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[3] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_3"));
      key_share0[3].configure(.blk_parent(this));
      key_share0[3].build(csr_excl);
      default_map.add_reg(.rg(key_share0[3]),
                          .offset(32'h3c));
      key_share0[3].add_hdl_path_slice(
          "u_reg.u_key_share0_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[4] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_4"));
      key_share0[4].configure(.blk_parent(this));
      key_share0[4].build(csr_excl);
      default_map.add_reg(.rg(key_share0[4]),
                          .offset(32'h40));
      key_share0[4].add_hdl_path_slice(
          "u_reg.u_key_share0_4.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[5] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_5"));
      key_share0[5].configure(.blk_parent(this));
      key_share0[5].build(csr_excl);
      default_map.add_reg(.rg(key_share0[5]),
                          .offset(32'h44));
      key_share0[5].add_hdl_path_slice(
          "u_reg.u_key_share0_5.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[6] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_6"));
      key_share0[6].configure(.blk_parent(this));
      key_share0[6].build(csr_excl);
      default_map.add_reg(.rg(key_share0[6]),
                          .offset(32'h48));
      key_share0[6].add_hdl_path_slice(
          "u_reg.u_key_share0_6.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[7] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_7"));
      key_share0[7].configure(.blk_parent(this));
      key_share0[7].build(csr_excl);
      default_map.add_reg(.rg(key_share0[7]),
                          .offset(32'h4c));
      key_share0[7].add_hdl_path_slice(
          "u_reg.u_key_share0_7.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[8] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_8"));
      key_share0[8].configure(.blk_parent(this));
      key_share0[8].build(csr_excl);
      default_map.add_reg(.rg(key_share0[8]),
                          .offset(32'h50));
      key_share0[8].add_hdl_path_slice(
          "u_reg.u_key_share0_8.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[9] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_9"));
      key_share0[9].configure(.blk_parent(this));
      key_share0[9].build(csr_excl);
      default_map.add_reg(.rg(key_share0[9]),
                          .offset(32'h54));
      key_share0[9].add_hdl_path_slice(
          "u_reg.u_key_share0_9.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[10] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_10"));
      key_share0[10].configure(.blk_parent(this));
      key_share0[10].build(csr_excl);
      default_map.add_reg(.rg(key_share0[10]),
                          .offset(32'h58));
      key_share0[10].add_hdl_path_slice(
          "u_reg.u_key_share0_10.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[11] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_11"));
      key_share0[11].configure(.blk_parent(this));
      key_share0[11].build(csr_excl);
      default_map.add_reg(.rg(key_share0[11]),
                          .offset(32'h5c));
      key_share0[11].add_hdl_path_slice(
          "u_reg.u_key_share0_11.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[12] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_12"));
      key_share0[12].configure(.blk_parent(this));
      key_share0[12].build(csr_excl);
      default_map.add_reg(.rg(key_share0[12]),
                          .offset(32'h60));
      key_share0[12].add_hdl_path_slice(
          "u_reg.u_key_share0_12.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[13] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_13"));
      key_share0[13].configure(.blk_parent(this));
      key_share0[13].build(csr_excl);
      default_map.add_reg(.rg(key_share0[13]),
                          .offset(32'h64));
      key_share0[13].add_hdl_path_slice(
          "u_reg.u_key_share0_13.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[14] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_14"));
      key_share0[14].configure(.blk_parent(this));
      key_share0[14].build(csr_excl);
      default_map.add_reg(.rg(key_share0[14]),
                          .offset(32'h68));
      key_share0[14].add_hdl_path_slice(
          "u_reg.u_key_share0_14.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[15] =
          (kmac_reg_key_share0::
           type_id::create("key_share0_15"));
      key_share0[15].configure(.blk_parent(this));
      key_share0[15].build(csr_excl);
      default_map.add_reg(.rg(key_share0[15]),
                          .offset(32'h6c));
      key_share0[15].add_hdl_path_slice(
          "u_reg.u_key_share0_15.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[0] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_0"));
      key_share1[0].configure(.blk_parent(this));
      key_share1[0].build(csr_excl);
      default_map.add_reg(.rg(key_share1[0]),
                          .offset(32'h70));
      key_share1[0].add_hdl_path_slice(
          "u_reg.u_key_share1_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[1] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_1"));
      key_share1[1].configure(.blk_parent(this));
      key_share1[1].build(csr_excl);
      default_map.add_reg(.rg(key_share1[1]),
                          .offset(32'h74));
      key_share1[1].add_hdl_path_slice(
          "u_reg.u_key_share1_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[2] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_2"));
      key_share1[2].configure(.blk_parent(this));
      key_share1[2].build(csr_excl);
      default_map.add_reg(.rg(key_share1[2]),
                          .offset(32'h78));
      key_share1[2].add_hdl_path_slice(
          "u_reg.u_key_share1_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[3] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_3"));
      key_share1[3].configure(.blk_parent(this));
      key_share1[3].build(csr_excl);
      default_map.add_reg(.rg(key_share1[3]),
                          .offset(32'h7c));
      key_share1[3].add_hdl_path_slice(
          "u_reg.u_key_share1_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[4] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_4"));
      key_share1[4].configure(.blk_parent(this));
      key_share1[4].build(csr_excl);
      default_map.add_reg(.rg(key_share1[4]),
                          .offset(32'h80));
      key_share1[4].add_hdl_path_slice(
          "u_reg.u_key_share1_4.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[5] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_5"));
      key_share1[5].configure(.blk_parent(this));
      key_share1[5].build(csr_excl);
      default_map.add_reg(.rg(key_share1[5]),
                          .offset(32'h84));
      key_share1[5].add_hdl_path_slice(
          "u_reg.u_key_share1_5.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[6] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_6"));
      key_share1[6].configure(.blk_parent(this));
      key_share1[6].build(csr_excl);
      default_map.add_reg(.rg(key_share1[6]),
                          .offset(32'h88));
      key_share1[6].add_hdl_path_slice(
          "u_reg.u_key_share1_6.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[7] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_7"));
      key_share1[7].configure(.blk_parent(this));
      key_share1[7].build(csr_excl);
      default_map.add_reg(.rg(key_share1[7]),
                          .offset(32'h8c));
      key_share1[7].add_hdl_path_slice(
          "u_reg.u_key_share1_7.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[8] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_8"));
      key_share1[8].configure(.blk_parent(this));
      key_share1[8].build(csr_excl);
      default_map.add_reg(.rg(key_share1[8]),
                          .offset(32'h90));
      key_share1[8].add_hdl_path_slice(
          "u_reg.u_key_share1_8.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[9] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_9"));
      key_share1[9].configure(.blk_parent(this));
      key_share1[9].build(csr_excl);
      default_map.add_reg(.rg(key_share1[9]),
                          .offset(32'h94));
      key_share1[9].add_hdl_path_slice(
          "u_reg.u_key_share1_9.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[10] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_10"));
      key_share1[10].configure(.blk_parent(this));
      key_share1[10].build(csr_excl);
      default_map.add_reg(.rg(key_share1[10]),
                          .offset(32'h98));
      key_share1[10].add_hdl_path_slice(
          "u_reg.u_key_share1_10.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[11] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_11"));
      key_share1[11].configure(.blk_parent(this));
      key_share1[11].build(csr_excl);
      default_map.add_reg(.rg(key_share1[11]),
                          .offset(32'h9c));
      key_share1[11].add_hdl_path_slice(
          "u_reg.u_key_share1_11.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[12] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_12"));
      key_share1[12].configure(.blk_parent(this));
      key_share1[12].build(csr_excl);
      default_map.add_reg(.rg(key_share1[12]),
                          .offset(32'ha0));
      key_share1[12].add_hdl_path_slice(
          "u_reg.u_key_share1_12.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[13] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_13"));
      key_share1[13].configure(.blk_parent(this));
      key_share1[13].build(csr_excl);
      default_map.add_reg(.rg(key_share1[13]),
                          .offset(32'ha4));
      key_share1[13].add_hdl_path_slice(
          "u_reg.u_key_share1_13.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[14] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_14"));
      key_share1[14].configure(.blk_parent(this));
      key_share1[14].build(csr_excl);
      default_map.add_reg(.rg(key_share1[14]),
                          .offset(32'ha8));
      key_share1[14].add_hdl_path_slice(
          "u_reg.u_key_share1_14.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[15] =
          (kmac_reg_key_share1::
           type_id::create("key_share1_15"));
      key_share1[15].configure(.blk_parent(this));
      key_share1[15].build(csr_excl);
      default_map.add_reg(.rg(key_share1[15]),
                          .offset(32'hac));
      key_share1[15].add_hdl_path_slice(
          "u_reg.u_key_share1_15.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_len =
          (kmac_reg_key_len::
           type_id::create("key_len"));
      key_len.configure(.blk_parent(this));
      key_len.build(csr_excl);
      default_map.add_reg(.rg(key_len),
                          .offset(32'hb0));
      key_len.add_hdl_path_slice(
          "u_reg.u_key_len.q",
          0, 3, 0, "BkdrRegPathRtl");

      prefix[0] =
          (kmac_reg_prefix::
           type_id::create("prefix_0"));
      prefix[0].configure(.blk_parent(this));
      prefix[0].build(csr_excl);
      default_map.add_reg(.rg(prefix[0]),
                          .offset(32'hb4));
      prefix[0].add_hdl_path_slice(
          "u_reg.u_prefix_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[1] =
          (kmac_reg_prefix::
           type_id::create("prefix_1"));
      prefix[1].configure(.blk_parent(this));
      prefix[1].build(csr_excl);
      default_map.add_reg(.rg(prefix[1]),
                          .offset(32'hb8));
      prefix[1].add_hdl_path_slice(
          "u_reg.u_prefix_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[2] =
          (kmac_reg_prefix::
           type_id::create("prefix_2"));
      prefix[2].configure(.blk_parent(this));
      prefix[2].build(csr_excl);
      default_map.add_reg(.rg(prefix[2]),
                          .offset(32'hbc));
      prefix[2].add_hdl_path_slice(
          "u_reg.u_prefix_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[3] =
          (kmac_reg_prefix::
           type_id::create("prefix_3"));
      prefix[3].configure(.blk_parent(this));
      prefix[3].build(csr_excl);
      default_map.add_reg(.rg(prefix[3]),
                          .offset(32'hc0));
      prefix[3].add_hdl_path_slice(
          "u_reg.u_prefix_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[4] =
          (kmac_reg_prefix::
           type_id::create("prefix_4"));
      prefix[4].configure(.blk_parent(this));
      prefix[4].build(csr_excl);
      default_map.add_reg(.rg(prefix[4]),
                          .offset(32'hc4));
      prefix[4].add_hdl_path_slice(
          "u_reg.u_prefix_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[5] =
          (kmac_reg_prefix::
           type_id::create("prefix_5"));
      prefix[5].configure(.blk_parent(this));
      prefix[5].build(csr_excl);
      default_map.add_reg(.rg(prefix[5]),
                          .offset(32'hc8));
      prefix[5].add_hdl_path_slice(
          "u_reg.u_prefix_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[6] =
          (kmac_reg_prefix::
           type_id::create("prefix_6"));
      prefix[6].configure(.blk_parent(this));
      prefix[6].build(csr_excl);
      default_map.add_reg(.rg(prefix[6]),
                          .offset(32'hcc));
      prefix[6].add_hdl_path_slice(
          "u_reg.u_prefix_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[7] =
          (kmac_reg_prefix::
           type_id::create("prefix_7"));
      prefix[7].configure(.blk_parent(this));
      prefix[7].build(csr_excl);
      default_map.add_reg(.rg(prefix[7]),
                          .offset(32'hd0));
      prefix[7].add_hdl_path_slice(
          "u_reg.u_prefix_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[8] =
          (kmac_reg_prefix::
           type_id::create("prefix_8"));
      prefix[8].configure(.blk_parent(this));
      prefix[8].build(csr_excl);
      default_map.add_reg(.rg(prefix[8]),
                          .offset(32'hd4));
      prefix[8].add_hdl_path_slice(
          "u_reg.u_prefix_8.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[9] =
          (kmac_reg_prefix::
           type_id::create("prefix_9"));
      prefix[9].configure(.blk_parent(this));
      prefix[9].build(csr_excl);
      default_map.add_reg(.rg(prefix[9]),
                          .offset(32'hd8));
      prefix[9].add_hdl_path_slice(
          "u_reg.u_prefix_9.q",
          0, 32, 0, "BkdrRegPathRtl");

      prefix[10] =
          (kmac_reg_prefix::
           type_id::create("prefix_10"));
      prefix[10].configure(.blk_parent(this));
      prefix[10].build(csr_excl);
      default_map.add_reg(.rg(prefix[10]),
                          .offset(32'hdc));
      prefix[10].add_hdl_path_slice(
          "u_reg.u_prefix_10.q",
          0, 32, 0, "BkdrRegPathRtl");

      err_code =
          (kmac_reg_err_code::
           type_id::create("err_code"));
      err_code.configure(.blk_parent(this));
      err_code.build(csr_excl);
      default_map.add_reg(.rg(err_code),
                          .offset(32'he0));
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code.q",
          0, 32, 0, "BkdrRegPathRtl");

      // assign locked reg to its regwen reg
      cfg_regwen.add_lockable_reg_or_fld(cfg_shadowed);
      cfg_regwen.add_lockable_reg_or_fld(entropy_period);
      cfg_regwen.add_lockable_reg_or_fld(entropy_refresh_hash_cnt);
      cfg_regwen.add_lockable_reg_or_fld(entropy_refresh_threshold_shadowed);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[0]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[1]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[2]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[3]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[4]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[5]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[6]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[7]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[8]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[9]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[10]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[11]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[12]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[13]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[14]);
      cfg_regwen.add_lockable_reg_or_fld(key_share0[15]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[0]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[1]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[2]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[3]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[4]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[5]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[6]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[7]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[8]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[9]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[10]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[11]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[12]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[13]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[14]);
      cfg_regwen.add_lockable_reg_or_fld(key_share1[15]);
      cfg_regwen.add_lockable_reg_or_fld(key_len);
      cfg_regwen.add_lockable_reg_or_fld(prefix[0]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[1]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[2]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[3]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[4]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[5]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[6]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[7]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[8]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[9]);
      cfg_regwen.add_lockable_reg_or_fld(prefix[10]);

      // create memories
      state =
          kmac_mem_state::type_id::create("state");
      state.configure(.parent(this));
      default_map.add_mem(.mem(state),
                          .offset(32'h400),
                          .rights("RO"));
      msg_fifo =
          kmac_mem_msg_fifo::type_id::create("msg_fifo");
      msg_fifo.configure(.parent(this));
      default_map.add_mem(.mem(msg_fifo),
                          .offset(32'h800),
                          .rights("WO"));


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : kmac_reg_block

endpackage

