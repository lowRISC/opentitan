// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package lc_ctrl_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class lc_ctrl_reg_alert_test;
  typedef class lc_ctrl_reg_status;
  typedef class lc_ctrl_reg_claim_transition_if_regwen;
  typedef class lc_ctrl_reg_claim_transition_if;
  typedef class lc_ctrl_reg_transition_regwen;
  typedef class lc_ctrl_reg_transition_cmd;
  typedef class lc_ctrl_reg_transition_ctrl;
  typedef class lc_ctrl_reg_transition_token;
  typedef class lc_ctrl_reg_transition_target;
  typedef class lc_ctrl_reg_otp_vendor_test_ctrl;
  typedef class lc_ctrl_reg_otp_vendor_test_status;
  typedef class lc_ctrl_reg_lc_state;
  typedef class lc_ctrl_reg_lc_transition_cnt;
  typedef class lc_ctrl_reg_lc_id_state;
  typedef class lc_ctrl_reg_hw_revision0;
  typedef class lc_ctrl_reg_hw_revision1;
  typedef class lc_ctrl_reg_device_id;
  typedef class lc_ctrl_reg_manuf_state;
  typedef class lc_ctrl_reg_block;

  class lc_ctrl_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_prog_error;
    rand dv_base_reg_field fatal_state_error;
    rand dv_base_reg_field fatal_bus_integ_error;

    `uvm_object_utils(lc_ctrl_reg_alert_test)

    function new(string       name = "lc_ctrl_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_prog_error =
          (dv_base_reg_field::
           type_id::create("fatal_prog_error"));
      fatal_prog_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_prog_error.set_original_access("WO");
      fatal_state_error =
          (dv_base_reg_field::
           type_id::create("fatal_state_error"));
      fatal_state_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_state_error.set_original_access("WO");
      fatal_bus_integ_error =
          (dv_base_reg_field::
           type_id::create("fatal_bus_integ_error"));
      fatal_bus_integ_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_bus_integ_error.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_alert_test

  class lc_ctrl_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field initialized;
    rand dv_base_reg_field ready;
    rand dv_base_reg_field ext_clock_switched;
    rand dv_base_reg_field transition_successful;
    rand dv_base_reg_field transition_count_error;
    rand dv_base_reg_field transition_error;
    rand dv_base_reg_field token_error;
    rand dv_base_reg_field flash_rma_error;
    rand dv_base_reg_field otp_error;
    rand dv_base_reg_field state_error;
    rand dv_base_reg_field bus_integ_error;
    rand dv_base_reg_field otp_partition_error;

    `uvm_object_utils(lc_ctrl_reg_status)

    function new(string       name = "lc_ctrl_reg_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      initialized =
          (dv_base_reg_field::
           type_id::create("initialized"));
      initialized.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      initialized.set_original_access("RO");
      ready =
          (dv_base_reg_field::
           type_id::create("ready"));
      ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ready.set_original_access("RO");
      ext_clock_switched =
          (dv_base_reg_field::
           type_id::create("ext_clock_switched"));
      ext_clock_switched.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ext_clock_switched.set_original_access("RO");
      transition_successful =
          (dv_base_reg_field::
           type_id::create("transition_successful"));
      transition_successful.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      transition_successful.set_original_access("RO");
      transition_count_error =
          (dv_base_reg_field::
           type_id::create("transition_count_error"));
      transition_count_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      transition_count_error.set_original_access("RO");
      transition_error =
          (dv_base_reg_field::
           type_id::create("transition_error"));
      transition_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      transition_error.set_original_access("RO");
      token_error =
          (dv_base_reg_field::
           type_id::create("token_error"));
      token_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      token_error.set_original_access("RO");
      flash_rma_error =
          (dv_base_reg_field::
           type_id::create("flash_rma_error"));
      flash_rma_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_rma_error.set_original_access("RO");
      otp_error =
          (dv_base_reg_field::
           type_id::create("otp_error"));
      otp_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      otp_error.set_original_access("RO");
      state_error =
          (dv_base_reg_field::
           type_id::create("state_error"));
      state_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      state_error.set_original_access("RO");
      bus_integ_error =
          (dv_base_reg_field::
           type_id::create("bus_integ_error"));
      bus_integ_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus_integ_error.set_original_access("RO");
      otp_partition_error =
          (dv_base_reg_field::
           type_id::create("otp_partition_error"));
      otp_partition_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      otp_partition_error.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_status

  class lc_ctrl_reg_claim_transition_if_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field claim_transition_if_regwen;

    `uvm_object_utils(lc_ctrl_reg_claim_transition_if_regwen)

    function new(string       name = "lc_ctrl_reg_claim_transition_if_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      claim_transition_if_regwen =
          (dv_base_reg_field::
           type_id::create("claim_transition_if_regwen"));
      claim_transition_if_regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      claim_transition_if_regwen.set_original_access("W0C");
    endfunction : build
  endclass : lc_ctrl_reg_claim_transition_if_regwen

  class lc_ctrl_reg_claim_transition_if extends dv_base_reg;
    // fields
    rand dv_base_reg_field mutex;

    `uvm_object_utils(lc_ctrl_reg_claim_transition_if)

    function new(string       name = "lc_ctrl_reg_claim_transition_if",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      mutex =
          (dv_base_reg_field::
           type_id::create("mutex"));
      mutex.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(1),
        .reset(32'h69),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mutex.set_original_access("RW");
      mutex.set_mubi_width(8);
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_claim_transition_if

  class lc_ctrl_reg_transition_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field transition_regwen;

    `uvm_object_utils(lc_ctrl_reg_transition_regwen)

    function new(string       name = "lc_ctrl_reg_transition_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      transition_regwen =
          (dv_base_reg_field::
           type_id::create("transition_regwen"));
      transition_regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      transition_regwen.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_transition_regwen

  class lc_ctrl_reg_transition_cmd extends dv_base_reg;
    // fields
    rand dv_base_reg_field start;

    `uvm_object_utils(lc_ctrl_reg_transition_cmd)

    function new(string       name = "lc_ctrl_reg_transition_cmd",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      start =
          (dv_base_reg_field::
           type_id::create("start"));
      start.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      start.set_original_access("W1C");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_transition_cmd

  class lc_ctrl_reg_transition_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field ext_clock_en;
    rand dv_base_reg_field volatile_raw_unlock;

    `uvm_object_utils(lc_ctrl_reg_transition_ctrl)

    function new(string       name = "lc_ctrl_reg_transition_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ext_clock_en =
          (dv_base_reg_field::
           type_id::create("ext_clock_en"));
      ext_clock_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1S"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ext_clock_en.set_original_access("W1S");
      volatile_raw_unlock =
          (dv_base_reg_field::
           type_id::create("volatile_raw_unlock"));
      volatile_raw_unlock.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      volatile_raw_unlock.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_transition_ctrl

  class lc_ctrl_reg_transition_token extends dv_base_reg;
    // fields
    rand dv_base_reg_field transition_token;

    `uvm_object_utils(lc_ctrl_reg_transition_token)

    function new(string       name = "lc_ctrl_reg_transition_token",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      transition_token =
          (dv_base_reg_field::
           type_id::create("transition_token_0"));
      transition_token.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      transition_token.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_transition_token

  class lc_ctrl_reg_transition_target extends dv_base_reg;
    // fields
    rand dv_base_reg_field state;

    `uvm_object_utils(lc_ctrl_reg_transition_target)

    function new(string       name = "lc_ctrl_reg_transition_target",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      state =
          (dv_base_reg_field::
           type_id::create("state"));
      state.configure(
        .parent(this),
        .size(30),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      state.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(state.get_full_name(), CsrExclCheck, CsrNonInitTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_transition_target

  class lc_ctrl_reg_otp_vendor_test_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field otp_vendor_test_ctrl;

    `uvm_object_utils(lc_ctrl_reg_otp_vendor_test_ctrl)

    function new(string       name = "lc_ctrl_reg_otp_vendor_test_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      otp_vendor_test_ctrl =
          (dv_base_reg_field::
           type_id::create("otp_vendor_test_ctrl"));
      otp_vendor_test_ctrl.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      otp_vendor_test_ctrl.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_otp_vendor_test_ctrl

  class lc_ctrl_reg_otp_vendor_test_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field otp_vendor_test_status;

    `uvm_object_utils(lc_ctrl_reg_otp_vendor_test_status)

    function new(string       name = "lc_ctrl_reg_otp_vendor_test_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      otp_vendor_test_status =
          (dv_base_reg_field::
           type_id::create("otp_vendor_test_status"));
      otp_vendor_test_status.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      otp_vendor_test_status.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_otp_vendor_test_status

  class lc_ctrl_reg_lc_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field state;

    `uvm_object_utils(lc_ctrl_reg_lc_state)

    function new(string       name = "lc_ctrl_reg_lc_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      state =
          (dv_base_reg_field::
           type_id::create("state"));
      state.configure(
        .parent(this),
        .size(30),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      state.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_lc_state

  class lc_ctrl_reg_lc_transition_cnt extends dv_base_reg;
    // fields
    rand dv_base_reg_field cnt;

    `uvm_object_utils(lc_ctrl_reg_lc_transition_cnt)

    function new(string       name = "lc_ctrl_reg_lc_transition_cnt",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cnt =
          (dv_base_reg_field::
           type_id::create("cnt"));
      cnt.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cnt.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_lc_transition_cnt

  class lc_ctrl_reg_lc_id_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field state;

    `uvm_object_utils(lc_ctrl_reg_lc_id_state)

    function new(string       name = "lc_ctrl_reg_lc_id_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      state =
          (dv_base_reg_field::
           type_id::create("state"));
      state.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      state.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_lc_id_state

  class lc_ctrl_reg_hw_revision0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field product_id;
    rand dv_base_reg_field silicon_creator_id;

    `uvm_object_utils(lc_ctrl_reg_hw_revision0)

    function new(string       name = "lc_ctrl_reg_hw_revision0",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      product_id =
          (dv_base_reg_field::
           type_id::create("product_id"));
      product_id.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      product_id.set_original_access("RO");
      silicon_creator_id =
          (dv_base_reg_field::
           type_id::create("silicon_creator_id"));
      silicon_creator_id.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      silicon_creator_id.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_hw_revision0

  class lc_ctrl_reg_hw_revision1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field revision_id;
    rand dv_base_reg_field reserved;

    `uvm_object_utils(lc_ctrl_reg_hw_revision1)

    function new(string       name = "lc_ctrl_reg_hw_revision1",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      revision_id =
          (dv_base_reg_field::
           type_id::create("revision_id"));
      revision_id.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      revision_id.set_original_access("RO");
      reserved =
          (dv_base_reg_field::
           type_id::create("reserved"));
      reserved.configure(
        .parent(this),
        .size(24),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      reserved.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_hw_revision1

  class lc_ctrl_reg_device_id extends dv_base_reg;
    // fields
    rand dv_base_reg_field device_id;

    `uvm_object_utils(lc_ctrl_reg_device_id)

    function new(string       name = "lc_ctrl_reg_device_id",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      device_id =
          (dv_base_reg_field::
           type_id::create("device_id_0"));
      device_id.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      device_id.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_device_id

  class lc_ctrl_reg_manuf_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field manuf_state;

    `uvm_object_utils(lc_ctrl_reg_manuf_state)

    function new(string       name = "lc_ctrl_reg_manuf_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      manuf_state =
          (dv_base_reg_field::
           type_id::create("manuf_state_0"));
      manuf_state.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      manuf_state.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : lc_ctrl_reg_manuf_state

  class lc_ctrl_reg_block extends dv_base_reg_block;
    // registers
    rand lc_ctrl_reg_alert_test alert_test;
    rand lc_ctrl_reg_status status;
    rand lc_ctrl_reg_claim_transition_if_regwen claim_transition_if_regwen;
    rand lc_ctrl_reg_claim_transition_if claim_transition_if;
    rand lc_ctrl_reg_transition_regwen transition_regwen;
    rand lc_ctrl_reg_transition_cmd transition_cmd;
    rand lc_ctrl_reg_transition_ctrl transition_ctrl;
    rand lc_ctrl_reg_transition_token transition_token[4];
    rand lc_ctrl_reg_transition_target transition_target;
    rand lc_ctrl_reg_otp_vendor_test_ctrl otp_vendor_test_ctrl;
    rand lc_ctrl_reg_otp_vendor_test_status otp_vendor_test_status;
    rand lc_ctrl_reg_lc_state lc_state;
    rand lc_ctrl_reg_lc_transition_cnt lc_transition_cnt;
    rand lc_ctrl_reg_lc_id_state lc_id_state;
    rand lc_ctrl_reg_hw_revision0 hw_revision0;
    rand lc_ctrl_reg_hw_revision1 hw_revision1;
    rand lc_ctrl_reg_device_id device_id[8];
    rand lc_ctrl_reg_manuf_state manuf_state[8];

    `uvm_object_utils(lc_ctrl_reg_block)

    function new(string name = "lc_ctrl_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      alert_test =
          (lc_ctrl_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'h0));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_prog_error.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_state_error.qs",
          1, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_bus_integ_error.qs",
          2, 1, 0, "BkdrRegPathRtl");

      status =
          (lc_ctrl_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h4));
      status.add_hdl_path_slice(
          "u_reg.u_status_initialized.qs",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_ready.qs",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_ext_clock_switched.qs",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_transition_successful.qs",
          3, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_transition_count_error.qs",
          4, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_transition_error.qs",
          5, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_token_error.qs",
          6, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_flash_rma_error.qs",
          7, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_otp_error.qs",
          8, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_state_error.qs",
          9, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_bus_integ_error.qs",
          10, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_otp_partition_error.qs",
          11, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(status.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      claim_transition_if_regwen =
          (lc_ctrl_reg_claim_transition_if_regwen::
           type_id::create("claim_transition_if_regwen"));
      claim_transition_if_regwen.configure(.blk_parent(this));
      claim_transition_if_regwen.build(csr_excl);
      default_map.add_reg(.rg(claim_transition_if_regwen),
                          .offset(32'h8));
      claim_transition_if_regwen.add_hdl_path_slice(
          "u_reg.u_claim_transition_if_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      claim_transition_if =
          (lc_ctrl_reg_claim_transition_if::
           type_id::create("claim_transition_if"));
      claim_transition_if.configure(.blk_parent(this));
      claim_transition_if.build(csr_excl);
      default_map.add_reg(.rg(claim_transition_if),
                          .offset(32'hc));
      claim_transition_if.add_hdl_path_slice(
          "u_reg.u_claim_transition_if.qs",
          0, 8, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(claim_transition_if.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      transition_regwen =
          (lc_ctrl_reg_transition_regwen::
           type_id::create("transition_regwen"));
      transition_regwen.configure(.blk_parent(this));
      transition_regwen.build(csr_excl);
      default_map.add_reg(.rg(transition_regwen),
                          .offset(32'h10));
      transition_regwen.add_hdl_path_slice(
          "u_reg.u_transition_regwen.qs",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(transition_regwen.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      transition_cmd =
          (lc_ctrl_reg_transition_cmd::
           type_id::create("transition_cmd"));
      transition_cmd.configure(.blk_parent(this));
      transition_cmd.build(csr_excl);
      default_map.add_reg(.rg(transition_cmd),
                          .offset(32'h14));
      transition_cmd.add_hdl_path_slice(
          "u_reg.u_transition_cmd.qs",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(transition_cmd.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      transition_ctrl =
          (lc_ctrl_reg_transition_ctrl::
           type_id::create("transition_ctrl"));
      transition_ctrl.configure(.blk_parent(this));
      transition_ctrl.build(csr_excl);
      default_map.add_reg(.rg(transition_ctrl),
                          .offset(32'h18));
      transition_ctrl.add_hdl_path_slice(
          "u_reg.u_transition_ctrl_ext_clock_en.qs",
          0, 1, 0, "BkdrRegPathRtl");
      transition_ctrl.add_hdl_path_slice(
          "u_reg.u_transition_ctrl_volatile_raw_unlock.qs",
          1, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(transition_ctrl.get_full_name(),
                        CsrExclAll, CsrAllTests);
      transition_token[0] =
          (lc_ctrl_reg_transition_token::
           type_id::create("transition_token_0"));
      transition_token[0].configure(.blk_parent(this));
      transition_token[0].build(csr_excl);
      default_map.add_reg(.rg(transition_token[0]),
                          .offset(32'h1c));
      transition_token[0].add_hdl_path_slice(
          "u_reg.u_transition_token_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(transition_token[0].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      transition_token[1] =
          (lc_ctrl_reg_transition_token::
           type_id::create("transition_token_1"));
      transition_token[1].configure(.blk_parent(this));
      transition_token[1].build(csr_excl);
      default_map.add_reg(.rg(transition_token[1]),
                          .offset(32'h20));
      transition_token[1].add_hdl_path_slice(
          "u_reg.u_transition_token_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(transition_token[1].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      transition_token[2] =
          (lc_ctrl_reg_transition_token::
           type_id::create("transition_token_2"));
      transition_token[2].configure(.blk_parent(this));
      transition_token[2].build(csr_excl);
      default_map.add_reg(.rg(transition_token[2]),
                          .offset(32'h24));
      transition_token[2].add_hdl_path_slice(
          "u_reg.u_transition_token_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(transition_token[2].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      transition_token[3] =
          (lc_ctrl_reg_transition_token::
           type_id::create("transition_token_3"));
      transition_token[3].configure(.blk_parent(this));
      transition_token[3].build(csr_excl);
      default_map.add_reg(.rg(transition_token[3]),
                          .offset(32'h28));
      transition_token[3].add_hdl_path_slice(
          "u_reg.u_transition_token_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(transition_token[3].get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      transition_target =
          (lc_ctrl_reg_transition_target::
           type_id::create("transition_target"));
      transition_target.configure(.blk_parent(this));
      transition_target.build(csr_excl);
      default_map.add_reg(.rg(transition_target),
                          .offset(32'h2c));
      transition_target.add_hdl_path_slice(
          "u_reg.u_transition_target.qs",
          0, 30, 0, "BkdrRegPathRtl");

      otp_vendor_test_ctrl =
          (lc_ctrl_reg_otp_vendor_test_ctrl::
           type_id::create("otp_vendor_test_ctrl"));
      otp_vendor_test_ctrl.configure(.blk_parent(this));
      otp_vendor_test_ctrl.build(csr_excl);
      default_map.add_reg(.rg(otp_vendor_test_ctrl),
                          .offset(32'h30));
      otp_vendor_test_ctrl.add_hdl_path_slice(
          "u_reg.u_otp_vendor_test_ctrl.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(otp_vendor_test_ctrl.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      otp_vendor_test_status =
          (lc_ctrl_reg_otp_vendor_test_status::
           type_id::create("otp_vendor_test_status"));
      otp_vendor_test_status.configure(.blk_parent(this));
      otp_vendor_test_status.build(csr_excl);
      default_map.add_reg(.rg(otp_vendor_test_status),
                          .offset(32'h34));
      otp_vendor_test_status.add_hdl_path_slice(
          "u_reg.u_otp_vendor_test_status.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(otp_vendor_test_status.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      lc_state =
          (lc_ctrl_reg_lc_state::
           type_id::create("lc_state"));
      lc_state.configure(.blk_parent(this));
      lc_state.build(csr_excl);
      default_map.add_reg(.rg(lc_state),
                          .offset(32'h38));
      lc_state.add_hdl_path_slice(
          "u_reg.u_lc_state.qs",
          0, 30, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(lc_state.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      lc_transition_cnt =
          (lc_ctrl_reg_lc_transition_cnt::
           type_id::create("lc_transition_cnt"));
      lc_transition_cnt.configure(.blk_parent(this));
      lc_transition_cnt.build(csr_excl);
      default_map.add_reg(.rg(lc_transition_cnt),
                          .offset(32'h3c));
      lc_transition_cnt.add_hdl_path_slice(
          "u_reg.u_lc_transition_cnt.qs",
          0, 5, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(lc_transition_cnt.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      lc_id_state =
          (lc_ctrl_reg_lc_id_state::
           type_id::create("lc_id_state"));
      lc_id_state.configure(.blk_parent(this));
      lc_id_state.build(csr_excl);
      default_map.add_reg(.rg(lc_id_state),
                          .offset(32'h40));
      lc_id_state.add_hdl_path_slice(
          "u_reg.u_lc_id_state.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(lc_id_state.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      hw_revision0 =
          (lc_ctrl_reg_hw_revision0::
           type_id::create("hw_revision0"));
      hw_revision0.configure(.blk_parent(this));
      hw_revision0.build(csr_excl);
      default_map.add_reg(.rg(hw_revision0),
                          .offset(32'h44));
      hw_revision0.add_hdl_path_slice(
          "u_reg.u_hw_revision0_product_id.qs",
          0, 16, 0, "BkdrRegPathRtl");
      hw_revision0.add_hdl_path_slice(
          "u_reg.u_hw_revision0_silicon_creator_id.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(hw_revision0.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      hw_revision1 =
          (lc_ctrl_reg_hw_revision1::
           type_id::create("hw_revision1"));
      hw_revision1.configure(.blk_parent(this));
      hw_revision1.build(csr_excl);
      default_map.add_reg(.rg(hw_revision1),
                          .offset(32'h48));
      hw_revision1.add_hdl_path_slice(
          "u_reg.u_hw_revision1_revision_id.qs",
          0, 8, 0, "BkdrRegPathRtl");
      hw_revision1.add_hdl_path_slice(
          "u_reg.u_hw_revision1_reserved.qs",
          8, 24, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(hw_revision1.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      device_id[0] =
          (lc_ctrl_reg_device_id::
           type_id::create("device_id_0"));
      device_id[0].configure(.blk_parent(this));
      device_id[0].build(csr_excl);
      default_map.add_reg(.rg(device_id[0]),
                          .offset(32'h4c));
      device_id[0].add_hdl_path_slice(
          "u_reg.u_device_id_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(device_id[0].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      device_id[1] =
          (lc_ctrl_reg_device_id::
           type_id::create("device_id_1"));
      device_id[1].configure(.blk_parent(this));
      device_id[1].build(csr_excl);
      default_map.add_reg(.rg(device_id[1]),
                          .offset(32'h50));
      device_id[1].add_hdl_path_slice(
          "u_reg.u_device_id_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(device_id[1].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      device_id[2] =
          (lc_ctrl_reg_device_id::
           type_id::create("device_id_2"));
      device_id[2].configure(.blk_parent(this));
      device_id[2].build(csr_excl);
      default_map.add_reg(.rg(device_id[2]),
                          .offset(32'h54));
      device_id[2].add_hdl_path_slice(
          "u_reg.u_device_id_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(device_id[2].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      device_id[3] =
          (lc_ctrl_reg_device_id::
           type_id::create("device_id_3"));
      device_id[3].configure(.blk_parent(this));
      device_id[3].build(csr_excl);
      default_map.add_reg(.rg(device_id[3]),
                          .offset(32'h58));
      device_id[3].add_hdl_path_slice(
          "u_reg.u_device_id_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(device_id[3].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      device_id[4] =
          (lc_ctrl_reg_device_id::
           type_id::create("device_id_4"));
      device_id[4].configure(.blk_parent(this));
      device_id[4].build(csr_excl);
      default_map.add_reg(.rg(device_id[4]),
                          .offset(32'h5c));
      device_id[4].add_hdl_path_slice(
          "u_reg.u_device_id_4.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(device_id[4].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      device_id[5] =
          (lc_ctrl_reg_device_id::
           type_id::create("device_id_5"));
      device_id[5].configure(.blk_parent(this));
      device_id[5].build(csr_excl);
      default_map.add_reg(.rg(device_id[5]),
                          .offset(32'h60));
      device_id[5].add_hdl_path_slice(
          "u_reg.u_device_id_5.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(device_id[5].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      device_id[6] =
          (lc_ctrl_reg_device_id::
           type_id::create("device_id_6"));
      device_id[6].configure(.blk_parent(this));
      device_id[6].build(csr_excl);
      default_map.add_reg(.rg(device_id[6]),
                          .offset(32'h64));
      device_id[6].add_hdl_path_slice(
          "u_reg.u_device_id_6.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(device_id[6].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      device_id[7] =
          (lc_ctrl_reg_device_id::
           type_id::create("device_id_7"));
      device_id[7].configure(.blk_parent(this));
      device_id[7].build(csr_excl);
      default_map.add_reg(.rg(device_id[7]),
                          .offset(32'h68));
      device_id[7].add_hdl_path_slice(
          "u_reg.u_device_id_7.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(device_id[7].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      manuf_state[0] =
          (lc_ctrl_reg_manuf_state::
           type_id::create("manuf_state_0"));
      manuf_state[0].configure(.blk_parent(this));
      manuf_state[0].build(csr_excl);
      default_map.add_reg(.rg(manuf_state[0]),
                          .offset(32'h6c));
      manuf_state[0].add_hdl_path_slice(
          "u_reg.u_manuf_state_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(manuf_state[0].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      manuf_state[1] =
          (lc_ctrl_reg_manuf_state::
           type_id::create("manuf_state_1"));
      manuf_state[1].configure(.blk_parent(this));
      manuf_state[1].build(csr_excl);
      default_map.add_reg(.rg(manuf_state[1]),
                          .offset(32'h70));
      manuf_state[1].add_hdl_path_slice(
          "u_reg.u_manuf_state_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(manuf_state[1].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      manuf_state[2] =
          (lc_ctrl_reg_manuf_state::
           type_id::create("manuf_state_2"));
      manuf_state[2].configure(.blk_parent(this));
      manuf_state[2].build(csr_excl);
      default_map.add_reg(.rg(manuf_state[2]),
                          .offset(32'h74));
      manuf_state[2].add_hdl_path_slice(
          "u_reg.u_manuf_state_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(manuf_state[2].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      manuf_state[3] =
          (lc_ctrl_reg_manuf_state::
           type_id::create("manuf_state_3"));
      manuf_state[3].configure(.blk_parent(this));
      manuf_state[3].build(csr_excl);
      default_map.add_reg(.rg(manuf_state[3]),
                          .offset(32'h78));
      manuf_state[3].add_hdl_path_slice(
          "u_reg.u_manuf_state_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(manuf_state[3].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      manuf_state[4] =
          (lc_ctrl_reg_manuf_state::
           type_id::create("manuf_state_4"));
      manuf_state[4].configure(.blk_parent(this));
      manuf_state[4].build(csr_excl);
      default_map.add_reg(.rg(manuf_state[4]),
                          .offset(32'h7c));
      manuf_state[4].add_hdl_path_slice(
          "u_reg.u_manuf_state_4.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(manuf_state[4].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      manuf_state[5] =
          (lc_ctrl_reg_manuf_state::
           type_id::create("manuf_state_5"));
      manuf_state[5].configure(.blk_parent(this));
      manuf_state[5].build(csr_excl);
      default_map.add_reg(.rg(manuf_state[5]),
                          .offset(32'h80));
      manuf_state[5].add_hdl_path_slice(
          "u_reg.u_manuf_state_5.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(manuf_state[5].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      manuf_state[6] =
          (lc_ctrl_reg_manuf_state::
           type_id::create("manuf_state_6"));
      manuf_state[6].configure(.blk_parent(this));
      manuf_state[6].build(csr_excl);
      default_map.add_reg(.rg(manuf_state[6]),
                          .offset(32'h84));
      manuf_state[6].add_hdl_path_slice(
          "u_reg.u_manuf_state_6.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(manuf_state[6].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      manuf_state[7] =
          (lc_ctrl_reg_manuf_state::
           type_id::create("manuf_state_7"));
      manuf_state[7].configure(.blk_parent(this));
      manuf_state[7].build(csr_excl);
      default_map.add_reg(.rg(manuf_state[7]),
                          .offset(32'h88));
      manuf_state[7].add_hdl_path_slice(
          "u_reg.u_manuf_state_7.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(manuf_state[7].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      // assign locked reg to its regwen reg
      claim_transition_if_regwen.add_lockable_reg_or_fld(claim_transition_if);
      transition_regwen.add_lockable_reg_or_fld(transition_cmd);
      transition_regwen.add_lockable_reg_or_fld(transition_ctrl);
      transition_regwen.add_lockable_reg_or_fld(transition_token[0]);
      transition_regwen.add_lockable_reg_or_fld(transition_token[1]);
      transition_regwen.add_lockable_reg_or_fld(transition_token[2]);
      transition_regwen.add_lockable_reg_or_fld(transition_token[3]);
      transition_regwen.add_lockable_reg_or_fld(transition_target);
      transition_regwen.add_lockable_reg_or_fld(otp_vendor_test_ctrl);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : lc_ctrl_reg_block

endpackage

