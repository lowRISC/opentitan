# Copyright lowRISC contributors.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

load("@rules_cc//cc:action_names.bzl", "ACTION_NAMES", "C_COMPILE_ACTION_NAME")
load("@bazel_skylib//lib:shell.bzl", "shell")

# TODO(drewmacrae) this should be in rules_cc
# pending resolution of https://github.com/bazelbuild/rules_cc/issues/75
load("//rules:bugfix.bzl", "find_cc_toolchain")
load(
    "//rules:cc_side_outputs.bzl",
    "AsmSideProductInfo",
    "LlSideProductInfo",
    "PreProcSideProductInfo",
    "cc_asm_aspect",
    "cc_llvm_aspect",
    "cc_preprocess_aspect",
)
load(
    "//rules:rv.bzl",
    "rv_rule",
    _OPENTITAN_CPU = "OPENTITAN_CPU",
    _OPENTITAN_PLATFORM = "OPENTITAN_PLATFORM",
    _opentitan_transition = "opentitan_transition",
)
load("//rules:autogen.bzl", "OtpImageInfo")
load("//sw/device/lib/arch:device.bzl", "DeviceInfo")

"""Rules to build OpenTitan for the RiscV target"""

# Re-exports of names from transition.bzl; many files in the repo use opentitan.bzl
# to get to them.
OPENTITAN_CPU = _OPENTITAN_CPU
OPENTITAN_PLATFORM = _OPENTITAN_PLATFORM

def objcopy(actions, cc_toolchain, input, output, format = "binary"):
    """
    Creates an action that objcopies `input` to `output`, converting it into
    the desired format.
    """
    return actions.run(
        outputs = [output],
        inputs = [input],
        tools = [cc_toolchain.all_files],
        arguments = [
            "--output-target",
            format,
            input.path,
            output.path,
        ],
        executable = cc_toolchain.objcopy_executable,
    )

def vmemcopy(actions, cc_toolchain, input, output, word_size = 64):
    """
    Creates an action that converts `input` into a vmem file `output`.
    """
    return actions.run(
        outputs = [output],
        inputs = [input],
        arguments = [
            input.path,
            "--binary",
            # Reverse the endianness of every word.
            "--offset",
            "0x0",
            "--byte-swap",
            str(word_size // 8),
            # Pad to word alignment.
            "--fill",
            "0xff",
            "-within",
            input.path,
            "-binary",
            "-range-pad",
            str(word_size // 8),
            # Output a VMEM file with specified word size
            "--output",
            output.path,
            "--vmem",
            str(word_size),
        ],
        # This this executable is expected to be installed (as required by the
        # srecord package in apt-requirements.txt).
        executable = "srec_cat",
    )

def scramble_vmem(actions, input, output, scrambler):
    """
    Creates an action that scrambles `input` into `output`.
    """
    return actions.run(
        outputs = [output],
        inputs = [input],
        tools = [scrambler],
        arguments = [input.path, output.path],
        executable = scrambler.path,
    )

OtRomInfo = provider(
    "Files generated by a ROM binary rule.",
    fields = ["device", "binary", "scrambled"],
)
OtFlashInfo = provider(
    "Files generated by a flash binary rule.",
    fields = ["device", "binary", "vmem", "scrambled", "signed"],
)
DvInfo = provider(
    "Files needed for running DV tests.",
    fields = ["logs_db", "rodata", "frames_bin", "frames_vmem"],
)

def _opentitan_binary_impl(ctx):
    cc_toolchain = find_cc_toolchain(ctx)
    feature_configuration = cc_common.configure_features(
        ctx = ctx,
        cc_toolchain = cc_toolchain,
        requested_features = ctx.features,
        unsupported_features = ctx.disabled_features,
    )

    infos = []
    outputs = []
    side_outputs = sorted(ctx.attr.main[PreProcSideProductInfo].files.to_list() +
                          ctx.attr.main[AsmSideProductInfo].files.to_list() +
                          ctx.attr.main[LlSideProductInfo].files.to_list())

    # First, link the actual binary we need by comining the general
    # objects and the per-device objects.
    linkmap = ctx.actions.declare_file("{}.ldmap".format(ctx.attr.name))
    side_outputs.append(linkmap)
    exe = cc_common.link(
        name = ctx.attr.name,
        actions = ctx.actions,
        feature_configuration = feature_configuration,
        cc_toolchain = cc_toolchain,
        linking_contexts = [
            # Our main "binary", which will just be a cc_library that does the
            # heavy lifting of constructing a CcInfo.
            ctx.attr.main[CcInfo].linking_context,
            # The implementation of device.h, which is linked as late as possible.
            ctx.attr.device[DeviceInfo].device_impl[CcInfo].linking_context,
        ],
        user_link_flags = [
            "-Wl,-Map=" + linkmap.path,
            "-nostartfiles",
            "-nostdlib",
        ],
        additional_outputs = [linkmap],
    ).executable

    # Next, transform the ELF file and generate the correspionding binary image.
    elf = ctx.actions.declare_file("{}.elf".format(ctx.attr.name))
    outputs.append(elf)
    objcopy(ctx.actions, cc_toolchain, exe, elf, "elf32-little")

    binary_image = ctx.actions.declare_file("{}.bin".format(ctx.attr.name))
    outputs.append(binary_image)
    objcopy(ctx.actions, cc_toolchain, exe, binary_image)

    # Generate a disasembly for the ELF file.
    disassembly = ctx.actions.declare_file("{}.elf.s".format(ctx.attr.name))
    side_outputs.append(disassembly)
    ctx.actions.run_shell(
        tools = [
            ctx.file._tab_cleanup_script,
            cc_toolchain.all_files,
        ],
        outputs = [disassembly],
        inputs = [exe],
        arguments = [
            cc_toolchain.objdump_executable,
            exe.path,
            ctx.executable._tab_cleanup_script.path,
            disassembly.path,
        ],
        command = "$1 --disassemble --headers --line-numbers --source $2 | $3 > $4",
    )

    # If this is a "DV" device, we need to emit additional information in the form of
    # the logs database and pre-built bootstrapping info.
    if ctx.attr.device[DeviceInfo].is_dv:
        logs_db = ctx.actions.declare_file("{}.logs.txt".format(ctx.attr.name))
        rodata = ctx.actions.declare_file("{}.rodata.txt".format(ctx.attr.name))
        frames_bin = ctx.actions.declare_file("{}.frames.bin".format(ctx.attr.name))
        frames_vmem = ctx.actions.declare_file("{}.frames.vmem".format(ctx.attr.name))
        outputs += [logs_db, rodata, frames_vmem, frames_vmem]
        infos.append(DvInfo(
            logs_db = logs_db,
            rodata = rodata,
            frames_bin = frames_bin,
            frames_vmem = frames_vmem,
        ))

        ctx.actions.run(
            outputs = [logs_db, rodata],
            inputs = [elf],
            tools = [ctx.executable._dv_logs_extractor],
            arguments = [
                "--elf-file",
                elf.path,
                "--rodata-sections",
                ".rodata",
                "--logs-fields-section",
                ".logs.fields",
                "--name",
                ctx.attr.name,
                "--outdir",
                logs_db.dirname,
            ],
            executable = ctx.executable._dv_logs_extractor,
        )

        ctx.actions.run(
            outputs = [frames_bin],
            inputs = [binary_image],
            tools = [ctx.executable._spiflash],
            arguments = [
                "--input",
                binary_image.path,
                "--dump-frames",
                frames_bin.path,
            ],
            executable = ctx.executable._spiflash,
        )

        # Bootstrap VMEM image uses 32-bit words
        vmemcopy(ctx.actions, cc_toolchain, frames_bin, frames_vmem, word_size = 32)

    if ctx.attr.kind == "rom":
        scrambled = ctx.actions.declare_file("{}.scr.39.vmem".format(ctx.attr.name))
        outputs.append(scrambled)
        infos.append(OtRomInfo(
            device = ctx.attr.device,
            binary = binary_image,
            scrambled = scrambled,
        ))
        ctx.actions.run(
            outputs = [scrambled],
            inputs = [
                elf,
                ctx.file._rom_scramble_config,
            ],
            tools = [ctx.executable._rom_scrambler],
            arguments = [
                ctx.file._rom_scramble_config.path,
                elf.path,
                scrambled.path,
            ],
            executable = ctx.executable._rom_scrambler.path,
        )
    elif ctx.attr.kind == "flash":
        vmem = ctx.actions.declare_file("{}.vmem".format(ctx.attr.name))
        scrambled = ctx.actions.declare_file("{}.scr.vmem".format(ctx.attr.name))
        outputs += [vmem, scrambled]
        vmemcopy(ctx.actions, cc_toolchain, binary_image, vmem)
        scramble_vmem(ctx.actions, vmem, scrambled, ctx.executable._flash_scrambler)

        signed = {}
        for key in ctx.attr.signing_keys:
            signed_image = ctx.actions.declare_file("{}.{}.signed.bin".format(
                ctx.attr.name,
                key.label.name,
            ))
            signed_vmem = ctx.actions.declare_file("{}.{}.signed.vmem".format(
                ctx.attr.name,
                key.label.name,
            ))
            signed_scrambled = ctx.actions.declare_file("{}.{}.signed.scr.vmem".format(
                ctx.attr.name,
                key.label.name,
            ))
            outputs += [signed_image, signed_vmem, signed_scrambled]
            signed[str(key.label)] = OtFlashInfo(
                device = ctx.attr.device,
                binary = signed_image,
                vmem = signed_vmem,
                scrambled = signed_scrambled,
                signed = {},
            )
            outputs.append(signed_image)

            key_file = key[DefaultInfo].files.to_list()[0]
            ctx.actions.run(
                outputs = [signed_image],
                inputs = [binary_image, elf, key_file],
                tools = [ctx.executable._signer],
                arguments = [
                    "rom_ext",
                    binary_image.path,
                    key_file.path,
                    elf.path,
                    signed_image.path,
                ],
                executable = ctx.executable._signer.path,
            )

            vmemcopy(ctx.actions, cc_toolchain, binary_image, signed_vmem)
            scramble_vmem(ctx.actions, signed_vmem, signed_scrambled, ctx.executable._flash_scrambler)

        infos.append(OtFlashInfo(
            device = ctx.attr.device,
            binary = binary_image,
            vmem = vmem,
            scrambled = scrambled,
            signed = signed,
        ))

    else:
        fail("kind must be one of `rom` or `flash`")

    return infos + [DefaultInfo(
        files = depset(side_outputs + outputs),
        runfiles = ctx.runfiles(side_outputs + outputs),
    )]

_OPENTITAN_BINARY_KEYS = [
    "main",
    "kind",
    "signing_keys",
    "platform",
]

opentitan_device_binary = rv_rule(
    implementation = _opentitan_binary_impl,
    attrs = {
        "main": attr.label(
            mandatory = True,
            providers = [CcInfo],
            aspects = [
                cc_preprocess_aspect,
                cc_asm_aspect,
                cc_llvm_aspect,
            ],
        ),
        "device": attr.label(
            mandatory = True,
            providers = [DeviceInfo],
        ),
        "kind": attr.string(
            doc = "The type of binary: `flash` or `rom`",
            default = "flash",
        ),
        "signing_keys": attr.label_list(
            doc = "Keys to use to generate signed binaries.",
            default = [],
            allow_files = True,
        ),
        "platform": attr.string(default = OPENTITAN_PLATFORM),
        "_cc_toolchain": attr.label(
            default = Label("@bazel_tools//tools/cpp:current_cc_toolchain"),
        ),
        "_tab_cleanup_script": attr.label(
            allow_single_file = True,
            default = Label("//rules/scripts:expand_tabs.sh"),
            cfg = "host",
            executable = True,
        ),
        "_dv_logs_extractor": attr.label(
            default = Label("//util/device_sw_utils:extract_sw_logs_db"),
            cfg = "host",
            executable = True,
        ),
        "_spiflash": attr.label(
            default = "//sw/host/spiflash",
            cfg = "host",
            executable = True,
        ),
        "_rom_scrambler": attr.label(
            default = "//hw/ip/rom_ctrl/util:scramble_image.py",
            allow_single_file = True,
            cfg = "host",
            executable = True,
        ),
        "_rom_scramble_config": attr.label(
            default = "//hw/top_earlgrey/data:autogen/top_earlgrey.gen.hjson",
            allow_single_file = True,
        ),
        "_flash_scrambler": attr.label(
            default = "//util/design:gen-flash-img.py",
            allow_single_file = True,
            cfg = "host",
            executable = True,
        ),
        "_signer": attr.label(
            default = "//sw/host/rom_ext_image_tools/signer:rom_ext_signer",
            cfg = "host",
            executable = True,
        ),
    },
    toolchains = ["@rules_cc//cc:toolchain_type"],
    incompatible_use_toolchain_transition = True,
    fragments = ["cpp"],
    host_fragments = ["cpp"],
)

OtBinarySetInfo = provider(fields = ["binaries"])

def _opentitan_binary_set_impl(ctx):
    binaries = {}
    for binary in ctx.attr.binaries:
        if OtRomInfo in binary:
            device = binary[OtRomInfo].device
        else:
            device = binary[OtFlashInfo].device
        binaries[str(device.label)] = binary

    return [
        DefaultInfo(
            files = depset(transitive = [
                dep[DefaultInfo].files
                for dep in ctx.attr.binaries
            ]),
            runfiles = ctx.runfiles(transitive_files = depset(transitive = [
                dep[DefaultInfo].default_runfiles.files
                for dep in ctx.attr.binaries
            ])),
        ),
        OtBinarySetInfo(binaries = binaries),
    ]

opentitan_device_binary_set = rv_rule(
    implementation = _opentitan_binary_set_impl,
    attrs = {
        "binaries": attr.label_list(
            mandatory = True,
            providers = [[OtFlashInfo], [OtRomInfo]],
        ),
    },
)

def _format_list(list1, **kwargs):
    """Concatenate and format list items.

    This is used to prepare substitutions in user-supplied args to the
    various test invocations (ie: the location of flash).
    Args:
        @param list1: A list of items to prepend to the list item from datadict.
        @param **kwargs: Values to pass to the format function.
    Returns:
        list[str]
    """
    return [x.format(**kwargs) for x in list1]

def _file_or_defaultinfo(xs):
    deps = []
    for x in xs:
        if not x:
            pass
        elif type(x) == "File":
            deps.append(depset([x]))
        else:
            deps.append(x[DefaultInfo].default_runfiles.files)
    return deps

def _opentitan_test_impl(ctx):
    binary = ctx.attr.binary
    if OtRomInfo in binary:
        binary_info = binary[OtRomInfo]
        is_rom = True
    else:
        binary_info = binary[OtFlashInfo]
        is_rom = False

    device = binary_info.device

    runfiles = []

    if not is_rom and ctx.attr.signed_with != "":
        binary_info = binary_info.signed[ctx.attr.signed_with]

    if device[DeviceInfo].is_dv and ctx.attr.dv_bootstrap:
        # If the (flash) test image is to be loaded via bootstrap in the DV
        # simulation environment, then we need to use a special VMEM image
        # that has been split into SPI flash frames. Currently, signed
        # images loaded via bootstrap in DV sim are not supported.
        # TODO: support signed bootstap images in DV sim.
        if ctx.attr.signed_with != "":
            fail("A signed test cannot be bootstrapped in DV sim.")
        flash = binary[DvInfo].frames_vmem
    elif device[DeviceInfo].uses_vmem:
        flash = binary_info.scrambled
    else:
        flash = binary_info.binary
    runfiles.append(flash)

    rom_info = ctx.attr.rom
    if is_rom:
        rom_info = binary_info
    elif OtBinarySetInfo in rom_info:
        rom_info = rom_info[OtBinarySetInfo].binaries[str(device.label)][OtRomInfo]
    else:
        rom_info = rom_info[OtRomInfo]

    if device[DeviceInfo].uses_vmem:
        rom = rom_info.scrambled
    else:
        rom = rom_info.binary
    runfiles.append(rom)

    otp_info = device[DeviceInfo].otp
    if ctx.attr.otp:
        otp_info = ctx.attr.otp
    otp = otp_info[OtpImageInfo].image
    runfiles.append(otp)

    dvsim_config = device[DeviceInfo].dvsim_config
    if ctx.file.dvsim_config:
        dvsim_config = ctx.file.dvsim_config
    if dvsim_config:
        runfiles.append(dvsim_config)

    data_runfiles = depset(transitive = [
        target.files
        for target in [device[DeviceInfo].runner, ctx.attr.binary] + device[DeviceInfo].data
    ])
    runfiles = ctx.runfiles(files = runfiles, transitive_files = data_runfiles)

    args = list(device[DeviceInfo].required_args)
    if len(ctx.attr.runner_args) != 0:
        args += ctx.attrs.runner_args
    else:
        args += device[DeviceInfo].default_args

    # Concatenate args / data passed into the opentitan_functest macro
    # with args / data from device-specific params.
    # TODO(lowRISC/opentitan:#11779): remove this concatenation action
    concat_args = _format_list(
        args,
        name = ctx.attr.name,
        flash = flash.short_path,
        otp = otp.short_path,
        rom = rom.short_path,
        dvsim_config = dvsim_config,
    )

    runfiles = runfiles.merge_all([
        target[DefaultInfo].default_runfiles
        for target in [device[DeviceInfo].runner, ctx.attr.binary] + device[DeviceInfo].data
    ])

    runner = device[DeviceInfo].runner[DefaultInfo].files_to_run.executable
    cmd_line = runner.short_path
    for arg in concat_args:
        cmd_line += " \\\n  " + shell.quote(arg)

    exe = ctx.actions.declare_file("{}.sh".format(ctx.attr.name))
    ctx.actions.write(
        output = exe,
        is_executable = True,
        content = "#!/bin/bash\nset -e\ncat $0\n{}".format(cmd_line),
    )

    return [DefaultInfo(
        executable = exe,
        runfiles = runfiles,
    )]

_OPENTITAN_TEST_KEYS = [
    "timeout",
    "tags",
    "rom",
    "otp",
    "runner_args",
    "signed_with",
    "dv_bootstrap",
    "dvsim_config",
]

opentitan_device_test = rv_rule(
    implementation = _opentitan_test_impl,
    test = True,
    attrs = {
        "binary": attr.label(
            doc = "The binary to test, which may be either a flash binary or a ROM binary.",
            mandatory = True,
        ),
        "rom": attr.label(
            doc = "The ROM to use for executing this test, for flash tests.",
            default = Label("//sw/device/lib/testing/test_rom:test_rom2"),
        ),
        "otp": attr.label(
            doc = "The OTP image to use if the device-specific default is not desired.",
            default = None,
        ),
        "runner_args": attr.string_list(
            doc = "Arguments to pass to the test runner, overriding the overrideable arguments.",
            default = [],
        ),
        "dvsim_config": attr.label(
            doc = "The dvsim config to use if the device-specific default is not desired.",
            allow_single_file = True,
            default = None,
        ),
        "signed_with": attr.string(),
        "dv_bootstrap": attr.bool(),
    },
)

def opentitan_binary(
        name,
        devices = [
            "//sw/device/lib/arch:sim_verilator",
            "//sw/device/lib/arch:fpga_cw310",
        ],
        per_device = {},
        **kwargs):
    targets = []
    for device in devices:
        ot_args = {}
        cc_args = dict(kwargs)
        cc_args.update(per_device.get(device, {}))

        for k in cc_args.keys():
            if k in _OPENTITAN_BINARY_KEYS:
                ot_args[k] = cc_args.pop(k)

        if type(device) != Label:
            device = Label(device)

        prog_name = "{}_{}_main".format(device.name, name)
        bin_name = "{}_{}".format(device.name, name)
        targets.append(bin_name)

        native.cc_library(
            name = prog_name,
            alwayslink = True,
            **cc_args
        )

        opentitan_device_binary(
            name = bin_name,
            main = ":" + prog_name,
            device = device,
            **ot_args
        )

    opentitan_device_binary_set(
        name = name,
        binaries = targets,
    )

def opentitan_test(
        name,
        devices = [
            "//sw/device/lib/arch:sim_verilator",
            "//sw/device/lib/arch:sim_dv",
            "//sw/device/lib/arch:fpga_cw310",
        ],
        per_device = {},
        **kwargs):
    per_device_test_opts = {}
    for dev, opts in per_device.items():
        test_opts = {}
        for k in opts.keys():
            if k in _OPENTITAN_TEST_KEYS:
                test_opts[k] = opts.pop(k)
        per_device_test_opts[dev] = test_opts

    ot_args = {}
    for k in kwargs.keys():
        if k in _OPENTITAN_TEST_KEYS:
            ot_args[k] = kwargs.pop(k)

    opentitan_binary(
        name = name + "_prog",
        devices = devices,
        per_device = per_device,
        **kwargs
    )

    targets = []
    for device in devices:
        if type(device) != Label:
            device = Label(device)

        bin_name = "{}_{}_prog".format(device.name, name)
        test_name = "{}_{}".format(device.name, name)
        targets.append(test_name)

        kwargs = dict(ot_args)
        kwargs.update(per_device_test_opts.get(device, {}))
        kwargs["tags"] = kwargs.pop("tags", []) + [device.name]

        opentitan_device_test(
            name = test_name,
            binary = ":" + bin_name,
            **kwargs
        )

    native.test_suite(
        name = name,
        tests = targets,
    )
