# Copyright lowRISC contributors (OpenTitan project).
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

"""Rules to describe OpenTitan HW"""

def opentitan_ip(name, hjson):
    """
    Return a structure describing an IP. This can be given to opentitan_top.

    Arguments:
    - name: name of ip in lower case.
    - hjson: label of the IP's hjson path, you MUST NOT use a relative label.
    """
    return struct(
        name = name,
        hjson = hjson,
    )

def opentitan_top(name, hjson, top_lib, ips):
    """
    Return a structure describing a top.

    Arguments:
    - name: name of top in lower case.
    - hjson: label of the top's hjson path (generated by topgen), you MUST NOT
             use a relative label.
    - top_lib: same but for the top's library
    - ips: array of ips, the entries must be opentitan_ip().
    """
    return struct(
        name = name,
        hjson = hjson,
        top_lib = top_lib,
        ips = ips,
    )

OpenTitanTopInfo = provider(
    doc = "Information about an OpenTitan top",
    fields = {
        "name": "Name of this top (string)",
        "hjson": "topgen-generated HJSON file for this top (file)",
        "ip_hjson": "dictionary of IPs HSJON files (dict: string => file)",
    },
)

def _select_top(ctx):
    all_tops = json.decode(ctx.attr.all_tops)
    the_top = [top for top in all_tops if top["name"] == ctx.attr.top]
    if len(the_top) == 0:
        fail("Not top named {} found!".format(ctx.attr.top))
    if len(the_top) > 1:
        fail("Several tops named {} found!".format(ctx.attr.top))

    toplvl_hjson = None
    ip_hjson = {}

    for (hjson, info) in ctx.attr.all_hjson.items():
        # We cannot use ctx.files because it is only a list and not a dict.
        # Therefor extract the file from the Target.
        hjson = hjson[DefaultInfo].files.to_list()[0]
        info = json.decode(info)
        if ctx.attr.top not in info["tops"]:
            continue
        if "ip" in info:
            ip_hjson[info["ip"]] = hjson
        else:
            toplvl_hjson = hjson

    return [
        OpenTitanTopInfo(
            name = ctx.attr.top,
            hjson = toplvl_hjson,
            ip_hjson = ip_hjson,
        ),
    ]

select_top_rule = rule(
    implementation = _select_top,
    attrs = {
        "all_tops": attr.string(mandatory = True, doc = "json.encode()-ed list of tops"),
        "all_hjson": attr.label_keyed_string_dict(allow_files = True, doc = "mapping from hjson files to tops"),
        "top": attr.string(mandatory = True, doc = "Which top to select"),
    },
)

def select_top(name, all_tops, top):
    """
    Create a target that provides an OpenTitanTopInfo corresponding to the
    requested top.

    - all_tops: list of tops (created by opentitan_top).
    - top: name of the top to use.
    """

    # Although we already pass the top description to the rule, those are just strings.
    # We also need to let bazel know that we depend on the hjson files which is why
    # we also pass them in a structured way.
    all_hjson = {}
    for _top in all_tops:
        all_hjson[_top.hjson] = json.encode({"tops": [_top.name]})
        for ip in _top.ips:
            prev = json.decode(all_hjson.get(ip.hjson, "{}"))
            prev["ip"] = ip.name
            prev["tops"] = prev.get("tops", []) + [_top.name]
            all_hjson[ip.hjson] = json.encode(prev)

    select_top_rule(
        name = name,
        all_tops = json.encode(all_tops),
        all_hjson = all_hjson,
        top = top,
    )

def select_top_lib(name, all_tops, top):
    """
    Create an alias to the top library.
    """
    libs = [_top.top_lib for _top in all_tops if _top.name == top]
    if len(libs) == 0:
        fail("not top found with name {}".format(top))

    native.alias(
        name = name,
        actual = libs[0],
    )
