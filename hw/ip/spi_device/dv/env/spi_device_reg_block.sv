// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// UVM Registers auto-generated by `reggen` containing data structure
// Do Not Edit directly

// Forward declare all register/memory/block classes
typedef class spi_device_reg_intr_state;
typedef class spi_device_reg_intr_enable;
typedef class spi_device_reg_intr_test;
typedef class spi_device_reg_control;
typedef class spi_device_reg_cfg;
typedef class spi_device_reg_fifo_level;
typedef class spi_device_reg_async_fifo_level;
typedef class spi_device_reg_status;
typedef class spi_device_reg_rxf_ptr;
typedef class spi_device_reg_txf_ptr;
typedef class spi_device_reg_rxf_addr;
typedef class spi_device_reg_txf_addr;
typedef class spi_device_mem_buffer;
typedef class spi_device_reg_block;

// Block: spi_device
// Class: spi_device_reg_intr_state
class spi_device_reg_intr_state extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxne;
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txe;
  rand dv_base_reg_field txf;
  rand dv_base_reg_field txlvl;
  rand dv_base_reg_field rxerr;

  `uvm_object_utils(spi_device_reg_intr_state)

  function new(string       name = "spi_device_reg_intr_state",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxne = dv_base_reg_field::type_id::create("rxne");
    rxne.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txe = dv_base_reg_field::type_id::create("txe");
    txe.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txf = dv_base_reg_field::type_id::create("txf");
    txf.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxerr = dv_base_reg_field::type_id::create("rxerr");
    rxerr.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_intr_state

// Class: spi_device_reg_intr_enable
class spi_device_reg_intr_enable extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxne;
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txe;
  rand dv_base_reg_field txf;
  rand dv_base_reg_field txlvl;
  rand dv_base_reg_field rxerr;

  `uvm_object_utils(spi_device_reg_intr_enable)

  function new(string       name = "spi_device_reg_intr_enable",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxne = dv_base_reg_field::type_id::create("rxne");
    rxne.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txe = dv_base_reg_field::type_id::create("txe");
    txe.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txf = dv_base_reg_field::type_id::create("txf");
    txf.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxerr = dv_base_reg_field::type_id::create("rxerr");
    rxerr.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_intr_enable

// Class: spi_device_reg_intr_test
class spi_device_reg_intr_test extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxne;
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txe;
  rand dv_base_reg_field txf;
  rand dv_base_reg_field txlvl;
  rand dv_base_reg_field rxerr;

  `uvm_object_utils(spi_device_reg_intr_test)

  function new(string       name = "spi_device_reg_intr_test",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxne = dv_base_reg_field::type_id::create("rxne");
    rxne.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txe = dv_base_reg_field::type_id::create("txe");
    txe.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txf = dv_base_reg_field::type_id::create("txf");
    txf.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxerr = dv_base_reg_field::type_id::create("rxerr");
    rxerr.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_intr_test

// Class: spi_device_reg_control
class spi_device_reg_control extends dv_base_reg;
  // fields
  rand dv_base_reg_field abort;
  rand dv_base_reg_field mode;
  rand dv_base_reg_field rst_txfifo;
  rand dv_base_reg_field rst_rxfifo;

  `uvm_object_utils(spi_device_reg_control)

  function new(string       name = "spi_device_reg_control",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    abort = dv_base_reg_field::type_id::create("abort");
    abort.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    mode = dv_base_reg_field::type_id::create("mode");
    mode.configure(
      .parent(this),
      .size(2),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rst_txfifo = dv_base_reg_field::type_id::create("rst_txfifo");
    rst_txfifo.configure(
      .parent(this),
      .size(1),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rst_rxfifo = dv_base_reg_field::type_id::create("rst_rxfifo");
    rst_rxfifo.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_control

// Class: spi_device_reg_cfg
class spi_device_reg_cfg extends dv_base_reg;
  // fields
  rand dv_base_reg_field cpol;
  rand dv_base_reg_field cpha;
  rand dv_base_reg_field tx_order;
  rand dv_base_reg_field rx_order;
  rand dv_base_reg_field timer_v;

  `uvm_object_utils(spi_device_reg_cfg)

  function new(string       name = "spi_device_reg_cfg",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    cpol = dv_base_reg_field::type_id::create("cpol");
    cpol.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    cpha = dv_base_reg_field::type_id::create("cpha");
    cpha.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    tx_order = dv_base_reg_field::type_id::create("tx_order");
    tx_order.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_order = dv_base_reg_field::type_id::create("rx_order");
    rx_order.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    timer_v = dv_base_reg_field::type_id::create("timer_v");
    timer_v.configure(
      .parent(this),
      .size(8),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(127),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_cfg

// Class: spi_device_reg_fifo_level
class spi_device_reg_fifo_level extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txlvl;

  `uvm_object_utils(spi_device_reg_fifo_level)

  function new(string       name = "spi_device_reg_fifo_level",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(128),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_fifo_level

// Class: spi_device_reg_async_fifo_level
class spi_device_reg_async_fifo_level extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txlvl;

  `uvm_object_utils(spi_device_reg_async_fifo_level)

  function new(string       name = "spi_device_reg_async_fifo_level",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(8),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(8),
      .lsb_pos(16),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_async_fifo_level

// Class: spi_device_reg_status
class spi_device_reg_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxf_full;
  rand dv_base_reg_field rxf_empty;
  rand dv_base_reg_field txf_full;
  rand dv_base_reg_field txf_empty;
  rand dv_base_reg_field abort_done;

  `uvm_object_utils(spi_device_reg_status)

  function new(string       name = "spi_device_reg_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxf_full = dv_base_reg_field::type_id::create("rxf_full");
    rxf_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxf_empty = dv_base_reg_field::type_id::create("rxf_empty");
    rxf_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txf_full = dv_base_reg_field::type_id::create("txf_full");
    txf_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txf_empty = dv_base_reg_field::type_id::create("txf_empty");
    txf_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    abort_done = dv_base_reg_field::type_id::create("abort_done");
    abort_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_status

// Class: spi_device_reg_rxf_ptr
class spi_device_reg_rxf_ptr extends dv_base_reg;
  // fields
  rand dv_base_reg_field rptr;
  rand dv_base_reg_field wptr;

  `uvm_object_utils(spi_device_reg_rxf_ptr)

  function new(string       name = "spi_device_reg_rxf_ptr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rptr = dv_base_reg_field::type_id::create("rptr");
    rptr.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    wptr = dv_base_reg_field::type_id::create("wptr");
    wptr.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_rxf_ptr

// Class: spi_device_reg_txf_ptr
class spi_device_reg_txf_ptr extends dv_base_reg;
  // fields
  rand dv_base_reg_field rptr;
  rand dv_base_reg_field wptr;

  `uvm_object_utils(spi_device_reg_txf_ptr)

  function new(string       name = "spi_device_reg_txf_ptr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rptr = dv_base_reg_field::type_id::create("rptr");
    rptr.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    wptr = dv_base_reg_field::type_id::create("wptr");
    wptr.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_txf_ptr

// Class: spi_device_reg_rxf_addr
class spi_device_reg_rxf_addr extends dv_base_reg;
  // fields
  rand dv_base_reg_field base;
  rand dv_base_reg_field limit;

  `uvm_object_utils(spi_device_reg_rxf_addr)

  function new(string       name = "spi_device_reg_rxf_addr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    base = dv_base_reg_field::type_id::create("base");
    base.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    limit = dv_base_reg_field::type_id::create("limit");
    limit.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(508),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_rxf_addr

// Class: spi_device_reg_txf_addr
class spi_device_reg_txf_addr extends dv_base_reg;
  // fields
  rand dv_base_reg_field base;
  rand dv_base_reg_field limit;

  `uvm_object_utils(spi_device_reg_txf_addr)

  function new(string       name = "spi_device_reg_txf_addr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    base = dv_base_reg_field::type_id::create("base");
    base.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(512),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    limit = dv_base_reg_field::type_id::create("limit");
    limit.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(1020),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_txf_addr

// Class: spi_device_mem_buffer
class spi_device_mem_buffer extends dv_base_mem;

  `uvm_object_utils(spi_device_mem_buffer)

  function new(string           name = "spi_device_mem_buffer",
               longint unsigned size = 512,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"RW"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : spi_device_mem_buffer

// Class: spi_device_reg_block
class spi_device_reg_block extends dv_base_reg_block;
  // registers
  rand spi_device_reg_intr_state intr_state;
  rand spi_device_reg_intr_enable intr_enable;
  rand spi_device_reg_intr_test intr_test;
  rand spi_device_reg_control control;
  rand spi_device_reg_cfg cfg;
  rand spi_device_reg_fifo_level fifo_level;
  rand spi_device_reg_async_fifo_level async_fifo_level;
  rand spi_device_reg_status status;
  rand spi_device_reg_rxf_ptr rxf_ptr;
  rand spi_device_reg_txf_ptr txf_ptr;
  rand spi_device_reg_rxf_addr rxf_addr;
  rand spi_device_reg_txf_addr txf_addr;
  // memories
  rand spi_device_mem_buffer buffer;

  `uvm_object_utils(spi_device_reg_block)

  function new(string name = "spi_device_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    intr_state = spi_device_reg_intr_state::type_id::create("intr_state");
    intr_state.configure(.blk_parent(this));
    intr_state.build();
    default_map.add_reg(.rg(intr_state),
                        .offset(32'h0),
                        .rights("RW"));
    intr_enable = spi_device_reg_intr_enable::type_id::create("intr_enable");
    intr_enable.configure(.blk_parent(this));
    intr_enable.build();
    default_map.add_reg(.rg(intr_enable),
                        .offset(32'h4),
                        .rights("RW"));
    intr_test = spi_device_reg_intr_test::type_id::create("intr_test");
    intr_test.configure(.blk_parent(this));
    intr_test.build();
    default_map.add_reg(.rg(intr_test),
                        .offset(32'h8),
                        .rights("WO"));
    control = spi_device_reg_control::type_id::create("control");
    control.configure(.blk_parent(this));
    control.build();
    default_map.add_reg(.rg(control),
                        .offset(32'hc),
                        .rights("RW"));
    cfg = spi_device_reg_cfg::type_id::create("cfg");
    cfg.configure(.blk_parent(this));
    cfg.build();
    default_map.add_reg(.rg(cfg),
                        .offset(32'h10),
                        .rights("RW"));
    fifo_level = spi_device_reg_fifo_level::type_id::create("fifo_level");
    fifo_level.configure(.blk_parent(this));
    fifo_level.build();
    default_map.add_reg(.rg(fifo_level),
                        .offset(32'h14),
                        .rights("RW"));
    async_fifo_level = spi_device_reg_async_fifo_level::type_id::create("async_fifo_level");
    async_fifo_level.configure(.blk_parent(this));
    async_fifo_level.build();
    default_map.add_reg(.rg(async_fifo_level),
                        .offset(32'h18),
                        .rights("RO"));
    status = spi_device_reg_status::type_id::create("status");
    status.configure(.blk_parent(this));
    status.build();
    default_map.add_reg(.rg(status),
                        .offset(32'h1c),
                        .rights("RO"));
    rxf_ptr = spi_device_reg_rxf_ptr::type_id::create("rxf_ptr");
    rxf_ptr.configure(.blk_parent(this));
    rxf_ptr.build();
    default_map.add_reg(.rg(rxf_ptr),
                        .offset(32'h20),
                        .rights("RW"));
    txf_ptr = spi_device_reg_txf_ptr::type_id::create("txf_ptr");
    txf_ptr.configure(.blk_parent(this));
    txf_ptr.build();
    default_map.add_reg(.rg(txf_ptr),
                        .offset(32'h24),
                        .rights("RW"));
    rxf_addr = spi_device_reg_rxf_addr::type_id::create("rxf_addr");
    rxf_addr.configure(.blk_parent(this));
    rxf_addr.build();
    default_map.add_reg(.rg(rxf_addr),
                        .offset(32'h28),
                        .rights("RW"));
    txf_addr = spi_device_reg_txf_addr::type_id::create("txf_addr");
    txf_addr.configure(.blk_parent(this));
    txf_addr.build();
    default_map.add_reg(.rg(txf_addr),
                        .offset(32'h2c),
                        .rights("RW"));

    // create memories
    buffer = spi_device_mem_buffer::type_id::create("buffer");
    buffer.configure(.parent(this));
    default_map.add_mem(.mem(buffer),
                        .offset(32'h800),
                        .rights("RW"));
  endfunction : build

endclass : spi_device_reg_block
