// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// UVM Registers auto-generated by `reggen` containing data structure
// Do Not Edit directly

// Forward declare all register/memory/block classes
typedef class aes_reg_key0;
typedef class aes_reg_key1;
typedef class aes_reg_key2;
typedef class aes_reg_key3;
typedef class aes_reg_key4;
typedef class aes_reg_key5;
typedef class aes_reg_key6;
typedef class aes_reg_key7;
typedef class aes_reg_data_in0;
typedef class aes_reg_data_in1;
typedef class aes_reg_data_in2;
typedef class aes_reg_data_in3;
typedef class aes_reg_data_out0;
typedef class aes_reg_data_out1;
typedef class aes_reg_data_out2;
typedef class aes_reg_data_out3;
typedef class aes_reg_ctrl;
typedef class aes_reg_trigger;
typedef class aes_reg_status;
typedef class aes_reg_block;

// Block: aes
// Class: aes_reg_key0
class aes_reg_key0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key0;

  `uvm_object_utils(aes_reg_key0)

  function new(string       name = "aes_reg_key0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key0 = dv_base_reg_field::type_id::create("key0");
    key0.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_key0

// Class: aes_reg_key1
class aes_reg_key1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key1;

  `uvm_object_utils(aes_reg_key1)

  function new(string       name = "aes_reg_key1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key1 = dv_base_reg_field::type_id::create("key1");
    key1.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_key1

// Class: aes_reg_key2
class aes_reg_key2 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key2;

  `uvm_object_utils(aes_reg_key2)

  function new(string       name = "aes_reg_key2",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key2 = dv_base_reg_field::type_id::create("key2");
    key2.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_key2

// Class: aes_reg_key3
class aes_reg_key3 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key3;

  `uvm_object_utils(aes_reg_key3)

  function new(string       name = "aes_reg_key3",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key3 = dv_base_reg_field::type_id::create("key3");
    key3.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_key3

// Class: aes_reg_key4
class aes_reg_key4 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key4;

  `uvm_object_utils(aes_reg_key4)

  function new(string       name = "aes_reg_key4",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key4 = dv_base_reg_field::type_id::create("key4");
    key4.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_key4

// Class: aes_reg_key5
class aes_reg_key5 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key5;

  `uvm_object_utils(aes_reg_key5)

  function new(string       name = "aes_reg_key5",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key5 = dv_base_reg_field::type_id::create("key5");
    key5.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_key5

// Class: aes_reg_key6
class aes_reg_key6 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key6;

  `uvm_object_utils(aes_reg_key6)

  function new(string       name = "aes_reg_key6",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key6 = dv_base_reg_field::type_id::create("key6");
    key6.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_key6

// Class: aes_reg_key7
class aes_reg_key7 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key7;

  `uvm_object_utils(aes_reg_key7)

  function new(string       name = "aes_reg_key7",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key7 = dv_base_reg_field::type_id::create("key7");
    key7.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_key7

// Class: aes_reg_data_in0
class aes_reg_data_in0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field data_in0;

  `uvm_object_utils(aes_reg_data_in0)

  function new(string       name = "aes_reg_data_in0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data_in0 = dv_base_reg_field::type_id::create("data_in0");
    data_in0.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_data_in0

// Class: aes_reg_data_in1
class aes_reg_data_in1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field data_in1;

  `uvm_object_utils(aes_reg_data_in1)

  function new(string       name = "aes_reg_data_in1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data_in1 = dv_base_reg_field::type_id::create("data_in1");
    data_in1.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_data_in1

// Class: aes_reg_data_in2
class aes_reg_data_in2 extends dv_base_reg;
  // fields
  rand dv_base_reg_field data_in2;

  `uvm_object_utils(aes_reg_data_in2)

  function new(string       name = "aes_reg_data_in2",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data_in2 = dv_base_reg_field::type_id::create("data_in2");
    data_in2.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_data_in2

// Class: aes_reg_data_in3
class aes_reg_data_in3 extends dv_base_reg;
  // fields
  rand dv_base_reg_field data_in3;

  `uvm_object_utils(aes_reg_data_in3)

  function new(string       name = "aes_reg_data_in3",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data_in3 = dv_base_reg_field::type_id::create("data_in3");
    data_in3.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_data_in3

// Class: aes_reg_data_out0
class aes_reg_data_out0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field data_out0;

  `uvm_object_utils(aes_reg_data_out0)

  function new(string       name = "aes_reg_data_out0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data_out0 = dv_base_reg_field::type_id::create("data_out0");
    data_out0.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_data_out0

// Class: aes_reg_data_out1
class aes_reg_data_out1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field data_out1;

  `uvm_object_utils(aes_reg_data_out1)

  function new(string       name = "aes_reg_data_out1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data_out1 = dv_base_reg_field::type_id::create("data_out1");
    data_out1.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_data_out1

// Class: aes_reg_data_out2
class aes_reg_data_out2 extends dv_base_reg;
  // fields
  rand dv_base_reg_field data_out2;

  `uvm_object_utils(aes_reg_data_out2)

  function new(string       name = "aes_reg_data_out2",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data_out2 = dv_base_reg_field::type_id::create("data_out2");
    data_out2.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_data_out2

// Class: aes_reg_data_out3
class aes_reg_data_out3 extends dv_base_reg;
  // fields
  rand dv_base_reg_field data_out3;

  `uvm_object_utils(aes_reg_data_out3)

  function new(string       name = "aes_reg_data_out3",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data_out3 = dv_base_reg_field::type_id::create("data_out3");
    data_out3.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_data_out3

// Class: aes_reg_ctrl
class aes_reg_ctrl extends dv_base_reg;
  // fields
  rand dv_base_reg_field mode;
  rand dv_base_reg_field key_len;
  rand dv_base_reg_field manual_start_trigger;
  rand dv_base_reg_field force_data_overwrite;

  `uvm_object_utils(aes_reg_ctrl)

  function new(string       name = "aes_reg_ctrl",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    mode = dv_base_reg_field::type_id::create("mode");
    mode.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    key_len = dv_base_reg_field::type_id::create("key_len");
    key_len.configure(
      .parent(this),
      .size(3),
      .lsb_pos(1),
      .access("RW"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    manual_start_trigger = dv_base_reg_field::type_id::create("manual_start_trigger");
    manual_start_trigger.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    force_data_overwrite = dv_base_reg_field::type_id::create("force_data_overwrite");
    force_data_overwrite.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_ctrl

// Class: aes_reg_trigger
class aes_reg_trigger extends dv_base_reg;
  // fields
  rand dv_base_reg_field start;

  `uvm_object_utils(aes_reg_trigger)

  function new(string       name = "aes_reg_trigger",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    start = dv_base_reg_field::type_id::create("start");
    start.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_trigger

// Class: aes_reg_status
class aes_reg_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field idle;
  rand dv_base_reg_field stall;
  rand dv_base_reg_field output_valid;
  rand dv_base_reg_field input_ready;

  `uvm_object_utils(aes_reg_status)

  function new(string       name = "aes_reg_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    idle = dv_base_reg_field::type_id::create("idle");
    idle.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    stall = dv_base_reg_field::type_id::create("stall");
    stall.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    output_valid = dv_base_reg_field::type_id::create("output_valid");
    output_valid.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    input_ready = dv_base_reg_field::type_id::create("input_ready");
    input_ready.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : aes_reg_status

// Class: aes_reg_block
class aes_reg_block extends dv_base_reg_block;
  // registers
  rand aes_reg_key0 key0;
  rand aes_reg_key1 key1;
  rand aes_reg_key2 key2;
  rand aes_reg_key3 key3;
  rand aes_reg_key4 key4;
  rand aes_reg_key5 key5;
  rand aes_reg_key6 key6;
  rand aes_reg_key7 key7;
  rand aes_reg_data_in0 data_in0;
  rand aes_reg_data_in1 data_in1;
  rand aes_reg_data_in2 data_in2;
  rand aes_reg_data_in3 data_in3;
  rand aes_reg_data_out0 data_out0;
  rand aes_reg_data_out1 data_out1;
  rand aes_reg_data_out2 data_out2;
  rand aes_reg_data_out3 data_out3;
  rand aes_reg_ctrl ctrl;
  rand aes_reg_trigger trigger;
  rand aes_reg_status status;

  `uvm_object_utils(aes_reg_block)

  function new(string name = "aes_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    key0 = aes_reg_key0::type_id::create("key0");
    key0.configure(.blk_parent(this));
    key0.build();
    default_map.add_reg(.rg(key0),
                        .offset(32'h0),
                        .rights("WO"));
    key1 = aes_reg_key1::type_id::create("key1");
    key1.configure(.blk_parent(this));
    key1.build();
    default_map.add_reg(.rg(key1),
                        .offset(32'h4),
                        .rights("WO"));
    key2 = aes_reg_key2::type_id::create("key2");
    key2.configure(.blk_parent(this));
    key2.build();
    default_map.add_reg(.rg(key2),
                        .offset(32'h8),
                        .rights("WO"));
    key3 = aes_reg_key3::type_id::create("key3");
    key3.configure(.blk_parent(this));
    key3.build();
    default_map.add_reg(.rg(key3),
                        .offset(32'hc),
                        .rights("WO"));
    key4 = aes_reg_key4::type_id::create("key4");
    key4.configure(.blk_parent(this));
    key4.build();
    default_map.add_reg(.rg(key4),
                        .offset(32'h10),
                        .rights("WO"));
    key5 = aes_reg_key5::type_id::create("key5");
    key5.configure(.blk_parent(this));
    key5.build();
    default_map.add_reg(.rg(key5),
                        .offset(32'h14),
                        .rights("WO"));
    key6 = aes_reg_key6::type_id::create("key6");
    key6.configure(.blk_parent(this));
    key6.build();
    default_map.add_reg(.rg(key6),
                        .offset(32'h18),
                        .rights("WO"));
    key7 = aes_reg_key7::type_id::create("key7");
    key7.configure(.blk_parent(this));
    key7.build();
    default_map.add_reg(.rg(key7),
                        .offset(32'h1c),
                        .rights("WO"));
    data_in0 = aes_reg_data_in0::type_id::create("data_in0");
    data_in0.configure(.blk_parent(this));
    data_in0.build();
    default_map.add_reg(.rg(data_in0),
                        .offset(32'h20),
                        .rights("WO"));
    data_in1 = aes_reg_data_in1::type_id::create("data_in1");
    data_in1.configure(.blk_parent(this));
    data_in1.build();
    default_map.add_reg(.rg(data_in1),
                        .offset(32'h24),
                        .rights("WO"));
    data_in2 = aes_reg_data_in2::type_id::create("data_in2");
    data_in2.configure(.blk_parent(this));
    data_in2.build();
    default_map.add_reg(.rg(data_in2),
                        .offset(32'h28),
                        .rights("WO"));
    data_in3 = aes_reg_data_in3::type_id::create("data_in3");
    data_in3.configure(.blk_parent(this));
    data_in3.build();
    default_map.add_reg(.rg(data_in3),
                        .offset(32'h2c),
                        .rights("WO"));
    data_out0 = aes_reg_data_out0::type_id::create("data_out0");
    data_out0.configure(.blk_parent(this));
    data_out0.build();
    default_map.add_reg(.rg(data_out0),
                        .offset(32'h30),
                        .rights("RO"));
    data_out1 = aes_reg_data_out1::type_id::create("data_out1");
    data_out1.configure(.blk_parent(this));
    data_out1.build();
    default_map.add_reg(.rg(data_out1),
                        .offset(32'h34),
                        .rights("RO"));
    data_out2 = aes_reg_data_out2::type_id::create("data_out2");
    data_out2.configure(.blk_parent(this));
    data_out2.build();
    default_map.add_reg(.rg(data_out2),
                        .offset(32'h38),
                        .rights("RO"));
    data_out3 = aes_reg_data_out3::type_id::create("data_out3");
    data_out3.configure(.blk_parent(this));
    data_out3.build();
    default_map.add_reg(.rg(data_out3),
                        .offset(32'h3c),
                        .rights("RO"));
    ctrl = aes_reg_ctrl::type_id::create("ctrl");
    ctrl.configure(.blk_parent(this));
    ctrl.build();
    default_map.add_reg(.rg(ctrl),
                        .offset(32'h40),
                        .rights("RW"));
    trigger = aes_reg_trigger::type_id::create("trigger");
    trigger.configure(.blk_parent(this));
    trigger.build();
    default_map.add_reg(.rg(trigger),
                        .offset(32'h44),
                        .rights("RW"));
    status = aes_reg_status::type_id::create("status");
    status.configure(.blk_parent(this));
    status.build();
    default_map.add_reg(.rg(status),
                        .offset(32'h48),
                        .rights("RO"));
  endfunction : build

endclass : aes_reg_block
