// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// UVM Registers auto-generated by `reggen` containing data structure
// Do Not Edit directly

// Forward declare all register/memory/block classes
typedef class pinmux_reg_regen;
typedef class pinmux_reg_periph_insel0;
typedef class pinmux_reg_periph_insel1;
typedef class pinmux_reg_mio_outsel0;
typedef class pinmux_reg_mio_outsel1;
typedef class pinmux_reg_block;

// Block: pinmux
// Class: pinmux_reg_regen
class pinmux_reg_regen extends dv_base_reg;
  // fields
  rand dv_base_reg_field regen;

  `uvm_object_utils(pinmux_reg_regen)

  function new(string       name = "pinmux_reg_regen",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    regen = dv_base_reg_field::type_id::create("regen");
    regen.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : pinmux_reg_regen

// Class: pinmux_reg_periph_insel0
class pinmux_reg_periph_insel0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field in0;
  rand dv_base_reg_field in1;
  rand dv_base_reg_field in2;
  rand dv_base_reg_field in3;
  rand dv_base_reg_field in4;
  rand dv_base_reg_field in5;
  rand dv_base_reg_field in6;
  rand dv_base_reg_field in7;

  `uvm_object_utils(pinmux_reg_periph_insel0)

  function new(string       name = "pinmux_reg_periph_insel0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    in0 = dv_base_reg_field::type_id::create("in0");
    in0.configure(
      .parent(this),
      .size(4),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in1 = dv_base_reg_field::type_id::create("in1");
    in1.configure(
      .parent(this),
      .size(4),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in2 = dv_base_reg_field::type_id::create("in2");
    in2.configure(
      .parent(this),
      .size(4),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in3 = dv_base_reg_field::type_id::create("in3");
    in3.configure(
      .parent(this),
      .size(4),
      .lsb_pos(12),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in4 = dv_base_reg_field::type_id::create("in4");
    in4.configure(
      .parent(this),
      .size(4),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in5 = dv_base_reg_field::type_id::create("in5");
    in5.configure(
      .parent(this),
      .size(4),
      .lsb_pos(20),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in6 = dv_base_reg_field::type_id::create("in6");
    in6.configure(
      .parent(this),
      .size(4),
      .lsb_pos(24),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in7 = dv_base_reg_field::type_id::create("in7");
    in7.configure(
      .parent(this),
      .size(4),
      .lsb_pos(28),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : pinmux_reg_periph_insel0

// Class: pinmux_reg_periph_insel1
class pinmux_reg_periph_insel1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field in8;
  rand dv_base_reg_field in9;
  rand dv_base_reg_field in10;
  rand dv_base_reg_field in11;
  rand dv_base_reg_field in12;
  rand dv_base_reg_field in13;
  rand dv_base_reg_field in14;
  rand dv_base_reg_field in15;

  `uvm_object_utils(pinmux_reg_periph_insel1)

  function new(string       name = "pinmux_reg_periph_insel1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    in8 = dv_base_reg_field::type_id::create("in8");
    in8.configure(
      .parent(this),
      .size(4),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in9 = dv_base_reg_field::type_id::create("in9");
    in9.configure(
      .parent(this),
      .size(4),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in10 = dv_base_reg_field::type_id::create("in10");
    in10.configure(
      .parent(this),
      .size(4),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in11 = dv_base_reg_field::type_id::create("in11");
    in11.configure(
      .parent(this),
      .size(4),
      .lsb_pos(12),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in12 = dv_base_reg_field::type_id::create("in12");
    in12.configure(
      .parent(this),
      .size(4),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in13 = dv_base_reg_field::type_id::create("in13");
    in13.configure(
      .parent(this),
      .size(4),
      .lsb_pos(20),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in14 = dv_base_reg_field::type_id::create("in14");
    in14.configure(
      .parent(this),
      .size(4),
      .lsb_pos(24),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    in15 = dv_base_reg_field::type_id::create("in15");
    in15.configure(
      .parent(this),
      .size(4),
      .lsb_pos(28),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : pinmux_reg_periph_insel1

// Class: pinmux_reg_mio_outsel0
class pinmux_reg_mio_outsel0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field out0;
  rand dv_base_reg_field out1;
  rand dv_base_reg_field out2;
  rand dv_base_reg_field out3;
  rand dv_base_reg_field out4;
  rand dv_base_reg_field out5;

  `uvm_object_utils(pinmux_reg_mio_outsel0)

  function new(string       name = "pinmux_reg_mio_outsel0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    out0 = dv_base_reg_field::type_id::create("out0");
    out0.configure(
      .parent(this),
      .size(5),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(2),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    out1 = dv_base_reg_field::type_id::create("out1");
    out1.configure(
      .parent(this),
      .size(5),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(2),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    out2 = dv_base_reg_field::type_id::create("out2");
    out2.configure(
      .parent(this),
      .size(5),
      .lsb_pos(10),
      .access("RW"),
      .volatile(0),
      .reset(2),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    out3 = dv_base_reg_field::type_id::create("out3");
    out3.configure(
      .parent(this),
      .size(5),
      .lsb_pos(15),
      .access("RW"),
      .volatile(0),
      .reset(2),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    out4 = dv_base_reg_field::type_id::create("out4");
    out4.configure(
      .parent(this),
      .size(5),
      .lsb_pos(20),
      .access("RW"),
      .volatile(0),
      .reset(2),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    out5 = dv_base_reg_field::type_id::create("out5");
    out5.configure(
      .parent(this),
      .size(5),
      .lsb_pos(25),
      .access("RW"),
      .volatile(0),
      .reset(2),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : pinmux_reg_mio_outsel0

// Class: pinmux_reg_mio_outsel1
class pinmux_reg_mio_outsel1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field out6;
  rand dv_base_reg_field out7;

  `uvm_object_utils(pinmux_reg_mio_outsel1)

  function new(string       name = "pinmux_reg_mio_outsel1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    out6 = dv_base_reg_field::type_id::create("out6");
    out6.configure(
      .parent(this),
      .size(5),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(2),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    out7 = dv_base_reg_field::type_id::create("out7");
    out7.configure(
      .parent(this),
      .size(5),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(2),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : pinmux_reg_mio_outsel1

// Class: pinmux_reg_block
class pinmux_reg_block extends dv_base_reg_block;
  // registers
  rand pinmux_reg_regen regen;
  rand pinmux_reg_periph_insel0 periph_insel0;
  rand pinmux_reg_periph_insel1 periph_insel1;
  rand pinmux_reg_mio_outsel0 mio_outsel0;
  rand pinmux_reg_mio_outsel1 mio_outsel1;

  `uvm_object_utils(pinmux_reg_block)

  function new(string name = "pinmux_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    regen = pinmux_reg_regen::type_id::create("regen");
    regen.configure(.blk_parent(this));
    regen.build();
    default_map.add_reg(.rg(regen),
                        .offset(32'h0),
                        .rights("RW"));
    periph_insel0 = pinmux_reg_periph_insel0::type_id::create("periph_insel0");
    periph_insel0.configure(.blk_parent(this));
    periph_insel0.build();
    default_map.add_reg(.rg(periph_insel0),
                        .offset(32'h4),
                        .rights("RW"));
    periph_insel1 = pinmux_reg_periph_insel1::type_id::create("periph_insel1");
    periph_insel1.configure(.blk_parent(this));
    periph_insel1.build();
    default_map.add_reg(.rg(periph_insel1),
                        .offset(32'h8),
                        .rights("RW"));
    mio_outsel0 = pinmux_reg_mio_outsel0::type_id::create("mio_outsel0");
    mio_outsel0.configure(.blk_parent(this));
    mio_outsel0.build();
    default_map.add_reg(.rg(mio_outsel0),
                        .offset(32'hc),
                        .rights("RW"));
    mio_outsel1 = pinmux_reg_mio_outsel1::type_id::create("mio_outsel1");
    mio_outsel1.configure(.blk_parent(this));
    mio_outsel1.build();
    default_map.add_reg(.rg(mio_outsel1),
                        .offset(32'h10),
                        .rights("RW"));
  endfunction : build

endclass : pinmux_reg_block
