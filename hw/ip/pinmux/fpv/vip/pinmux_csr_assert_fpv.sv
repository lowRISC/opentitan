// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// FPV CSR read and write assertions auto-generated by `reggen` containing data structure
// Do Not Edit directly
// TODO: This automation does not support: shadow reg and regwen reg
// This automation assumes that W1C and W0C are registers with 1 bit per field

`include "prim_assert.sv"

// Block: pinmux
module pinmux_csr_assert_fpv import tlul_pkg::*; import pinmux_reg_pkg::*; (
  input clk_i,
  input rst_ni,

  // tile link ports
  input tl_h2d_t h2d,
  input tl_d2h_t d2h,

  // reg and hw ports
  input pinmux_reg2hw_t reg2hw,
  input pinmux_hw2reg_t hw2reg
);

  parameter int DWidth = 32;
  // mask register to convert byte to bit
  logic [DWidth-1:0] a_mask_bit;

  assign a_mask_bit[7:0]   = h2d.a_mask[0] ? '1 : '0;
  assign a_mask_bit[15:8]  = h2d.a_mask[1] ? '1 : '0;
  assign a_mask_bit[23:16] = h2d.a_mask[2] ? '1 : '0;
  assign a_mask_bit[31:24] = h2d.a_mask[3] ? '1 : '0;

  // declare common read and write sequences
  sequence device_wr_S(logic [6:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {PutFullData, PutPartialData} &&
        h2d.a_valid && h2d.d_ready && !d2h.d_valid;
  endsequence

  sequence device_rd_S(logic [6:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {Get} && h2d.a_valid && h2d.d_ready &&
        !d2h.d_valid;
  endsequence

  // declare common read and write properties
  // for homog registers, we check by a reg; for non-homog regs, we check by field.
  // `mask` is used for checking by field. It masks out any act_data that are not within the field
  // `lsb` is used to check non-homog multi_reg. Because we are using a local copy `_fpv` variable
  // to store all the multi-reg within one basefield, we need to shift the `_fpv` value to the
  // correct bits, then compare with read/write exp_data.

  property wr_P(bit [6:0] addr, bit [DWidth-1:0] act_data, bit regen,
                bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_wr_S(addr), id = h2d.a_source, exp_data = h2d.a_data & a_mask_bit & mask) ##1
        first_match(##[0:$] d2h.d_valid && d2h.d_source == id) |->
        (d2h.d_error || (act_data << lsb) == exp_data || !regen);
  endproperty

  // external reg will use one clk cycle to update act_data from external
  property wr_ext_P(bit [6:0] addr, bit [DWidth-1:0] act_data, bit regen,
                    bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_wr_S(addr), id = h2d.a_source, exp_data = h2d.a_data & a_mask_bit & mask) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || ($past(act_data) << lsb) == exp_data || !regen);
  endproperty

  property w1c_P(bit [6:0] addr, bit [DWidth-1:0] act_data, bit regen,
                bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_wr_S(addr), id = h2d.a_source, exp_data = h2d.a_data & a_mask_bit & mask & '0) ##1
        first_match(##[0:$] d2h.d_valid && d2h.d_source == id) |->
        (d2h.d_error || (act_data << lsb) == exp_data || !regen);
  endproperty

  property w1c_ext_P(bit [6:0] addr, bit [DWidth-1:0] act_data, bit regen,
                    bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_wr_S(addr), id = h2d.a_source, exp_data = h2d.a_data & a_mask_bit & mask & '0) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || ($past(act_data) << lsb) == exp_data || !regen);
  endproperty

  property rd_P(bit [6:0] addr, bit [DWidth-1:0] act_data, bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_rd_S(addr), id = h2d.a_source, exp_data = $past(act_data)) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || (d2h.d_data & mask) >> lsb == exp_data);
  endproperty

  property rd_ext_P(bit [6:0] addr, bit [DWidth-1:0] act_data, bit [DWidth-1:0] mask,
      int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_rd_S(addr), id = h2d.a_source, exp_data = act_data) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || (d2h.d_data & mask) >> lsb == exp_data);
  endproperty

  // read a WO register, always return 0
  property r_wo_P(bit [6:0] addr);
    logic [DWidth-1:0] id;
    (device_rd_S(addr), id = h2d.a_source) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || d2h.d_data == 0);
  endproperty

  // TODO: currently not used, will use once support regwen reg
  property wr_regen_stable_P(bit regen, bit [DWidth-1:0] exp_data);
    (!regen && $stable(regen)) |-> $stable(exp_data);
  endproperty


  // assertions for register: regen

  // define local fpv variable for multi-reg
  logic [191:0] periph_insel_q_fpv;
  for (genvar s = 0; s < 32; s++) begin : gen_periph_insel_q
    assign periph_insel_q_fpv[((s+1)*6-1):s*6] = reg2hw.periph_insel[s].q;
  end

  // assertions for register: periph_insel0
  `ASSERT(periph_insel0_wr_A, wr_P(7'h4, periph_insel_q_fpv[29:0], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(periph_insel0_rd_A, rd_P(7'h4, periph_insel_q_fpv[29:0], 'h3fffffff, 0))
  // assertions for register: periph_insel1
  `ASSERT(periph_insel1_wr_A, wr_P(7'h8, periph_insel_q_fpv[59:30], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(periph_insel1_rd_A, rd_P(7'h8, periph_insel_q_fpv[59:30], 'h3fffffff, 0))
  // assertions for register: periph_insel2
  `ASSERT(periph_insel2_wr_A, wr_P(7'hc, periph_insel_q_fpv[89:60], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(periph_insel2_rd_A, rd_P(7'hc, periph_insel_q_fpv[89:60], 'h3fffffff, 0))
  // assertions for register: periph_insel3
  `ASSERT(periph_insel3_wr_A, wr_P(7'h10, periph_insel_q_fpv[119:90], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(periph_insel3_rd_A, rd_P(7'h10, periph_insel_q_fpv[119:90], 'h3fffffff, 0))
  // assertions for register: periph_insel4
  `ASSERT(periph_insel4_wr_A, wr_P(7'h14, periph_insel_q_fpv[149:120], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(periph_insel4_rd_A, rd_P(7'h14, periph_insel_q_fpv[149:120], 'h3fffffff, 0))
  // assertions for register: periph_insel5
  `ASSERT(periph_insel5_wr_A, wr_P(7'h18, periph_insel_q_fpv[179:150], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(periph_insel5_rd_A, rd_P(7'h18, periph_insel_q_fpv[179:150], 'h3fffffff, 0))
  // assertions for register: periph_insel6
  `ASSERT(periph_insel6_wr_A, wr_P(7'h1c, periph_insel_q_fpv[191:180], dut.u_reg.regen_qs, 'hfff, 0))
  `ASSERT(periph_insel6_rd_A, rd_P(7'h1c, periph_insel_q_fpv[191:180], 'hfff, 0))

  // define local fpv variable for multi-reg
  logic [191:0] mio_outsel_q_fpv;
  for (genvar s = 0; s < 32; s++) begin : gen_mio_outsel_q
    assign mio_outsel_q_fpv[((s+1)*6-1):s*6] = reg2hw.mio_outsel[s].q;
  end

  // assertions for register: mio_outsel0
  `ASSERT(mio_outsel0_wr_A, wr_P(7'h20, mio_outsel_q_fpv[29:0], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(mio_outsel0_rd_A, rd_P(7'h20, mio_outsel_q_fpv[29:0], 'h3fffffff, 0))
  // assertions for register: mio_outsel1
  `ASSERT(mio_outsel1_wr_A, wr_P(7'h24, mio_outsel_q_fpv[59:30], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(mio_outsel1_rd_A, rd_P(7'h24, mio_outsel_q_fpv[59:30], 'h3fffffff, 0))
  // assertions for register: mio_outsel2
  `ASSERT(mio_outsel2_wr_A, wr_P(7'h28, mio_outsel_q_fpv[89:60], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(mio_outsel2_rd_A, rd_P(7'h28, mio_outsel_q_fpv[89:60], 'h3fffffff, 0))
  // assertions for register: mio_outsel3
  `ASSERT(mio_outsel3_wr_A, wr_P(7'h2c, mio_outsel_q_fpv[119:90], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(mio_outsel3_rd_A, rd_P(7'h2c, mio_outsel_q_fpv[119:90], 'h3fffffff, 0))
  // assertions for register: mio_outsel4
  `ASSERT(mio_outsel4_wr_A, wr_P(7'h30, mio_outsel_q_fpv[149:120], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(mio_outsel4_rd_A, rd_P(7'h30, mio_outsel_q_fpv[149:120], 'h3fffffff, 0))
  // assertions for register: mio_outsel5
  `ASSERT(mio_outsel5_wr_A, wr_P(7'h34, mio_outsel_q_fpv[179:150], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(mio_outsel5_rd_A, rd_P(7'h34, mio_outsel_q_fpv[179:150], 'h3fffffff, 0))
  // assertions for register: mio_outsel6
  `ASSERT(mio_outsel6_wr_A, wr_P(7'h38, mio_outsel_q_fpv[191:180], dut.u_reg.regen_qs, 'hfff, 0))
  `ASSERT(mio_outsel6_rd_A, rd_P(7'h38, mio_outsel_q_fpv[191:180], 'hfff, 0))

  // define local fpv variable for multi-reg
  logic [63:0] mio_out_sleep_val_q_fpv;
  for (genvar s = 0; s < 32; s++) begin : gen_mio_out_sleep_val_q
    assign mio_out_sleep_val_q_fpv[((s+1)*2-1):s*2] = reg2hw.mio_out_sleep_val[s].q;
  end

  // assertions for register: mio_out_sleep_val0
  `ASSERT(mio_out_sleep_val0_wr_A, wr_P(7'h3c, mio_out_sleep_val_q_fpv[31:0], dut.u_reg.regen_qs, 'hffffffff, 0))
  `ASSERT(mio_out_sleep_val0_rd_A, rd_P(7'h3c, mio_out_sleep_val_q_fpv[31:0], 'hffffffff, 0))
  // assertions for register: mio_out_sleep_val1
  `ASSERT(mio_out_sleep_val1_wr_A, wr_P(7'h40, mio_out_sleep_val_q_fpv[63:32], dut.u_reg.regen_qs, 'hffffffff, 0))
  `ASSERT(mio_out_sleep_val1_rd_A, rd_P(7'h40, mio_out_sleep_val_q_fpv[63:32], 'hffffffff, 0))

  // define local fpv variable for multi-reg
  logic [31:0] dio_out_sleep_val_q_fpv;
  logic [31:0] dio_out_sleep_val_d_fpv;
  for (genvar s = 0; s < 16; s++) begin : gen_dio_out_sleep_val_q
    assign dio_out_sleep_val_q_fpv[((s+1)*2-1):s*2] = reg2hw.dio_out_sleep_val[s].q;
    assign dio_out_sleep_val_d_fpv[((s+1)*2-1):s*2] = hw2reg.dio_out_sleep_val[s].d;
  end

  // assertions for register: dio_out_sleep_val
  `ASSERT(dio_out_sleep_val_wr_A, wr_ext_P(7'h44, dio_out_sleep_val_q_fpv[31:0], dut.u_reg.regen_qs, 'hffffffff, 0))
  `ASSERT(dio_out_sleep_val_rd_A, rd_ext_P(7'h44, dio_out_sleep_val_d_fpv[31:0], 'hffffffff, 0))

  // define local fpv variable for multi-reg
  logic [7:0] wkup_detector_en_q_fpv;
  for (genvar s = 0; s < 8; s++) begin : gen_wkup_detector_en_q
    assign wkup_detector_en_q_fpv[((s+1)*1-1):s*1] = reg2hw.wkup_detector_en[s].q;
  end

  // assertions for register: wkup_detector_en
  `ASSERT(wkup_detector_en_wr_A, wr_P(7'h48, wkup_detector_en_q_fpv[7:0], dut.u_reg.regen_qs, 'hff, 0))
  `ASSERT(wkup_detector_en_rd_A, rd_P(7'h48, wkup_detector_en_q_fpv[7:0], 'hff, 0))

  // define local fpv variable for multi-reg
  logic [23:0] wkup_detector_mode_q_fpv;
  logic [7:0] wkup_detector_filter_q_fpv;
  logic [7:0] wkup_detector_miodio_q_fpv;
  for (genvar s = 0; s < 8; s++) begin : gen_wkup_detector_q
    assign wkup_detector_mode_q_fpv[((s+1)*3-1):s*3] = reg2hw.wkup_detector[s].mode.q;
    assign wkup_detector_filter_q_fpv[((s+1)*1-1):s*1] = reg2hw.wkup_detector[s].filter.q;
    assign wkup_detector_miodio_q_fpv[((s+1)*1-1):s*1] = reg2hw.wkup_detector[s].miodio.q;
  end

  // assertions for register: wkup_detector0
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector0_mode0_wr_A, wr_P(7'h4c, wkup_detector_mode_q_fpv[2:0], dut.u_reg.regen_qs, 'h7, 0))
  `ASSERT(wkup_detector0_mode0_rd_A, rd_P(7'h4c, wkup_detector_mode_q_fpv[2:0], 'h7, 0))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector0_filter0_wr_A, wr_P(7'h4c, wkup_detector_filter_q_fpv[0:0], dut.u_reg.regen_qs, 'h8, 3))
  `ASSERT(wkup_detector0_filter0_rd_A, rd_P(7'h4c, wkup_detector_filter_q_fpv[0:0], 'h8, 3))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector0_miodio0_wr_A, wr_P(7'h4c, wkup_detector_miodio_q_fpv[0:0], dut.u_reg.regen_qs, 'h10, 4))
  `ASSERT(wkup_detector0_miodio0_rd_A, rd_P(7'h4c, wkup_detector_miodio_q_fpv[0:0], 'h10, 4))
  // assertions for register: wkup_detector1
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector1_mode1_wr_A, wr_P(7'h50, wkup_detector_mode_q_fpv[5:3], dut.u_reg.regen_qs, 'h7, 0))
  `ASSERT(wkup_detector1_mode1_rd_A, rd_P(7'h50, wkup_detector_mode_q_fpv[5:3], 'h7, 0))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector1_filter1_wr_A, wr_P(7'h50, wkup_detector_filter_q_fpv[1:1], dut.u_reg.regen_qs, 'h8, 3))
  `ASSERT(wkup_detector1_filter1_rd_A, rd_P(7'h50, wkup_detector_filter_q_fpv[1:1], 'h8, 3))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector1_miodio1_wr_A, wr_P(7'h50, wkup_detector_miodio_q_fpv[1:1], dut.u_reg.regen_qs, 'h10, 4))
  `ASSERT(wkup_detector1_miodio1_rd_A, rd_P(7'h50, wkup_detector_miodio_q_fpv[1:1], 'h10, 4))
  // assertions for register: wkup_detector2
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector2_mode2_wr_A, wr_P(7'h54, wkup_detector_mode_q_fpv[8:6], dut.u_reg.regen_qs, 'h7, 0))
  `ASSERT(wkup_detector2_mode2_rd_A, rd_P(7'h54, wkup_detector_mode_q_fpv[8:6], 'h7, 0))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector2_filter2_wr_A, wr_P(7'h54, wkup_detector_filter_q_fpv[2:2], dut.u_reg.regen_qs, 'h8, 3))
  `ASSERT(wkup_detector2_filter2_rd_A, rd_P(7'h54, wkup_detector_filter_q_fpv[2:2], 'h8, 3))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector2_miodio2_wr_A, wr_P(7'h54, wkup_detector_miodio_q_fpv[2:2], dut.u_reg.regen_qs, 'h10, 4))
  `ASSERT(wkup_detector2_miodio2_rd_A, rd_P(7'h54, wkup_detector_miodio_q_fpv[2:2], 'h10, 4))
  // assertions for register: wkup_detector3
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector3_mode3_wr_A, wr_P(7'h58, wkup_detector_mode_q_fpv[11:9], dut.u_reg.regen_qs, 'h7, 0))
  `ASSERT(wkup_detector3_mode3_rd_A, rd_P(7'h58, wkup_detector_mode_q_fpv[11:9], 'h7, 0))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector3_filter3_wr_A, wr_P(7'h58, wkup_detector_filter_q_fpv[3:3], dut.u_reg.regen_qs, 'h8, 3))
  `ASSERT(wkup_detector3_filter3_rd_A, rd_P(7'h58, wkup_detector_filter_q_fpv[3:3], 'h8, 3))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector3_miodio3_wr_A, wr_P(7'h58, wkup_detector_miodio_q_fpv[3:3], dut.u_reg.regen_qs, 'h10, 4))
  `ASSERT(wkup_detector3_miodio3_rd_A, rd_P(7'h58, wkup_detector_miodio_q_fpv[3:3], 'h10, 4))
  // assertions for register: wkup_detector4
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector4_mode4_wr_A, wr_P(7'h5c, wkup_detector_mode_q_fpv[14:12], dut.u_reg.regen_qs, 'h7, 0))
  `ASSERT(wkup_detector4_mode4_rd_A, rd_P(7'h5c, wkup_detector_mode_q_fpv[14:12], 'h7, 0))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector4_filter4_wr_A, wr_P(7'h5c, wkup_detector_filter_q_fpv[4:4], dut.u_reg.regen_qs, 'h8, 3))
  `ASSERT(wkup_detector4_filter4_rd_A, rd_P(7'h5c, wkup_detector_filter_q_fpv[4:4], 'h8, 3))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector4_miodio4_wr_A, wr_P(7'h5c, wkup_detector_miodio_q_fpv[4:4], dut.u_reg.regen_qs, 'h10, 4))
  `ASSERT(wkup_detector4_miodio4_rd_A, rd_P(7'h5c, wkup_detector_miodio_q_fpv[4:4], 'h10, 4))
  // assertions for register: wkup_detector5
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector5_mode5_wr_A, wr_P(7'h60, wkup_detector_mode_q_fpv[17:15], dut.u_reg.regen_qs, 'h7, 0))
  `ASSERT(wkup_detector5_mode5_rd_A, rd_P(7'h60, wkup_detector_mode_q_fpv[17:15], 'h7, 0))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector5_filter5_wr_A, wr_P(7'h60, wkup_detector_filter_q_fpv[5:5], dut.u_reg.regen_qs, 'h8, 3))
  `ASSERT(wkup_detector5_filter5_rd_A, rd_P(7'h60, wkup_detector_filter_q_fpv[5:5], 'h8, 3))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector5_miodio5_wr_A, wr_P(7'h60, wkup_detector_miodio_q_fpv[5:5], dut.u_reg.regen_qs, 'h10, 4))
  `ASSERT(wkup_detector5_miodio5_rd_A, rd_P(7'h60, wkup_detector_miodio_q_fpv[5:5], 'h10, 4))
  // assertions for register: wkup_detector6
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector6_mode6_wr_A, wr_P(7'h64, wkup_detector_mode_q_fpv[20:18], dut.u_reg.regen_qs, 'h7, 0))
  `ASSERT(wkup_detector6_mode6_rd_A, rd_P(7'h64, wkup_detector_mode_q_fpv[20:18], 'h7, 0))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector6_filter6_wr_A, wr_P(7'h64, wkup_detector_filter_q_fpv[6:6], dut.u_reg.regen_qs, 'h8, 3))
  `ASSERT(wkup_detector6_filter6_rd_A, rd_P(7'h64, wkup_detector_filter_q_fpv[6:6], 'h8, 3))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector6_miodio6_wr_A, wr_P(7'h64, wkup_detector_miodio_q_fpv[6:6], dut.u_reg.regen_qs, 'h10, 4))
  `ASSERT(wkup_detector6_miodio6_rd_A, rd_P(7'h64, wkup_detector_miodio_q_fpv[6:6], 'h10, 4))
  // assertions for register: wkup_detector7
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector7_mode7_wr_A, wr_P(7'h68, wkup_detector_mode_q_fpv[23:21], dut.u_reg.regen_qs, 'h7, 0))
  `ASSERT(wkup_detector7_mode7_rd_A, rd_P(7'h68, wkup_detector_mode_q_fpv[23:21], 'h7, 0))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector7_filter7_wr_A, wr_P(7'h68, wkup_detector_filter_q_fpv[7:7], dut.u_reg.regen_qs, 'h8, 3))
  `ASSERT(wkup_detector7_filter7_rd_A, rd_P(7'h68, wkup_detector_filter_q_fpv[7:7], 'h8, 3))
  // this is a non-homog multi-reg
  `ASSERT(wkup_detector7_miodio7_wr_A, wr_P(7'h68, wkup_detector_miodio_q_fpv[7:7], dut.u_reg.regen_qs, 'h10, 4))
  `ASSERT(wkup_detector7_miodio7_rd_A, rd_P(7'h68, wkup_detector_miodio_q_fpv[7:7], 'h10, 4))

  // define local fpv variable for multi-reg
  logic [63:0] wkup_detector_cnt_th_q_fpv;
  for (genvar s = 0; s < 8; s++) begin : gen_wkup_detector_cnt_th_q
    assign wkup_detector_cnt_th_q_fpv[((s+1)*8-1):s*8] = reg2hw.wkup_detector_cnt_th[s].q;
  end

  // assertions for register: wkup_detector_cnt_th0
  `ASSERT(wkup_detector_cnt_th0_wr_A, wr_P(7'h6c, wkup_detector_cnt_th_q_fpv[31:0], dut.u_reg.regen_qs, 'hffffffff, 0))
  `ASSERT(wkup_detector_cnt_th0_rd_A, rd_P(7'h6c, wkup_detector_cnt_th_q_fpv[31:0], 'hffffffff, 0))
  // assertions for register: wkup_detector_cnt_th1
  `ASSERT(wkup_detector_cnt_th1_wr_A, wr_P(7'h70, wkup_detector_cnt_th_q_fpv[63:32], dut.u_reg.regen_qs, 'hffffffff, 0))
  `ASSERT(wkup_detector_cnt_th1_rd_A, rd_P(7'h70, wkup_detector_cnt_th_q_fpv[63:32], 'hffffffff, 0))

  // define local fpv variable for multi-reg
  logic [39:0] wkup_detector_padsel_q_fpv;
  for (genvar s = 0; s < 8; s++) begin : gen_wkup_detector_padsel_q
    assign wkup_detector_padsel_q_fpv[((s+1)*5-1):s*5] = reg2hw.wkup_detector_padsel[s].q;
  end

  // assertions for register: wkup_detector_padsel0
  `ASSERT(wkup_detector_padsel0_wr_A, wr_P(7'h74, wkup_detector_padsel_q_fpv[29:0], dut.u_reg.regen_qs, 'h3fffffff, 0))
  `ASSERT(wkup_detector_padsel0_rd_A, rd_P(7'h74, wkup_detector_padsel_q_fpv[29:0], 'h3fffffff, 0))
  // assertions for register: wkup_detector_padsel1
  `ASSERT(wkup_detector_padsel1_wr_A, wr_P(7'h78, wkup_detector_padsel_q_fpv[39:30], dut.u_reg.regen_qs, 'h3ff, 0))
  `ASSERT(wkup_detector_padsel1_rd_A, rd_P(7'h78, wkup_detector_padsel_q_fpv[39:30], 'h3ff, 0))

  // define local fpv variable for multi-reg
  logic [7:0] wkup_cause_q_fpv;
  logic [7:0] wkup_cause_d_fpv;
  for (genvar s = 0; s < 8; s++) begin : gen_wkup_cause_q
    assign wkup_cause_q_fpv[((s+1)*1-1):s*1] = reg2hw.wkup_cause[s].q;
    assign wkup_cause_d_fpv[((s+1)*1-1):s*1] = hw2reg.wkup_cause[s].d;
  end

  // assertions for register: wkup_cause
  `ASSERT(wkup_cause_wr_A, wr_ext_P(7'h7c, wkup_cause_q_fpv[7:0], dut.u_reg.regen_qs, 'hff, 0))
  `ASSERT(wkup_cause_rd_A, rd_ext_P(7'h7c, wkup_cause_d_fpv[7:0], 'hff, 0))


endmodule
