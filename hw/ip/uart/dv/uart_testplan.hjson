{
  name: "uart"
  import_testplans: ["hw/dv/tools/testplans/csr_testplan.hjson",
                     "hw/dv/tools/testplans/intr_test_testplan.hjson",
                     "hw/dv/tools/testplans/tl_device_access_types_testplan.hjson"]
  entries: [
    {
      name: sanity
      desc: '''Basic UART sanity test with few bytes transmitted and received asynchronously
            and in parallel with scoreboard checks. Randomize UART baud rate and other
            parameters such as TL agent delays.'''
      milestone: V1
      tests: ["uart_sanity"]
    }
    {
      name: parity
      desc: "Send / receive bytes with parity and odd parity enabled randomly."
      milestone: V2
      tests: []
    }
    {
      name: parity_error
      desc: '''Enable parity and randomly set even/odd parity. Inject parity error randomly
            on data sent from rx and ensure the interrupt is raised.Send / receive bytes
            with parity and odd parity enabled randomly.'''
      milestone: V2
      tests: []
    }
    {
      name: tx_watermark
      desc: '''Program random tx fifo watermark level and keep pushing data out by writing to
            wdata. As the number of pending data entries in the tx fifo reaches the programmed
            watermark level, ensure that the tx watermark interrupt is asserted. Read the fifo
            status to cross-check. Ensure interrupt stays asserted until cleared.'''
      milestone: V2
      tests: []
    }
    {
      name: rx_watermark
      desc: '''Program random rx watermark level. Keep sending data over rx and read rdata
            register in parallel with randomized delays large enough to reach a point where
            the number of pending data items in rx fifo reaches the watermark level. When
            that happens, check that the interrupt is asserted.'''
      milestone: V2
      tests: []
    }
    {
      name: tx_reset
      desc: '''Fill up the tx fifo with data to be sent out. After a random number (less than
            filled fifo size) of bytes shows up on tx, reset the fifo and ensure that the
            remaining data bytes do not show up.'''
      milestone: V2
      tests: []
    }
    {
      name: rx_reset
      desc: '''Fill up the rx fifo by sending data bytes in over rx. After a random number
            (less than filled fifo size) of bytes sent over rx, reset the fifo and ensure
            that reads to rdata register yield 0s.'''
      milestone: V2
      tests: []
    }
    {
      name: tx_overflow
      desc: '''Keep writing over 32 bytes of data into wdata register and ensure excess data
            bytes are dropped and overflow interrupt is asserted.'''
      milestone: V2
      tests: []
    }
    {
      name: rx_overflow
      desc: '''Keep sending over 32 bytes of data over rx and ensure excess data bytes are
            dropped.'''
      milestone: V2
      tests: []
    }
    {
      name: tx_rx_fifo_full
      desc: "Send over 32 bytes of data but stop when fifo is full"
      milestone: V2
      tests: []
    }
    {
      name: frame_err
      desc: '''Inject frame error in parity and non-parity cases by not setting stop bit = 1.
            Ensure the interrupt gets asserted.'''
      milestone: V2
      tests: []
    }
    {
      name: rx_break_err
      desc: '''Program random number of break detection characters. Create a frame error
            scenario and send random number of 0 bytes. If that random number exceeds the
            programmed break characters, ensure that the break_err interrupt is asserted.'''
      milestone: V2
      tests: []
    }
    {
      name: rx_timeout
      desc: '''Program timeout_ctrl register to randomize the timeout. Send random number of
            data over rx and read fewer data than sent and let the DUT sit idle or the
            programmed timeout duration. Ensure timeout interrupt fires.'''
      milestone: V2
      tests: []
    }
    {
      name: stress
      desc: '''Do combinations of multiple of above scenarios to get multiple interrupts
            asserted at the same time. Scoreboard should be robust enough to deal with all
            scenarios.'''
      milestone: V2
      tests: []
    }
    {
      name: perf
      desc: '''Run (perhaps the stress test) with highest supported baud rate.
            - Core freq: 24mhz, 25mhz, 48mhz, 50mhz, 100mhz
            - Baud rate: 9600, 115200, 230400, 1Mbps(1048576), 2Mbps(2097152)'''
      milestone: V2
      tests: []
    }
    {
      name: sys_loopback
      desc: '''Drive uart TX and data will be loopbacked through RX. After loopback is done,
            RDATA will be equal to WDATA'''
      milestone: V2
      tests: []
    }
    {
      name: line_loopback
      desc: "Line loopback test"
      milestone: V2
      tests: []
    }
    {
      name: rx_noise_filter
      desc: "16x fast clk to check it, need to be 3 clk same value"
      milestone: V2
      tests: []
    }
    {
      name: tx_overide
      desc: "Enable override control and use register programming to drive uart output directly"
      milestone: V2
      tests: []
    }
    {
      name: rx_oversample
      desc: "read RX oversampled value and check use 16x faster than baud clk to sample it"
      milestone: V2
      tests: []
    }
  ]
}
