// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// UVM Registers auto-generated by `reggen` containing data structure
// Do Not Edit directly

// Forward declare all register/memory/block classes
typedef class flash_ctrl_reg_intr_state;
typedef class flash_ctrl_reg_intr_enable;
typedef class flash_ctrl_reg_intr_test;
typedef class flash_ctrl_reg_control;
typedef class flash_ctrl_reg_addr;
typedef class flash_ctrl_reg_region_cfg_regwen;
typedef class flash_ctrl_reg_mp_region_cfg0;
typedef class flash_ctrl_reg_mp_region_cfg1;
typedef class flash_ctrl_reg_mp_region_cfg2;
typedef class flash_ctrl_reg_mp_region_cfg3;
typedef class flash_ctrl_reg_mp_region_cfg4;
typedef class flash_ctrl_reg_mp_region_cfg5;
typedef class flash_ctrl_reg_mp_region_cfg6;
typedef class flash_ctrl_reg_mp_region_cfg7;
typedef class flash_ctrl_reg_default_region;
typedef class flash_ctrl_reg_bank_cfg_regwen;
typedef class flash_ctrl_reg_mp_bank_cfg;
typedef class flash_ctrl_reg_op_status;
typedef class flash_ctrl_reg_status;
typedef class flash_ctrl_reg_scratch;
typedef class flash_ctrl_reg_fifo_lvl;
typedef class flash_ctrl_mem_prog_fifo;
typedef class flash_ctrl_mem_rd_fifo;
typedef class flash_ctrl_reg_block;

// Block: flash_ctrl
// Class: flash_ctrl_reg_intr_state
class flash_ctrl_reg_intr_state extends dv_base_reg;
  // fields
  rand dv_base_reg_field prog_empty;
  rand dv_base_reg_field prog_lvl;
  rand dv_base_reg_field rd_full;
  rand dv_base_reg_field rd_lvl;
  rand dv_base_reg_field op_done;
  rand dv_base_reg_field op_error;

  `uvm_object_utils(flash_ctrl_reg_intr_state)

  function new(string       name = "flash_ctrl_reg_intr_state",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prog_empty = dv_base_reg_field::type_id::create("prog_empty");
    prog_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_lvl = dv_base_reg_field::type_id::create("prog_lvl");
    prog_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_full = dv_base_reg_field::type_id::create("rd_full");
    rd_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_lvl = dv_base_reg_field::type_id::create("rd_lvl");
    rd_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_done = dv_base_reg_field::type_id::create("op_done");
    op_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_error = dv_base_reg_field::type_id::create("op_error");
    op_error.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_intr_state

// Class: flash_ctrl_reg_intr_enable
class flash_ctrl_reg_intr_enable extends dv_base_reg;
  // fields
  rand dv_base_reg_field prog_empty;
  rand dv_base_reg_field prog_lvl;
  rand dv_base_reg_field rd_full;
  rand dv_base_reg_field rd_lvl;
  rand dv_base_reg_field op_done;
  rand dv_base_reg_field op_error;

  `uvm_object_utils(flash_ctrl_reg_intr_enable)

  function new(string       name = "flash_ctrl_reg_intr_enable",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prog_empty = dv_base_reg_field::type_id::create("prog_empty");
    prog_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_lvl = dv_base_reg_field::type_id::create("prog_lvl");
    prog_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_full = dv_base_reg_field::type_id::create("rd_full");
    rd_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_lvl = dv_base_reg_field::type_id::create("rd_lvl");
    rd_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_done = dv_base_reg_field::type_id::create("op_done");
    op_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_error = dv_base_reg_field::type_id::create("op_error");
    op_error.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_intr_enable

// Class: flash_ctrl_reg_intr_test
class flash_ctrl_reg_intr_test extends dv_base_reg;
  // fields
  rand dv_base_reg_field prog_empty;
  rand dv_base_reg_field prog_lvl;
  rand dv_base_reg_field rd_full;
  rand dv_base_reg_field rd_lvl;
  rand dv_base_reg_field op_done;
  rand dv_base_reg_field op_error;

  `uvm_object_utils(flash_ctrl_reg_intr_test)

  function new(string       name = "flash_ctrl_reg_intr_test",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prog_empty = dv_base_reg_field::type_id::create("prog_empty");
    prog_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_lvl = dv_base_reg_field::type_id::create("prog_lvl");
    prog_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_full = dv_base_reg_field::type_id::create("rd_full");
    rd_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_lvl = dv_base_reg_field::type_id::create("rd_lvl");
    rd_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_done = dv_base_reg_field::type_id::create("op_done");
    op_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_error = dv_base_reg_field::type_id::create("op_error");
    op_error.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_intr_test

// Class: flash_ctrl_reg_control
class flash_ctrl_reg_control extends dv_base_reg;
  // fields
  rand dv_base_reg_field start;
  rand dv_base_reg_field op;
  rand dv_base_reg_field erase_sel;
  rand dv_base_reg_field fifo_rst;
  rand dv_base_reg_field num;

  `uvm_object_utils(flash_ctrl_reg_control)

  function new(string       name = "flash_ctrl_reg_control",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    start = dv_base_reg_field::type_id::create("start");
    start.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op = dv_base_reg_field::type_id::create("op");
    op.configure(
      .parent(this),
      .size(2),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_sel = dv_base_reg_field::type_id::create("erase_sel");
    erase_sel.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    fifo_rst = dv_base_reg_field::type_id::create("fifo_rst");
    fifo_rst.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    num = dv_base_reg_field::type_id::create("num");
    num.configure(
      .parent(this),
      .size(12),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_control

// Class: flash_ctrl_reg_addr
class flash_ctrl_reg_addr extends dv_base_reg;
  // fields
  rand dv_base_reg_field start;

  `uvm_object_utils(flash_ctrl_reg_addr)

  function new(string       name = "flash_ctrl_reg_addr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    start = dv_base_reg_field::type_id::create("start");
    start.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_addr

// Class: flash_ctrl_reg_region_cfg_regwen
class flash_ctrl_reg_region_cfg_regwen extends dv_base_reg;
  // fields
  rand dv_base_reg_field region0;
  rand dv_base_reg_field region1;
  rand dv_base_reg_field region2;
  rand dv_base_reg_field region3;
  rand dv_base_reg_field region4;
  rand dv_base_reg_field region5;
  rand dv_base_reg_field region6;
  rand dv_base_reg_field region7;

  `uvm_object_utils(flash_ctrl_reg_region_cfg_regwen)

  function new(string       name = "flash_ctrl_reg_region_cfg_regwen",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    region0 = dv_base_reg_field::type_id::create("region0");
    region0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region1 = dv_base_reg_field::type_id::create("region1");
    region1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region2 = dv_base_reg_field::type_id::create("region2");
    region2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region3 = dv_base_reg_field::type_id::create("region3");
    region3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region4 = dv_base_reg_field::type_id::create("region4");
    region4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region5 = dv_base_reg_field::type_id::create("region5");
    region5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region6 = dv_base_reg_field::type_id::create("region6");
    region6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region7 = dv_base_reg_field::type_id::create("region7");
    region7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_region_cfg_regwen

// Class: flash_ctrl_reg_mp_region_cfg0
class flash_ctrl_reg_mp_region_cfg0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en0;
  rand dv_base_reg_field rd_en0;
  rand dv_base_reg_field prog_en0;
  rand dv_base_reg_field erase_en0;
  rand dv_base_reg_field base0;
  rand dv_base_reg_field size0;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg0)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en0 = dv_base_reg_field::type_id::create("en0");
    en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en0 = dv_base_reg_field::type_id::create("rd_en0");
    rd_en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en0 = dv_base_reg_field::type_id::create("prog_en0");
    prog_en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en0 = dv_base_reg_field::type_id::create("erase_en0");
    erase_en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base0 = dv_base_reg_field::type_id::create("base0");
    base0.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size0 = dv_base_reg_field::type_id::create("size0");
    size0.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg0

// Class: flash_ctrl_reg_mp_region_cfg1
class flash_ctrl_reg_mp_region_cfg1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en1;
  rand dv_base_reg_field rd_en1;
  rand dv_base_reg_field prog_en1;
  rand dv_base_reg_field erase_en1;
  rand dv_base_reg_field base1;
  rand dv_base_reg_field size1;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg1)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en1 = dv_base_reg_field::type_id::create("en1");
    en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en1 = dv_base_reg_field::type_id::create("rd_en1");
    rd_en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en1 = dv_base_reg_field::type_id::create("prog_en1");
    prog_en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en1 = dv_base_reg_field::type_id::create("erase_en1");
    erase_en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base1 = dv_base_reg_field::type_id::create("base1");
    base1.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size1 = dv_base_reg_field::type_id::create("size1");
    size1.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg1

// Class: flash_ctrl_reg_mp_region_cfg2
class flash_ctrl_reg_mp_region_cfg2 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en2;
  rand dv_base_reg_field rd_en2;
  rand dv_base_reg_field prog_en2;
  rand dv_base_reg_field erase_en2;
  rand dv_base_reg_field base2;
  rand dv_base_reg_field size2;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg2)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg2",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en2 = dv_base_reg_field::type_id::create("en2");
    en2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en2 = dv_base_reg_field::type_id::create("rd_en2");
    rd_en2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en2 = dv_base_reg_field::type_id::create("prog_en2");
    prog_en2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en2 = dv_base_reg_field::type_id::create("erase_en2");
    erase_en2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base2 = dv_base_reg_field::type_id::create("base2");
    base2.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size2 = dv_base_reg_field::type_id::create("size2");
    size2.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg2

// Class: flash_ctrl_reg_mp_region_cfg3
class flash_ctrl_reg_mp_region_cfg3 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en3;
  rand dv_base_reg_field rd_en3;
  rand dv_base_reg_field prog_en3;
  rand dv_base_reg_field erase_en3;
  rand dv_base_reg_field base3;
  rand dv_base_reg_field size3;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg3)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg3",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en3 = dv_base_reg_field::type_id::create("en3");
    en3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en3 = dv_base_reg_field::type_id::create("rd_en3");
    rd_en3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en3 = dv_base_reg_field::type_id::create("prog_en3");
    prog_en3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en3 = dv_base_reg_field::type_id::create("erase_en3");
    erase_en3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base3 = dv_base_reg_field::type_id::create("base3");
    base3.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size3 = dv_base_reg_field::type_id::create("size3");
    size3.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg3

// Class: flash_ctrl_reg_mp_region_cfg4
class flash_ctrl_reg_mp_region_cfg4 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en4;
  rand dv_base_reg_field rd_en4;
  rand dv_base_reg_field prog_en4;
  rand dv_base_reg_field erase_en4;
  rand dv_base_reg_field base4;
  rand dv_base_reg_field size4;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg4)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg4",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en4 = dv_base_reg_field::type_id::create("en4");
    en4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en4 = dv_base_reg_field::type_id::create("rd_en4");
    rd_en4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en4 = dv_base_reg_field::type_id::create("prog_en4");
    prog_en4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en4 = dv_base_reg_field::type_id::create("erase_en4");
    erase_en4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base4 = dv_base_reg_field::type_id::create("base4");
    base4.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size4 = dv_base_reg_field::type_id::create("size4");
    size4.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg4

// Class: flash_ctrl_reg_mp_region_cfg5
class flash_ctrl_reg_mp_region_cfg5 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en5;
  rand dv_base_reg_field rd_en5;
  rand dv_base_reg_field prog_en5;
  rand dv_base_reg_field erase_en5;
  rand dv_base_reg_field base5;
  rand dv_base_reg_field size5;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg5)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg5",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en5 = dv_base_reg_field::type_id::create("en5");
    en5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en5 = dv_base_reg_field::type_id::create("rd_en5");
    rd_en5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en5 = dv_base_reg_field::type_id::create("prog_en5");
    prog_en5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en5 = dv_base_reg_field::type_id::create("erase_en5");
    erase_en5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base5 = dv_base_reg_field::type_id::create("base5");
    base5.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size5 = dv_base_reg_field::type_id::create("size5");
    size5.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg5

// Class: flash_ctrl_reg_mp_region_cfg6
class flash_ctrl_reg_mp_region_cfg6 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en6;
  rand dv_base_reg_field rd_en6;
  rand dv_base_reg_field prog_en6;
  rand dv_base_reg_field erase_en6;
  rand dv_base_reg_field base6;
  rand dv_base_reg_field size6;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg6)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg6",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en6 = dv_base_reg_field::type_id::create("en6");
    en6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en6 = dv_base_reg_field::type_id::create("rd_en6");
    rd_en6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en6 = dv_base_reg_field::type_id::create("prog_en6");
    prog_en6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en6 = dv_base_reg_field::type_id::create("erase_en6");
    erase_en6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base6 = dv_base_reg_field::type_id::create("base6");
    base6.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size6 = dv_base_reg_field::type_id::create("size6");
    size6.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg6

// Class: flash_ctrl_reg_mp_region_cfg7
class flash_ctrl_reg_mp_region_cfg7 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en7;
  rand dv_base_reg_field rd_en7;
  rand dv_base_reg_field prog_en7;
  rand dv_base_reg_field erase_en7;
  rand dv_base_reg_field base7;
  rand dv_base_reg_field size7;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg7)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg7",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en7 = dv_base_reg_field::type_id::create("en7");
    en7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en7 = dv_base_reg_field::type_id::create("rd_en7");
    rd_en7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en7 = dv_base_reg_field::type_id::create("prog_en7");
    prog_en7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en7 = dv_base_reg_field::type_id::create("erase_en7");
    erase_en7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base7 = dv_base_reg_field::type_id::create("base7");
    base7.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size7 = dv_base_reg_field::type_id::create("size7");
    size7.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg7

// Class: flash_ctrl_reg_default_region
class flash_ctrl_reg_default_region extends dv_base_reg;
  // fields
  rand dv_base_reg_field rd_en;
  rand dv_base_reg_field prog_en;
  rand dv_base_reg_field erase_en;

  `uvm_object_utils(flash_ctrl_reg_default_region)

  function new(string       name = "flash_ctrl_reg_default_region",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rd_en = dv_base_reg_field::type_id::create("rd_en");
    rd_en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en = dv_base_reg_field::type_id::create("prog_en");
    prog_en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en = dv_base_reg_field::type_id::create("erase_en");
    erase_en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_default_region

// Class: flash_ctrl_reg_bank_cfg_regwen
class flash_ctrl_reg_bank_cfg_regwen extends dv_base_reg;
  // fields
  rand dv_base_reg_field bank;

  `uvm_object_utils(flash_ctrl_reg_bank_cfg_regwen)

  function new(string       name = "flash_ctrl_reg_bank_cfg_regwen",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    bank = dv_base_reg_field::type_id::create("bank");
    bank.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_bank_cfg_regwen

// Class: flash_ctrl_reg_mp_bank_cfg
class flash_ctrl_reg_mp_bank_cfg extends dv_base_reg;
  // fields
  rand dv_base_reg_field erase_en0;
  rand dv_base_reg_field erase_en1;

  `uvm_object_utils(flash_ctrl_reg_mp_bank_cfg)

  function new(string       name = "flash_ctrl_reg_mp_bank_cfg",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    erase_en0 = dv_base_reg_field::type_id::create("erase_en0");
    erase_en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en1 = dv_base_reg_field::type_id::create("erase_en1");
    erase_en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_bank_cfg

// Class: flash_ctrl_reg_op_status
class flash_ctrl_reg_op_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field done;
  rand dv_base_reg_field err;

  `uvm_object_utils(flash_ctrl_reg_op_status)

  function new(string       name = "flash_ctrl_reg_op_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    done = dv_base_reg_field::type_id::create("done");
    done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    err = dv_base_reg_field::type_id::create("err");
    err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_op_status

// Class: flash_ctrl_reg_status
class flash_ctrl_reg_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field rd_full;
  rand dv_base_reg_field rd_empty;
  rand dv_base_reg_field prog_full;
  rand dv_base_reg_field prog_empty;
  rand dv_base_reg_field init_wip;
  rand dv_base_reg_field error_page;
  rand dv_base_reg_field error_bank;

  `uvm_object_utils(flash_ctrl_reg_status)

  function new(string       name = "flash_ctrl_reg_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rd_full = dv_base_reg_field::type_id::create("rd_full");
    rd_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_empty = dv_base_reg_field::type_id::create("rd_empty");
    rd_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_full = dv_base_reg_field::type_id::create("prog_full");
    prog_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_empty = dv_base_reg_field::type_id::create("prog_empty");
    prog_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    init_wip = dv_base_reg_field::type_id::create("init_wip");
    init_wip.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    error_page = dv_base_reg_field::type_id::create("error_page");
    error_page.configure(
      .parent(this),
      .size(9),
      .lsb_pos(8),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    error_bank = dv_base_reg_field::type_id::create("error_bank");
    error_bank.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_status

// Class: flash_ctrl_reg_scratch
class flash_ctrl_reg_scratch extends dv_base_reg;
  // fields
  rand dv_base_reg_field data;

  `uvm_object_utils(flash_ctrl_reg_scratch)

  function new(string       name = "flash_ctrl_reg_scratch",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data = dv_base_reg_field::type_id::create("data");
    data.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_scratch

// Class: flash_ctrl_reg_fifo_lvl
class flash_ctrl_reg_fifo_lvl extends dv_base_reg;
  // fields
  rand dv_base_reg_field prog;
  rand dv_base_reg_field rd;

  `uvm_object_utils(flash_ctrl_reg_fifo_lvl)

  function new(string       name = "flash_ctrl_reg_fifo_lvl",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prog = dv_base_reg_field::type_id::create("prog");
    prog.configure(
      .parent(this),
      .size(5),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(15),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd = dv_base_reg_field::type_id::create("rd");
    rd.configure(
      .parent(this),
      .size(5),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(15),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_fifo_lvl

// Class: flash_ctrl_mem_prog_fifo
class flash_ctrl_mem_prog_fifo extends dv_base_mem;

  `uvm_object_utils(flash_ctrl_mem_prog_fifo)

  function new(string           name = "flash_ctrl_mem_prog_fifo",
               longint unsigned size = 1,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"WO"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : flash_ctrl_mem_prog_fifo

// Class: flash_ctrl_mem_rd_fifo
class flash_ctrl_mem_rd_fifo extends dv_base_mem;

  `uvm_object_utils(flash_ctrl_mem_rd_fifo)

  function new(string           name = "flash_ctrl_mem_rd_fifo",
               longint unsigned size = 1,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"RO"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : flash_ctrl_mem_rd_fifo

// Class: flash_ctrl_reg_block
class flash_ctrl_reg_block extends dv_base_reg_block;
  // registers
  rand flash_ctrl_reg_intr_state intr_state;
  rand flash_ctrl_reg_intr_enable intr_enable;
  rand flash_ctrl_reg_intr_test intr_test;
  rand flash_ctrl_reg_control control;
  rand flash_ctrl_reg_addr addr;
  rand flash_ctrl_reg_region_cfg_regwen region_cfg_regwen;
  rand flash_ctrl_reg_mp_region_cfg0 mp_region_cfg0;
  rand flash_ctrl_reg_mp_region_cfg1 mp_region_cfg1;
  rand flash_ctrl_reg_mp_region_cfg2 mp_region_cfg2;
  rand flash_ctrl_reg_mp_region_cfg3 mp_region_cfg3;
  rand flash_ctrl_reg_mp_region_cfg4 mp_region_cfg4;
  rand flash_ctrl_reg_mp_region_cfg5 mp_region_cfg5;
  rand flash_ctrl_reg_mp_region_cfg6 mp_region_cfg6;
  rand flash_ctrl_reg_mp_region_cfg7 mp_region_cfg7;
  rand flash_ctrl_reg_default_region default_region;
  rand flash_ctrl_reg_bank_cfg_regwen bank_cfg_regwen;
  rand flash_ctrl_reg_mp_bank_cfg mp_bank_cfg;
  rand flash_ctrl_reg_op_status op_status;
  rand flash_ctrl_reg_status status;
  rand flash_ctrl_reg_scratch scratch;
  rand flash_ctrl_reg_fifo_lvl fifo_lvl;
  // memories
  rand flash_ctrl_mem_prog_fifo prog_fifo;
  rand flash_ctrl_mem_rd_fifo rd_fifo;

  `uvm_object_utils(flash_ctrl_reg_block)

  function new(string name = "flash_ctrl_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    intr_state = flash_ctrl_reg_intr_state::type_id::create("intr_state");
    intr_state.configure(.blk_parent(this));
    intr_state.build();
    default_map.add_reg(.rg(intr_state),
                        .offset(32'h0),
                        .rights("RW"));
    intr_enable = flash_ctrl_reg_intr_enable::type_id::create("intr_enable");
    intr_enable.configure(.blk_parent(this));
    intr_enable.build();
    default_map.add_reg(.rg(intr_enable),
                        .offset(32'h4),
                        .rights("RW"));
    intr_test = flash_ctrl_reg_intr_test::type_id::create("intr_test");
    intr_test.configure(.blk_parent(this));
    intr_test.build();
    default_map.add_reg(.rg(intr_test),
                        .offset(32'h8),
                        .rights("WO"));
    control = flash_ctrl_reg_control::type_id::create("control");
    control.configure(.blk_parent(this));
    control.build();
    default_map.add_reg(.rg(control),
                        .offset(32'hc),
                        .rights("RW"));
    addr = flash_ctrl_reg_addr::type_id::create("addr");
    addr.configure(.blk_parent(this));
    addr.build();
    default_map.add_reg(.rg(addr),
                        .offset(32'h10),
                        .rights("RW"));
    region_cfg_regwen = flash_ctrl_reg_region_cfg_regwen::type_id::create("region_cfg_regwen");
    region_cfg_regwen.configure(.blk_parent(this));
    region_cfg_regwen.build();
    default_map.add_reg(.rg(region_cfg_regwen),
                        .offset(32'h14),
                        .rights("RW"));
    mp_region_cfg0 = flash_ctrl_reg_mp_region_cfg0::type_id::create("mp_region_cfg0");
    mp_region_cfg0.configure(.blk_parent(this));
    mp_region_cfg0.build();
    default_map.add_reg(.rg(mp_region_cfg0),
                        .offset(32'h18),
                        .rights("RW"));
    mp_region_cfg1 = flash_ctrl_reg_mp_region_cfg1::type_id::create("mp_region_cfg1");
    mp_region_cfg1.configure(.blk_parent(this));
    mp_region_cfg1.build();
    default_map.add_reg(.rg(mp_region_cfg1),
                        .offset(32'h1c),
                        .rights("RW"));
    mp_region_cfg2 = flash_ctrl_reg_mp_region_cfg2::type_id::create("mp_region_cfg2");
    mp_region_cfg2.configure(.blk_parent(this));
    mp_region_cfg2.build();
    default_map.add_reg(.rg(mp_region_cfg2),
                        .offset(32'h20),
                        .rights("RW"));
    mp_region_cfg3 = flash_ctrl_reg_mp_region_cfg3::type_id::create("mp_region_cfg3");
    mp_region_cfg3.configure(.blk_parent(this));
    mp_region_cfg3.build();
    default_map.add_reg(.rg(mp_region_cfg3),
                        .offset(32'h24),
                        .rights("RW"));
    mp_region_cfg4 = flash_ctrl_reg_mp_region_cfg4::type_id::create("mp_region_cfg4");
    mp_region_cfg4.configure(.blk_parent(this));
    mp_region_cfg4.build();
    default_map.add_reg(.rg(mp_region_cfg4),
                        .offset(32'h28),
                        .rights("RW"));
    mp_region_cfg5 = flash_ctrl_reg_mp_region_cfg5::type_id::create("mp_region_cfg5");
    mp_region_cfg5.configure(.blk_parent(this));
    mp_region_cfg5.build();
    default_map.add_reg(.rg(mp_region_cfg5),
                        .offset(32'h2c),
                        .rights("RW"));
    mp_region_cfg6 = flash_ctrl_reg_mp_region_cfg6::type_id::create("mp_region_cfg6");
    mp_region_cfg6.configure(.blk_parent(this));
    mp_region_cfg6.build();
    default_map.add_reg(.rg(mp_region_cfg6),
                        .offset(32'h30),
                        .rights("RW"));
    mp_region_cfg7 = flash_ctrl_reg_mp_region_cfg7::type_id::create("mp_region_cfg7");
    mp_region_cfg7.configure(.blk_parent(this));
    mp_region_cfg7.build();
    default_map.add_reg(.rg(mp_region_cfg7),
                        .offset(32'h34),
                        .rights("RW"));
    default_region = flash_ctrl_reg_default_region::type_id::create("default_region");
    default_region.configure(.blk_parent(this));
    default_region.build();
    default_map.add_reg(.rg(default_region),
                        .offset(32'h38),
                        .rights("RW"));
    bank_cfg_regwen = flash_ctrl_reg_bank_cfg_regwen::type_id::create("bank_cfg_regwen");
    bank_cfg_regwen.configure(.blk_parent(this));
    bank_cfg_regwen.build();
    default_map.add_reg(.rg(bank_cfg_regwen),
                        .offset(32'h3c),
                        .rights("RW"));
    mp_bank_cfg = flash_ctrl_reg_mp_bank_cfg::type_id::create("mp_bank_cfg");
    mp_bank_cfg.configure(.blk_parent(this));
    mp_bank_cfg.build();
    default_map.add_reg(.rg(mp_bank_cfg),
                        .offset(32'h40),
                        .rights("RW"));
    op_status = flash_ctrl_reg_op_status::type_id::create("op_status");
    op_status.configure(.blk_parent(this));
    op_status.build();
    default_map.add_reg(.rg(op_status),
                        .offset(32'h44),
                        .rights("RW"));
    status = flash_ctrl_reg_status::type_id::create("status");
    status.configure(.blk_parent(this));
    status.build();
    default_map.add_reg(.rg(status),
                        .offset(32'h48),
                        .rights("RO"));
    scratch = flash_ctrl_reg_scratch::type_id::create("scratch");
    scratch.configure(.blk_parent(this));
    scratch.build();
    default_map.add_reg(.rg(scratch),
                        .offset(32'h4c),
                        .rights("RW"));
    fifo_lvl = flash_ctrl_reg_fifo_lvl::type_id::create("fifo_lvl");
    fifo_lvl.configure(.blk_parent(this));
    fifo_lvl.build();
    default_map.add_reg(.rg(fifo_lvl),
                        .offset(32'h50),
                        .rights("RW"));

    // create memories
    prog_fifo = flash_ctrl_mem_prog_fifo::type_id::create("prog_fifo");
    prog_fifo.configure(.parent(this));
    default_map.add_mem(.mem(prog_fifo),
                        .offset(32'h54),
                        .rights("WO"));
    rd_fifo = flash_ctrl_mem_rd_fifo::type_id::create("rd_fifo");
    rd_fifo.configure(.parent(this));
    default_map.add_mem(.mem(rd_fifo),
                        .offset(32'h58),
                        .rights("RO"));
  endfunction : build

endclass : flash_ctrl_reg_block
