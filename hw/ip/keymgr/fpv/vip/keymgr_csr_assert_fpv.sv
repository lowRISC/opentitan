// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// FPV CSR read and write assertions auto-generated by `reggen` containing data structure
// Do Not Edit directly


`include "prim_assert.sv"

// Block: keymgr
module keymgr_csr_assert_fpv import tlul_pkg::*; (
  input clk_i,
  input rst_ni,

  //tile link ports
  input tl_h2d_t h2d,
  input tl_d2h_t d2h
);

  // mask register to convert byte to bit
  logic [31:0] a_mask_bit;

  assign a_mask_bit[7:0]   = h2d.a_mask[0] ? '1 : '0;
  assign a_mask_bit[15:8]  = h2d.a_mask[1] ? '1 : '0;
  assign a_mask_bit[23:16] = h2d.a_mask[2] ? '1 : '0;
  assign a_mask_bit[31:24] = h2d.a_mask[3] ? '1 : '0;

  // declare common read and write sequences
  sequence device_wr_S(logic [7:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {PutFullData, PutPartialData} && h2d.a_valid && h2d.d_ready && !d2h.d_valid;
  endsequence

  sequence device_rd_S(logic [7:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {Get} && h2d.a_valid && h2d.d_ready && !d2h.d_valid;
  endsequence

  // declare common read and write properties
  property wr_P(int width, bit [7:0] addr, bit [31:0] compare_data, bit regen = 1);
    logic [31:0] id;
    logic [width:0] data;
    (device_wr_S(addr),id = h2d.a_source, data = h2d.a_data & a_mask_bit) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && compare_data == data) || !regen)));
  endproperty

  property wr_ext_P(int width, bit [7:0] addr, bit [31:0] compare_data, bit regen = 1);
    logic [31:0] id;
    logic [width:0] data;
    logic [width:0] compare_value;
    (device_wr_S(addr),id = h2d.a_source, data = h2d.a_data & a_mask_bit,
        compare_value = compare_data) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && compare_value == data) || !regen)));
  endproperty

  property rd_P(int width, bit [7:0] addr, bit [31:0] compare_data);
    logic [31:0] id;
    logic [width:0] data;
    (device_rd_S(addr), id = h2d.a_source, data = $past(compare_data)) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && d2h.d_data == data))));
  endproperty

  property rd_ext_P(int width, bit [7:0] addr, bit [31:0] compare_data);
    logic [31:0] id;
    logic [width:0] data;
    (device_rd_S(addr), id = h2d.a_source, data = compare_data) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && d2h.d_data == data))));
  endproperty

  property wr_regen_stable_P(regen, compare_data);
    (!regen && $stable(regen)) |-> $stable(compare_data);
  endproperty

// for all the regsters, declare assertion

  // read/write assertions for register: intr_state
  `ASSERT(intr_state_wr_A, wr_P(0, 8'h0, i_keymgr.reg2hw.intr_state.q, 0))
  `ASSERT(intr_state_rd_A, rd_P(0, 8'h0, i_keymgr.hw2reg.intr_state.d))

  // read/write assertions for register: intr_enable
  `ASSERT(intr_enable_wr_A, wr_P(0, 8'h4, i_keymgr.reg2hw.intr_enable.q, 0))
  `ASSERT(intr_enable_rd_A, rd_P(0, 8'h4, i_keymgr.reg2hw.intr_enable.q))

  // read/write assertions for register: intr_test
  `ASSERT(intr_test_wr_A, wr_ext_P(0, 8'h8, i_keymgr.reg2hw.intr_test.q, 0))

  // read/write assertions for register: cfgen
  `ASSERT(cfgen_wr_A, wr_ext_P(0, 8'hc, i_keymgr.reg2hw.cfgen.q, 0))
  `ASSERT(cfgen_rd_A, rd_ext_P(0, 8'hc, i_keymgr.hw2reg.cfgen.d))

  // read/write assertions for register: control
  `ASSERT(control_wr_A, wr_P(13, 8'h10, i_keymgr.reg2hw.control.q, i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(control_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, i_keymgr.reg2hw.control.q))
  `ASSERT(control_rd_A, rd_P(13, 8'h10, i_keymgr.hw2reg.control.d))

  // read/write assertions for register: rom_ext_desc_en
  `ASSERT(rom_ext_desc_en_wr_A, wr_P(1, 8'h14, i_keymgr.i_reg_top.rom_ext_desc_en_we, 0))
  `ASSERT(rom_ext_desc_en_rd_A, rd_P(1, 8'h14, i_keymgr.i_reg_top.rom_ext_desc_en_qs))

  // define local fpv variable for the multi_reg
  logic [127:0] rom_ext_desc_q_fpv;
  for (genvar s = 0; s <= 4-1; s++) begin : gen_rom_ext_desc_rd
    assign rom_ext_desc_q_fpv[((s+1)*32-1):s*32] = i_keymgr.reg2hw.rom_ext_desc[s].q;
  end

  // read/write assertions for register: rom_ext_desc0
  `ASSERT(rom_ext_desc0_wr_A, wr_P(31, 8'h18, rom_ext_desc_q_fpv[31:0], 0))
  `ASSERT(rom_ext_desc0_rd_A, rd_P(31, 8'h18, rom_ext_desc_q_fpv[31:0]))

  // read/write assertions for register: rom_ext_desc1
  `ASSERT(rom_ext_desc1_wr_A, wr_P(31, 8'h1c, rom_ext_desc_q_fpv[63:32], 0))
  `ASSERT(rom_ext_desc1_rd_A, rd_P(31, 8'h1c, rom_ext_desc_q_fpv[63:32]))

  // read/write assertions for register: rom_ext_desc2
  `ASSERT(rom_ext_desc2_wr_A, wr_P(31, 8'h20, rom_ext_desc_q_fpv[95:64], 0))
  `ASSERT(rom_ext_desc2_rd_A, rd_P(31, 8'h20, rom_ext_desc_q_fpv[95:64]))

  // read/write assertions for register: rom_ext_desc3
  `ASSERT(rom_ext_desc3_wr_A, wr_P(31, 8'h24, rom_ext_desc_q_fpv[127:96], 0))
  `ASSERT(rom_ext_desc3_rd_A, rd_P(31, 8'h24, rom_ext_desc_q_fpv[127:96]))

  // define local fpv variable for the multi_reg
  logic [127:0] software_binding_q_fpv;
  for (genvar s = 0; s <= 4-1; s++) begin : gen_software_binding_rd
    assign software_binding_q_fpv[((s+1)*32-1):s*32] = i_keymgr.reg2hw.software_binding[s].q;
  end

  // read/write assertions for register: software_binding0
  `ASSERT(software_binding0_wr_A, wr_P(31, 8'h28, software_binding_q_fpv[31:0], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(software_binding0_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, software_binding_q_fpv[31:0]))
  `ASSERT(software_binding0_rd_A, rd_P(31, 8'h28, software_binding_q_fpv[31:0]))

  // read/write assertions for register: software_binding1
  `ASSERT(software_binding1_wr_A, wr_P(31, 8'h2c, software_binding_q_fpv[63:32], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(software_binding1_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, software_binding_q_fpv[63:32]))
  `ASSERT(software_binding1_rd_A, rd_P(31, 8'h2c, software_binding_q_fpv[63:32]))

  // read/write assertions for register: software_binding2
  `ASSERT(software_binding2_wr_A, wr_P(31, 8'h30, software_binding_q_fpv[95:64], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(software_binding2_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, software_binding_q_fpv[95:64]))
  `ASSERT(software_binding2_rd_A, rd_P(31, 8'h30, software_binding_q_fpv[95:64]))

  // read/write assertions for register: software_binding3
  `ASSERT(software_binding3_wr_A, wr_P(31, 8'h34, software_binding_q_fpv[127:96], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(software_binding3_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, software_binding_q_fpv[127:96]))
  `ASSERT(software_binding3_rd_A, rd_P(31, 8'h34, software_binding_q_fpv[127:96]))

  // define local fpv variable for the multi_reg
  logic [127:0] key_id_q_fpv;
  for (genvar s = 0; s <= 4-1; s++) begin : gen_key_id_rd
    assign key_id_q_fpv[((s+1)*32-1):s*32] = i_keymgr.reg2hw.key_id[s].q;
  end

  // read/write assertions for register: key_id0
  `ASSERT(key_id0_wr_A, wr_P(31, 8'h38, key_id_q_fpv[31:0], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(key_id0_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, key_id_q_fpv[31:0]))
  `ASSERT(key_id0_rd_A, rd_P(31, 8'h38, key_id_q_fpv[31:0]))

  // read/write assertions for register: key_id1
  `ASSERT(key_id1_wr_A, wr_P(31, 8'h3c, key_id_q_fpv[63:32], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(key_id1_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, key_id_q_fpv[63:32]))
  `ASSERT(key_id1_rd_A, rd_P(31, 8'h3c, key_id_q_fpv[63:32]))

  // read/write assertions for register: key_id2
  `ASSERT(key_id2_wr_A, wr_P(31, 8'h40, key_id_q_fpv[95:64], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(key_id2_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, key_id_q_fpv[95:64]))
  `ASSERT(key_id2_rd_A, rd_P(31, 8'h40, key_id_q_fpv[95:64]))

  // read/write assertions for register: key_id3
  `ASSERT(key_id3_wr_A, wr_P(31, 8'h44, key_id_q_fpv[127:96], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(key_id3_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, key_id_q_fpv[127:96]))
  `ASSERT(key_id3_rd_A, rd_P(31, 8'h44, key_id_q_fpv[127:96]))

  // define local fpv variable for the multi_reg
  logic [127:0] salt_q_fpv;
  for (genvar s = 0; s <= 4-1; s++) begin : gen_salt_rd
    assign salt_q_fpv[((s+1)*32-1):s*32] = i_keymgr.reg2hw.salt[s].q;
  end

  // read/write assertions for register: salt0
  `ASSERT(salt0_wr_A, wr_P(31, 8'h48, salt_q_fpv[31:0], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(salt0_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, salt_q_fpv[31:0]))
  `ASSERT(salt0_rd_A, rd_P(31, 8'h48, salt_q_fpv[31:0]))

  // read/write assertions for register: salt1
  `ASSERT(salt1_wr_A, wr_P(31, 8'h4c, salt_q_fpv[63:32], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(salt1_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, salt_q_fpv[63:32]))
  `ASSERT(salt1_rd_A, rd_P(31, 8'h4c, salt_q_fpv[63:32]))

  // read/write assertions for register: salt2
  `ASSERT(salt2_wr_A, wr_P(31, 8'h50, salt_q_fpv[95:64], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(salt2_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, salt_q_fpv[95:64]))
  `ASSERT(salt2_rd_A, rd_P(31, 8'h50, salt_q_fpv[95:64]))

  // read/write assertions for register: salt3
  `ASSERT(salt3_wr_A, wr_P(31, 8'h54, salt_q_fpv[127:96], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(salt3_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, salt_q_fpv[127:96]))
  `ASSERT(salt3_rd_A, rd_P(31, 8'h54, salt_q_fpv[127:96]))

  // define local fpv variable for the multi_reg
  logic [31:0] key_version_q_fpv;
  for (genvar s = 0; s <= 1-1; s++) begin : gen_key_version_rd
    assign key_version_q_fpv[((s+1)*32-1):s*32] = i_keymgr.reg2hw.key_version[s].q;
  end

  // read/write assertions for register: key_version
  `ASSERT(key_version_wr_A, wr_P(31, 8'h58, key_version_q_fpv[31:0], i_keymgr.i_reg_top.cfgen_qs))
  `ASSERT(key_version_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.cfgen_qs, key_version_q_fpv[31:0]))
  `ASSERT(key_version_rd_A, rd_P(31, 8'h58, key_version_q_fpv[31:0]))

  // read/write assertions for register: max_creator_key_ver_en
  `ASSERT(max_creator_key_ver_en_wr_A, wr_P(0, 8'h5c, i_keymgr.i_reg_top.max_creator_key_ver_en_we, 0))
  `ASSERT(max_creator_key_ver_en_rd_A, rd_P(0, 8'h5c, i_keymgr.i_reg_top.max_creator_key_ver_en_qs))

  // read/write assertions for register: max_creator_key_ver
  `ASSERT(max_creator_key_ver_wr_A, wr_P(31, 8'h60, i_keymgr.reg2hw.max_creator_key_ver.q, i_keymgr.i_reg_top.max_creator_key_ver_en_qs))
  `ASSERT(max_creator_key_ver_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.max_creator_key_ver_en_qs, i_keymgr.reg2hw.max_creator_key_ver.q))
  `ASSERT(max_creator_key_ver_rd_A, rd_P(31, 8'h60, i_keymgr.reg2hw.max_creator_key_ver.q))

  // read/write assertions for register: max_owner_int_key_ver_en
  `ASSERT(max_owner_int_key_ver_en_wr_A, wr_P(0, 8'h64, i_keymgr.i_reg_top.max_owner_int_key_ver_en_we, 0))
  `ASSERT(max_owner_int_key_ver_en_rd_A, rd_P(0, 8'h64, i_keymgr.i_reg_top.max_owner_int_key_ver_en_qs))

  // read/write assertions for register: max_owner_int_key_ver
  `ASSERT(max_owner_int_key_ver_wr_A, wr_P(31, 8'h68, i_keymgr.reg2hw.max_owner_int_key_ver.q, i_keymgr.i_reg_top.max_owner_int_key_ver_en_qs))
  `ASSERT(max_owner_int_key_ver_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.max_owner_int_key_ver_en_qs, i_keymgr.reg2hw.max_owner_int_key_ver.q))
  `ASSERT(max_owner_int_key_ver_rd_A, rd_P(31, 8'h68, i_keymgr.reg2hw.max_owner_int_key_ver.q))

  // read/write assertions for register: max_owner_key_ver_en
  `ASSERT(max_owner_key_ver_en_wr_A, wr_P(0, 8'h6c, i_keymgr.i_reg_top.max_owner_key_ver_en_we, 0))
  `ASSERT(max_owner_key_ver_en_rd_A, rd_P(0, 8'h6c, i_keymgr.i_reg_top.max_owner_key_ver_en_qs))

  // read/write assertions for register: max_owner_key_ver
  `ASSERT(max_owner_key_ver_wr_A, wr_P(31, 8'h70, i_keymgr.reg2hw.max_owner_key_ver.q, i_keymgr.i_reg_top.max_owner_key_ver_en_qs))
  `ASSERT(max_owner_key_ver_stable_A, wr_regen_stable_P(i_keymgr.i_reg_top.max_owner_key_ver_en_qs, i_keymgr.reg2hw.max_owner_key_ver.q))
  `ASSERT(max_owner_key_ver_rd_A, rd_P(31, 8'h70, i_keymgr.reg2hw.max_owner_key_ver.q))

  // define local fpv variable for the multi_reg
  logic [255:0] sw_share0_output_d_fpv;
  for (genvar s = 0; s <= 8-1; s++) begin : gen_sw_share0_output_wr
    assign sw_share0_output_d_fpv[(s*32-1):s] = i_keymgr.hw2reg.sw_share0_output[s].d;
  end

  // read/write assertions for register: sw_share0_output0
  `ASSERT(sw_share0_output0_rd_A, rd_P(31, 8'h74, sw_share0_output_d_fpv[31:0]))

  // read/write assertions for register: sw_share0_output1
  `ASSERT(sw_share0_output1_rd_A, rd_P(31, 8'h78, sw_share0_output_d_fpv[63:32]))

  // read/write assertions for register: sw_share0_output2
  `ASSERT(sw_share0_output2_rd_A, rd_P(31, 8'h7c, sw_share0_output_d_fpv[95:64]))

  // read/write assertions for register: sw_share0_output3
  `ASSERT(sw_share0_output3_rd_A, rd_P(31, 8'h80, sw_share0_output_d_fpv[127:96]))

  // read/write assertions for register: sw_share0_output4
  `ASSERT(sw_share0_output4_rd_A, rd_P(31, 8'h84, sw_share0_output_d_fpv[159:128]))

  // read/write assertions for register: sw_share0_output5
  `ASSERT(sw_share0_output5_rd_A, rd_P(31, 8'h88, sw_share0_output_d_fpv[191:160]))

  // read/write assertions for register: sw_share0_output6
  `ASSERT(sw_share0_output6_rd_A, rd_P(31, 8'h8c, sw_share0_output_d_fpv[223:192]))

  // read/write assertions for register: sw_share0_output7
  `ASSERT(sw_share0_output7_rd_A, rd_P(31, 8'h90, sw_share0_output_d_fpv[255:224]))

  // define local fpv variable for the multi_reg
  logic [255:0] sw_share1_output_d_fpv;
  for (genvar s = 0; s <= 8-1; s++) begin : gen_sw_share1_output_wr
    assign sw_share1_output_d_fpv[(s*32-1):s] = i_keymgr.hw2reg.sw_share1_output[s].d;
  end

  // read/write assertions for register: sw_share1_output0
  `ASSERT(sw_share1_output0_rd_A, rd_P(31, 8'h94, sw_share1_output_d_fpv[31:0]))

  // read/write assertions for register: sw_share1_output1
  `ASSERT(sw_share1_output1_rd_A, rd_P(31, 8'h98, sw_share1_output_d_fpv[63:32]))

  // read/write assertions for register: sw_share1_output2
  `ASSERT(sw_share1_output2_rd_A, rd_P(31, 8'h9c, sw_share1_output_d_fpv[95:64]))

  // read/write assertions for register: sw_share1_output3
  `ASSERT(sw_share1_output3_rd_A, rd_P(31, 8'ha0, sw_share1_output_d_fpv[127:96]))

  // read/write assertions for register: sw_share1_output4
  `ASSERT(sw_share1_output4_rd_A, rd_P(31, 8'ha4, sw_share1_output_d_fpv[159:128]))

  // read/write assertions for register: sw_share1_output5
  `ASSERT(sw_share1_output5_rd_A, rd_P(31, 8'ha8, sw_share1_output_d_fpv[191:160]))

  // read/write assertions for register: sw_share1_output6
  `ASSERT(sw_share1_output6_rd_A, rd_P(31, 8'hac, sw_share1_output_d_fpv[223:192]))

  // read/write assertions for register: sw_share1_output7
  `ASSERT(sw_share1_output7_rd_A, rd_P(31, 8'hb0, sw_share1_output_d_fpv[255:224]))

  // read/write assertions for register: working_state
  `ASSERT(working_state_rd_A, rd_P(2, 8'hb4, i_keymgr.hw2reg.working_state.d))

  // read/write assertions for register: op_status
  `ASSERT(op_status_rd_A, rd_P(7, 8'hb8, i_keymgr.hw2reg.op_status.d))

endmodule
