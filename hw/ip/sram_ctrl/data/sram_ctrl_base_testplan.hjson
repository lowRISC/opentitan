// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{
  name: "sram_ctrl"
  // TODO: remove the common testplans if not applicable
  import_testplans: ["hw/dv/tools/dvsim/testplans/csr_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/alert_test_testplan.hjson",
                     // TODO uncomment once supported
                     //"hw/dv/tools/dvsim/testplans/stress_all_with_reset_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/tl_device_access_types_testplan.hjson"]
  testpoints: [
    {
      name: smoke
      desc: '''
            This test performs basic SRAM initialization procedure and tests basic memory function:
              - Initialize SRAM memory to zero
              - Perform some random memory operations, verify that they all succeed with an
                all-zero key and nonce
              - Request a new scrambling key from the OTP interface and verify that:
                - A valid key is received
                - The key seed used by OTP is valid
              - Perform a number of random memory accesses to the SRAM, verify that all accesses
                were executed correctly using the `mem_bkdr_util`
            '''
      milestone: V1
      tests: ["{variant}_smoke"]
    }
    {
      name: multiple_keys
      desc: '''
            In this test we request multiple scrambling keys from OTP and verify that the memory
            scrambling is performed correctly even with multiple seeds.
            Perform the following steps:
              - Initialize the memory to zero
              - Perform some random memory operations, verify that they succeed with an
                all-zero key and nonce
              - Repeat the following steps a number of times:
                - Get a scrambling key from the OTP interface
                - Perform a number of random memory accesses to the SRAM
              - Verify that all memory access succeed even if the scrambling key changes at arbitrary
                intervals
            '''
      milestone: V2
      tests: ["{variant}_multiple_keys"]
    }
    {
      name: stress_pipeline
      desc: '''
            This test is the same as the multiple_keys_test but we now do a series of back-to-back
            memory accesses at each random address in order to create read/write conflicts and
            stress the encryption pipeline.
            '''
      milestone: V2
      tests: ["{variant}_stress_pipeline"]
    }
    {
      name: bijection
      desc: '''
            In this test we iterate through each address in the SRAM memory.
            For each address write the current address to the SRAM.

            After this is done, read every address and check that the stored data is equivalent to
            the current address.

            This will verify that the SRAM encryption mechanism is actually bijective, and will not
            cause any address collisions.

            e.g. if the encryption scheme causes addresses 0x1 and 0x2 to collide and we write 0x1
                 and 0x2 respectively, we will see a return value of 0x2 when we read from 0x1,
                 instead of the expected 0x1.

            This process will be repeated for a number of new key seeds.
            '''
      milestone: V2
      tests: ["{variant}_bijection"]
    }
    {
      name: access_during_key_req
      desc: '''
            This test is the same as the multiple_keys test, except we make sure to sequence some
            memory transactions while a key request to OTP is still pending.
            Verify that these transactions are completely ignored by the memory.

            TODO: Behavior might change in future to throw an error instead of ignore,
                  should be reflected in TB.
            '''
      milestone: V2
      tests: ["{variant}_access_during_key_req"]
    }
    {
      name: lc_escalation
      desc: '''
            This test is the same as the multiple_keys test, except we now randomly assert the
            lifecycle escalation signal.
            Upon sending an escalation request, we verify that the DUT has properly latched it,
            and all scrambling state has been reset.
            In this state, we perform some memory accesses, they should all be blocked and not go
            through.
            We then issue a reset to the SRAM to get it out of the terminal state, and issue a
            couple of memory accesses just to make sure everything is still in working order.
            '''
      milestone: V2
      tests: ["{variant}_lc_escalation"]
    }
    {
      name: executable
      desc: '''
            This test is intended to test the "execute from SRAM" feature, in which TLUL memory
            transactions tagged with the `InstrType` value in the user bits are allowed to be
            handled by the SRAM memory.

            This behavior is enabled by either setting the `exec` CSR to 1 or by driving a second
            lifecycle input to `On` - both of these are muxed between with a `otp_en_sram_ifetch_i`
            input from the OTP controller.

            If this functionality is disabled, any memory transaction NOT tagged as `DataType` should
            error out, however `DataType` transactions should be successful when the SRAM is
            configured to be executable.
            '''
      milestone: V2
      tests: ["{variant}_executable"]
    }
    {
      name: partial_access
      desc: '''
            This test is intended to test a lot of partial accesses with random addresses or
            back-to-back accesses.

            Reuse the `smoke` and `stress_pipeline` by setting `partial_access_pct` = 90%
            '''
      milestone: V2
      tests: ["{variant}_partial_access", "{variant}_partial_access_b2b"]
    }
    {
      name: max_throughput
      desc: '''
            This test is intended to test the max throughput of the SRAM.

            Without partial write, if driver doesn't introduce any delay, it takes N+1 cycles to
            finish N SRAM read/write accesses.
            With partial write, it needs 2 extra cycles per partial write.
            '''
      milestone: V2
      tests: ["{variant}_max_throughput", "{variant}_throughput_w_partial_write"]
    }
    {
      name: parity
      desc: '''
            TODO - to be changed into an ECC test

            This test is the same as the multiple_keys test, except we randomly inject a parity
            error into the memory (TODO: figure out how exactly to do this).
            Verify that the SRAM reports the error and the faulty address correctly, and that the
            alert is sent out properly.
            We then perform some memory accesses and verify that none of them go through.
            This error is terminal, so like the lc_escalation test, issue a reset and then perform
            some memory accesses to make sure everything comes back online correctly.
            '''
      milestone: V3
      tests: ["{variant}_parity"]
    }
  ]

  covergroups: [
    {
      name: subword_access_cg
      desc: '''
            Covers that all possible types of subword accesses (both reads and writes) have been
            performed.
            '''
    }
    {
      name: access_during_key_req_cg
      desc: '''
            Covers that SRAM handles memory accesses during key requests.
            '''
    }
    {
      name: key_seed_valid_cg
      desc: '''
            Covers SRAM receiving a key from OTP in Off/On states,
            with both valid and invalid key seeds.
            '''
    }
    {
      name: lc_escalation_rst_cg
      desc: '''
            Covers de-assertion of LC escalation input before/after/during a reset trigger
            to get SRAM out of terminal state.
            '''
    }
    {
      name: raw_hazard_cg
      desc: '''
            Covers that the scrambling RAM sees address collisions on RAW hazards
            (indicating that b2b RAW access has been made to the same memory line).
            '''
    }
    {
      name: b2b_access_types_cg
      desc: '''
            Covers that any combination of access types (R/R, R/W, W/R, W/W) can be present in b2b
            transaction scenarios.
            '''
    }
    {
      name: executable_cg
      desc: '''
            Covers the various important scenarios that can enable SRAM executability.
            '''
    }
  ]
}
