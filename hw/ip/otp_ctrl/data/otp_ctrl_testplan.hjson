// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{
  name: "otp_ctrl"
  import_testplans: ["hw/dv/tools/dvsim/testplans/csr_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/mem_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/intr_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/alert_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/tl_device_access_types_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/stress_all_with_reset_testplan.hjson"]
  testpoints: [
    {
      name: wake_up
      desc: '''
            Wake_up test walks through otp_ctrl's power-on initialization, read, program, and
            digest functionalities.

            - drive pwrmgr's request pin to trigger OTP initialization after reset, check status
              after OTP initialization
            - write all-ones to a random address within OTP partition 0, wait until this operation
              completes
            - read out the random selected write address, check if the readout value is all-ones
            - trigger a digest calculation for a Software partition, check if the OtpError
              interrupt is set
            - trigger a digest calculation for a non-software partition, expect operation completes
              without the OtpError interrupt
            - read out secrets through the hardware interfaces
            '''
      milestone: V1
      tests: ["otp_ctrl_wake_up"]
    }
    {
      name: smoke
      desc: '''
            OTP_CTRL smoke test provisions and locks partitions.

            - drive pwrmgr's request pin to trigger OTP initialization after reset, check status
              after OTP initialization
            - randomly read out keys pertaining to `key_manager`, `flash`, `sram`, `otbn`
            - randomly issue LC program request
            - write random values to random addresses within each OTP partition
            - read out the random selected write addresses, check if the readout values are expected
            - during read and write operations, check if direct_access_regwen is correctly set by HW
            - perform a system-level reset and check corresponding CSRs are set correctly
            - lock all partitions except life_cycle by triggering digest calculations
            - read back and verify the digest
            - perform a system-level reset to verify the corresponding CSRs exposing the digests
              have been populated
            '''
      milestone: V1
      tests: ["otp_ctrl_smoke"]
    }
    {
      name: dai_access_partition_walk
      desc: '''
            Similar to UVM's memory walk test, this test ensures every address in each partition
            can be accessed successfully via DAI and TLUL interfacs according to its access policy.
            '''
      milestone: V2
      tests: ["otp_ctrl_partition_walk"]
    }
    {
      name: init_fail
      desc: '''
            Based on OTP_CTRL smoke test, this test creates OTP_CTRL's initialization failure:
            - write and read OTP memory via DAI interface
            - randomly issue DAI digest command to lock HW partitions
            - keep writing to OTP memory via DAI interface without asserting reset
            - if digests are not locked, backdoor inject ECC correctable or uncorrectable errors
            - issue reset and power initialization
            - if the injected errors are all correctable errors, disable the `lc_bypass_chk_en`
              after LC program request to create an LC partition check failure

            If fatal error is triggered, this test will check:
            - OTP initialization failure triggers fatal alert
            - `status`, `intr_state`, `err_code` CSRs reflect correct fatal error

            If OTP initialization finished without any fatal error, this test will check:
            - OTP initialization finishes with power init output goes to 1
            - `status`, `intr_state`, `err_code` CSRs reflect ECC correctable error
            '''
      milestone: V2
      tests: ["otp_ctrl_init_fail"]
    }
    {
      name: partition_check
      desc: '''
            Randomly program the partition check related CSRs including:
            - `check_timeout`
            - `integrity_check_period`
            - `consistency_check_period`
            - `check_trigger`

            Create a failure scenario by randomly picking one of these three methods:
            - inject ECC errors into the OTP macro via backdoor
            - set the `check_timeout` CSR with a very small value
            - write to a random OTP partition after digest is issued but before reset is asserted

            **Checks**:
            - the corresponding alerts are triggered
            - the error_code register is set correctly
            Note that due to limited simulation time, for background checks, this test only write
            random value that is less than 20 to the check period.
            '''
      milestone: V2
      tests: ["otp_ctrl_check_fail", "otp_ctrl_background_chks"]
    }
    {
      name: regwen_during_otp_init
      desc: '''
            The `direct_access_regwen` is a RO register which controls the write-enable of other
            reigsters. It is not verified by the common CSR tests. HW sets it to 0 when the DAI
            interface is busy.

            Stimulus and checks:
            - randomly read `direct_access_regwen` and verify that it returns 0 during OTP
              initialization
            - verify that the writes to the registers controlled by it do not go through during OTP
              initialization
            '''
      milestone: V2
      tests: ["otp_ctrl_regwen"]
    }
    {
      name: partition_lock
      desc: '''
            This test will cover two methods of locking read and write: digest calculation and CSR
            write. After locking the partitions, issue read or program sequences and check if the
            operations are locked correctly, and check if the `AccessError` is set.
            '''
      milestone: V2
      tests: ["otp_ctrl_dai_lock"]
    }
    {
      name: interface_key_check
      desc: '''
            OTP_CTRL will generate keys to `flash`, `sram`, and `otbn` upon their requests.
            Based on the DAI access sequence, this test will run key requests sequence in
            parallel, and check if correct keys are generated.
            '''
      milestone: V2
      tests: ["otp_ctrl_parallel_key_req"]
    }
    {
      name: lc_interactions
      desc: '''
            Verify the procotols between OTP_CTRL and LC_CTRL. Based on the DAI access sequence,
            run the following sequences in parallel:

            - request a LC state transition via the programming interface
            - enable the `lc_escalation_en` signal

            **Checks**:
            - if the LC program request has `AccessError`, check the LC program response sets
              the `error` bit to 1
            - if `lc_escalation_en` is enabled, verify that alert is triggered and OTP_CTRL entered
              terminal state
            '''
      milestone: V2
      tests: ["otp_ctrl_parallel_lc_req", "otp_ctrl_parallel_lc_esc"]
    }
    { name: otp_dai_errors
      desc: '''
            Based on the otp_dai_lock test, this test will randomly run the following OTP errors:
            - DAI interface writes non-blank OTP address
            - DAI interface accesses LC partition
            - DAI interface writes HW digests
            - DAI interface writes non-empty memory

            **Checks**:
            - `err_code` and `status` CSRs
            - `otp_error` interrupt
            '''
      milestone: V2
      tests: ["otp_ctrl_dai_errs"]
    }
    { name: otp_macro_errors
      desc: '''
            Randomly run the following OTP errors:
            - MacroError
            - MacroEccCorrError
            - MacroEccUncorrError

            **Checks**:
            - `err_code` and `status` CSRs
            - `otp_error` interrupt
            - if the error is unrecoverable, verify that alert is triggered and OTP_CTRL entered
              terminal state
            '''
      milestone: V2
      tests: ["otp_ctrl_macro_errs", "otp_ctrl_macro_invalid_cmd"]
    }
    {
      name: test_access
      desc: '''
            This test checks if the test access to OTP macro is connected correctly.

            **Stimulus and Checks**:
            - read out from the test access window and ensure no error occurs
            '''
      milestone: V2
      tests: ["otp_ctrl_test_access"]
    }
    {
      name: stress_all
      desc: '''
            - combine above sequences in one test to run sequentially, except csr sequence
            - randomly add reset between each sequence
            '''
      milestone: V2
      tests: ["otp_ctrl_stress_all"]
    }
  ]
}
