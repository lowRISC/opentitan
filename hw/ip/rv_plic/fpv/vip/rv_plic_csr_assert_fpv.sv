// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// FPV CSR read and write assertions auto-generated by `reggen` containing data structure
// Do Not Edit directly
// TODO: This automation does not support: shadow reg and regwen reg
// This automation assumes that W1C and W0C are registers with 1 bit per field

`include "prim_assert.sv"

// Block: rv_plic
module rv_plic_csr_assert_fpv import tlul_pkg::*; import rv_plic_reg_pkg::*; (
  input clk_i,
  input rst_ni,

  // tile link ports
  input tl_h2d_t h2d,
  input tl_d2h_t d2h,

  // reg and hw ports
  input rv_plic_reg2hw_t reg2hw,
  input rv_plic_hw2reg_t hw2reg
);

  parameter int DWidth = 32;
  // mask register to convert byte to bit
  logic [DWidth-1:0] a_mask_bit;

  assign a_mask_bit[7:0]   = h2d.a_mask[0] ? '1 : '0;
  assign a_mask_bit[15:8]  = h2d.a_mask[1] ? '1 : '0;
  assign a_mask_bit[23:16] = h2d.a_mask[2] ? '1 : '0;
  assign a_mask_bit[31:24] = h2d.a_mask[3] ? '1 : '0;

  // declare common read and write sequences
  sequence device_wr_S(logic [8:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {PutFullData, PutPartialData} &&
        h2d.a_valid && h2d.d_ready && !d2h.d_valid;
  endsequence

  sequence device_rd_S(logic [8:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {Get} && h2d.a_valid && h2d.d_ready &&
        !d2h.d_valid;
  endsequence

  // declare common read and write properties
  // for homog registers, we check by a reg; for non-homog regs, we check by field.
  // `mask` is used for checking by field. It masks out any act_data that are not within the field
  // `lsb` is used to check non-homog multi_reg. Because we are using a local copy `_fpv` variable
  // to store all the multi-reg within one basefield, we need to shift the `_fpv` value to the
  // correct bits, then compare with read/write exp_data.

  property wr_P(bit [8:0] addr, bit [DWidth-1:0] act_data, bit regen,
                bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_wr_S(addr), id = h2d.a_source, exp_data = h2d.a_data & a_mask_bit & mask) ##1
        first_match(##[0:$] d2h.d_valid && d2h.d_source == id) |->
        (d2h.d_error || (act_data << lsb) == exp_data || !regen);
  endproperty

  // external reg will use one clk cycle to update act_data from external
  property wr_ext_P(bit [8:0] addr, bit [DWidth-1:0] act_data, bit regen,
                    bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_wr_S(addr), id = h2d.a_source, exp_data = h2d.a_data & a_mask_bit & mask) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || ($past(act_data) << lsb) == exp_data || !regen);
  endproperty

  property w1c_P(bit [8:0] addr, bit [DWidth-1:0] act_data, bit regen,
                bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_wr_S(addr), id = h2d.a_source, exp_data = h2d.a_data & a_mask_bit & mask & '0) ##1
        first_match(##[0:$] d2h.d_valid && d2h.d_source == id) |->
        (d2h.d_error || (act_data << lsb) == exp_data || !regen);
  endproperty

  property w1c_ext_P(bit [8:0] addr, bit [DWidth-1:0] act_data, bit regen,
                    bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_wr_S(addr), id = h2d.a_source, exp_data = h2d.a_data & a_mask_bit & mask & '0) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || ($past(act_data) << lsb) == exp_data || !regen);
  endproperty

  property rd_P(bit [8:0] addr, bit [DWidth-1:0] act_data, bit [DWidth-1:0] mask, int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_rd_S(addr), id = h2d.a_source, exp_data = $past(act_data)) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || (d2h.d_data & mask) >> lsb == exp_data);
  endproperty

  property rd_ext_P(bit [8:0] addr, bit [DWidth-1:0] act_data, bit [DWidth-1:0] mask,
      int lsb);
    logic [DWidth-1:0] id, exp_data;
    (device_rd_S(addr), id = h2d.a_source, exp_data = act_data) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || (d2h.d_data & mask) >> lsb == exp_data);
  endproperty

  // read a WO register, always return 0
  property r_wo_P(bit [8:0] addr);
    logic [DWidth-1:0] id;
    (device_rd_S(addr), id = h2d.a_source) ##1
        first_match(##[0:$] (d2h.d_valid && d2h.d_source == id)) |->
        (d2h.d_error || d2h.d_data == 0);
  endproperty

  // TODO: currently not used, will use once support regwen reg
  property wr_regen_stable_P(bit regen, bit [DWidth-1:0] exp_data);
    (!regen && $stable(regen)) |-> $stable(exp_data);
  endproperty


  // define local fpv variable for multi-reg
  logic [31:0] ip_d_fpv;
  for (genvar s = 0; s < 32; s++) begin : gen_ip_q
    assign ip_d_fpv[((s+1)*1-1):s*1] = hw2reg.ip[s].d;
  end

  // assertions for register: ip
  `ASSERT(ip_rd_A, rd_P(9'h0, ip_d_fpv[31:0], 'hffffffff, 0))

  // define local fpv variable for multi-reg
  logic [31:0] le_q_fpv;
  for (genvar s = 0; s < 32; s++) begin : gen_le_q
    assign le_q_fpv[((s+1)*1-1):s*1] = reg2hw.le[s].q;
  end

  // assertions for register: le
  `ASSERT(le_wr_A, wr_P(9'h4, le_q_fpv[31:0], 1, 'hffffffff, 0))
  `ASSERT(le_rd_A, rd_P(9'h4, le_q_fpv[31:0], 'hffffffff, 0))

  // assertions for register: prio0
  `ASSERT(prio0_wr_A, wr_P(9'h8, reg2hw.prio0.q, 1, 'h7, 0))
  `ASSERT(prio0_rd_A, rd_P(9'h8, reg2hw.prio0.q, 'hffffffff, 0))

  // assertions for register: prio1
  `ASSERT(prio1_wr_A, wr_P(9'hc, reg2hw.prio1.q, 1, 'h7, 0))
  `ASSERT(prio1_rd_A, rd_P(9'hc, reg2hw.prio1.q, 'hffffffff, 0))

  // assertions for register: prio2
  `ASSERT(prio2_wr_A, wr_P(9'h10, reg2hw.prio2.q, 1, 'h7, 0))
  `ASSERT(prio2_rd_A, rd_P(9'h10, reg2hw.prio2.q, 'hffffffff, 0))

  // assertions for register: prio3
  `ASSERT(prio3_wr_A, wr_P(9'h14, reg2hw.prio3.q, 1, 'h7, 0))
  `ASSERT(prio3_rd_A, rd_P(9'h14, reg2hw.prio3.q, 'hffffffff, 0))

  // assertions for register: prio4
  `ASSERT(prio4_wr_A, wr_P(9'h18, reg2hw.prio4.q, 1, 'h7, 0))
  `ASSERT(prio4_rd_A, rd_P(9'h18, reg2hw.prio4.q, 'hffffffff, 0))

  // assertions for register: prio5
  `ASSERT(prio5_wr_A, wr_P(9'h1c, reg2hw.prio5.q, 1, 'h7, 0))
  `ASSERT(prio5_rd_A, rd_P(9'h1c, reg2hw.prio5.q, 'hffffffff, 0))

  // assertions for register: prio6
  `ASSERT(prio6_wr_A, wr_P(9'h20, reg2hw.prio6.q, 1, 'h7, 0))
  `ASSERT(prio6_rd_A, rd_P(9'h20, reg2hw.prio6.q, 'hffffffff, 0))

  // assertions for register: prio7
  `ASSERT(prio7_wr_A, wr_P(9'h24, reg2hw.prio7.q, 1, 'h7, 0))
  `ASSERT(prio7_rd_A, rd_P(9'h24, reg2hw.prio7.q, 'hffffffff, 0))

  // assertions for register: prio8
  `ASSERT(prio8_wr_A, wr_P(9'h28, reg2hw.prio8.q, 1, 'h7, 0))
  `ASSERT(prio8_rd_A, rd_P(9'h28, reg2hw.prio8.q, 'hffffffff, 0))

  // assertions for register: prio9
  `ASSERT(prio9_wr_A, wr_P(9'h2c, reg2hw.prio9.q, 1, 'h7, 0))
  `ASSERT(prio9_rd_A, rd_P(9'h2c, reg2hw.prio9.q, 'hffffffff, 0))

  // assertions for register: prio10
  `ASSERT(prio10_wr_A, wr_P(9'h30, reg2hw.prio10.q, 1, 'h7, 0))
  `ASSERT(prio10_rd_A, rd_P(9'h30, reg2hw.prio10.q, 'hffffffff, 0))

  // assertions for register: prio11
  `ASSERT(prio11_wr_A, wr_P(9'h34, reg2hw.prio11.q, 1, 'h7, 0))
  `ASSERT(prio11_rd_A, rd_P(9'h34, reg2hw.prio11.q, 'hffffffff, 0))

  // assertions for register: prio12
  `ASSERT(prio12_wr_A, wr_P(9'h38, reg2hw.prio12.q, 1, 'h7, 0))
  `ASSERT(prio12_rd_A, rd_P(9'h38, reg2hw.prio12.q, 'hffffffff, 0))

  // assertions for register: prio13
  `ASSERT(prio13_wr_A, wr_P(9'h3c, reg2hw.prio13.q, 1, 'h7, 0))
  `ASSERT(prio13_rd_A, rd_P(9'h3c, reg2hw.prio13.q, 'hffffffff, 0))

  // assertions for register: prio14
  `ASSERT(prio14_wr_A, wr_P(9'h40, reg2hw.prio14.q, 1, 'h7, 0))
  `ASSERT(prio14_rd_A, rd_P(9'h40, reg2hw.prio14.q, 'hffffffff, 0))

  // assertions for register: prio15
  `ASSERT(prio15_wr_A, wr_P(9'h44, reg2hw.prio15.q, 1, 'h7, 0))
  `ASSERT(prio15_rd_A, rd_P(9'h44, reg2hw.prio15.q, 'hffffffff, 0))

  // assertions for register: prio16
  `ASSERT(prio16_wr_A, wr_P(9'h48, reg2hw.prio16.q, 1, 'h7, 0))
  `ASSERT(prio16_rd_A, rd_P(9'h48, reg2hw.prio16.q, 'hffffffff, 0))

  // assertions for register: prio17
  `ASSERT(prio17_wr_A, wr_P(9'h4c, reg2hw.prio17.q, 1, 'h7, 0))
  `ASSERT(prio17_rd_A, rd_P(9'h4c, reg2hw.prio17.q, 'hffffffff, 0))

  // assertions for register: prio18
  `ASSERT(prio18_wr_A, wr_P(9'h50, reg2hw.prio18.q, 1, 'h7, 0))
  `ASSERT(prio18_rd_A, rd_P(9'h50, reg2hw.prio18.q, 'hffffffff, 0))

  // assertions for register: prio19
  `ASSERT(prio19_wr_A, wr_P(9'h54, reg2hw.prio19.q, 1, 'h7, 0))
  `ASSERT(prio19_rd_A, rd_P(9'h54, reg2hw.prio19.q, 'hffffffff, 0))

  // assertions for register: prio20
  `ASSERT(prio20_wr_A, wr_P(9'h58, reg2hw.prio20.q, 1, 'h7, 0))
  `ASSERT(prio20_rd_A, rd_P(9'h58, reg2hw.prio20.q, 'hffffffff, 0))

  // assertions for register: prio21
  `ASSERT(prio21_wr_A, wr_P(9'h5c, reg2hw.prio21.q, 1, 'h7, 0))
  `ASSERT(prio21_rd_A, rd_P(9'h5c, reg2hw.prio21.q, 'hffffffff, 0))

  // assertions for register: prio22
  `ASSERT(prio22_wr_A, wr_P(9'h60, reg2hw.prio22.q, 1, 'h7, 0))
  `ASSERT(prio22_rd_A, rd_P(9'h60, reg2hw.prio22.q, 'hffffffff, 0))

  // assertions for register: prio23
  `ASSERT(prio23_wr_A, wr_P(9'h64, reg2hw.prio23.q, 1, 'h7, 0))
  `ASSERT(prio23_rd_A, rd_P(9'h64, reg2hw.prio23.q, 'hffffffff, 0))

  // assertions for register: prio24
  `ASSERT(prio24_wr_A, wr_P(9'h68, reg2hw.prio24.q, 1, 'h7, 0))
  `ASSERT(prio24_rd_A, rd_P(9'h68, reg2hw.prio24.q, 'hffffffff, 0))

  // assertions for register: prio25
  `ASSERT(prio25_wr_A, wr_P(9'h6c, reg2hw.prio25.q, 1, 'h7, 0))
  `ASSERT(prio25_rd_A, rd_P(9'h6c, reg2hw.prio25.q, 'hffffffff, 0))

  // assertions for register: prio26
  `ASSERT(prio26_wr_A, wr_P(9'h70, reg2hw.prio26.q, 1, 'h7, 0))
  `ASSERT(prio26_rd_A, rd_P(9'h70, reg2hw.prio26.q, 'hffffffff, 0))

  // assertions for register: prio27
  `ASSERT(prio27_wr_A, wr_P(9'h74, reg2hw.prio27.q, 1, 'h7, 0))
  `ASSERT(prio27_rd_A, rd_P(9'h74, reg2hw.prio27.q, 'hffffffff, 0))

  // assertions for register: prio28
  `ASSERT(prio28_wr_A, wr_P(9'h78, reg2hw.prio28.q, 1, 'h7, 0))
  `ASSERT(prio28_rd_A, rd_P(9'h78, reg2hw.prio28.q, 'hffffffff, 0))

  // assertions for register: prio29
  `ASSERT(prio29_wr_A, wr_P(9'h7c, reg2hw.prio29.q, 1, 'h7, 0))
  `ASSERT(prio29_rd_A, rd_P(9'h7c, reg2hw.prio29.q, 'hffffffff, 0))

  // assertions for register: prio30
  `ASSERT(prio30_wr_A, wr_P(9'h80, reg2hw.prio30.q, 1, 'h7, 0))
  `ASSERT(prio30_rd_A, rd_P(9'h80, reg2hw.prio30.q, 'hffffffff, 0))

  // assertions for register: prio31
  `ASSERT(prio31_wr_A, wr_P(9'h84, reg2hw.prio31.q, 1, 'h7, 0))
  `ASSERT(prio31_rd_A, rd_P(9'h84, reg2hw.prio31.q, 'hffffffff, 0))

  // define local fpv variable for multi-reg
  logic [31:0] ie0_q_fpv;
  for (genvar s = 0; s < 32; s++) begin : gen_ie0_q
    assign ie0_q_fpv[((s+1)*1-1):s*1] = reg2hw.ie0[s].q;
  end

  // assertions for register: ie0
  `ASSERT(ie0_wr_A, wr_P(9'h100, ie0_q_fpv[31:0], 1, 'hffffffff, 0))
  `ASSERT(ie0_rd_A, rd_P(9'h100, ie0_q_fpv[31:0], 'hffffffff, 0))

  // assertions for register: threshold0
  `ASSERT(threshold0_wr_A, wr_P(9'h104, reg2hw.threshold0.q, 1, 'h7, 0))
  `ASSERT(threshold0_rd_A, rd_P(9'h104, reg2hw.threshold0.q, 'hffffffff, 0))

  // assertions for register: cc0
  `ASSERT(cc0_wr_A, wr_ext_P(9'h108, reg2hw.cc0.q, 1, 'h3f, 0))
  `ASSERT(cc0_rd_A, rd_ext_P(9'h108, hw2reg.cc0.d, 'hffffffff, 0))

  // assertions for register: msip0
  `ASSERT(msip0_wr_A, wr_P(9'h10c, reg2hw.msip0.q, 1, 'h1, 0))
  `ASSERT(msip0_rd_A, rd_P(9'h10c, reg2hw.msip0.q, 'hffffffff, 0))


endmodule
