// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{
    name: "dma"
    import_testplans: ["hw/dv/tools/dvsim/testplans/csr_testplan.hjson",
                       "hw/dv/tools/dvsim/testplans/alert_test_testplan.hjson",
                       "hw/dv/tools/dvsim/testplans/intr_test_testplan.hjson",
                       "hw/dv/tools/dvsim/testplans/tl_device_access_types_testplan.hjson"]
    testpoints: [
      //--------------------------------------------------------------------
      // Tests for DMA DUT 'memory-to-memory' and 'hardware handshake' modes
      //--------------------------------------------------------------------
      {
        name: dma_memory_smoke
        desc: '''
              Smoke test in which random DMA operations are performed with 'memory-to-memory' mode

              Stimulus:
                - Configure DMA
                  * Randomize DMA memory region base and limit
                  * Randomize source and destination address space IDs and address pointers such that all valid source and destination combinations are covered at least once
                  * Randomize Total transfer width and transaction size
                  * Update DMAC.op_code and disable hardware_handshake mode
                - Start DMA operation by setting DMAC.GO bit
                - Wait for TLUL transactions on the output interface
                - Respond with data from the TLUL agent in the testbench
                - Wait for the operation to complete
                - Repeat the operation randomly with different source and destination parameters

              Checking:
                - Check that the data presented at the source TLUL interface appears unchanged on the destination TLUL interface
                - Check for the assertion of PLIC interrupt if INTR_ENABLE.int_enable else check for DMAC.DONE after every iteration
                - Check for any spurious requests from the remaining TLUL interfaces
                - Check if the number of requests on TLUL agent matches the expected data size
                - Check if DMAC.busy bit is set throughout the operation in each iteration
              '''
        stage: V1
        tests: ["dma_memory_smoke"]
      }
      {
        name: dma_handshake_smoke
        desc: '''
              Smoke test in which 'hardware handshake' DMA operations are performed

              Stimulus:
                - Configure DMA
                  * Randomize DMA memory region base and limit
                  * Randomize source and destination address space IDs and address pointers such that all valid source and destination combinations are covered at least once
                  * Randomize total transfer width and transaction sizes
                  * Program DMAC.op_code and enable 'hardware handshake' mode
                - Start DMA operation by setting DMAC.GO bit
              - Assert Low Speed IO (LSIO) interrupt
              - Wait for TLUL transaction on the output interface
              - Respond with random number of data items from TLUL agent in the testbench
              - Deassert LSIO interrupt
              - Wait for the operation to complete
              - Repeat the copy operation with different source and destination parameters

              Checking:
              - Check if DMA operation is completed successfully
                * Check that the data presented at the source TLUL interface appears unchanged on the destination TLUL interface
                * Check for assertion of PLIC interrupt if INTR_ENABLE.int_enable else check for DMAC.DONE after every iteration
                * Check if the number of requests on TLUL agent matches the expected data size
              - Check if STATUS.busy bit is set until 'hardware handshake' mode is disabled
              - Check if STATUS.done is set after LSIO interrupt is deasserted
              '''
        stage: V1
        tests: ["dma_handshake_smoke"]
      }
      {
        name: dma_memory_region_lock
        desc:'''
              Test to check DMA memory region lock functionality

              Stimulus:
                - Configure DMA
                  * Randomize DMA memory region base and limit
                  * Randomize source and destination address space IDs and address pointers such that all valid source and destination combinations are covered at least once
                  * Randomize Total transfer width and transaction size
                  * Lock DMA memory configuration registers
                  * Program DMAC register with OP code and randomize 'hardware handshake' mode enable bit
                - Start DMA operation by setting DMAC.GO bit
              - Randomly change the DMA memory region base and limit
              - Wait for the operation to complete
              - Reset the design by asserting rst_n
              - Repeat DMA operation without locking the DMA memory configuration registers

              Checking:
              - Check that DMA operation is completed successfully
                * Check for assertion of interrupt if INTR_ENABLE.int_enable else check for DMAC.DONE after every iteration
              - Check if writes to DMA memory region and base values are ignored until range_regwen.regwen is cleared
              - Check if the range_regwen.regwen is set to MuBi4True after deassertion of reset
              '''
        stage: V2
        tests: ["dma_memory_region_lock"]
      }
      {
        name: dma_memory_tl_error
        desc: '''
              Test to check TLUL error behavior on DMA interfaces

              Stimulus:
              - Configure DMA to perform a copy operation with different source and destination parameters in 'memory-to-memory' mode
              - Start DMA operation by setting DMAC.GO bit
              - Respond with an error on either source or destination TLUL interface reqeust
              - Wait for PLIC interrupt assertion if INTR_ENABLE.int_enable is set else poll for DMAC.ABORTED bit

              Checking:
              - Check if STATUS.aborted bit is set (This indicates DMA operation is aborted)
              - Check that there are no TLUL transactions on source and destination interfaces after error response
              - Check if DMA generates an alert
              '''
        stage: V2
        tests: ["dma_memory_tl_error"]
      }
      {
        name: dma_handshake_tl_error
        desc: '''
              Test to check TLUL error behavior on DMA interfaces with 'hardware handshake' mode

              Stimulus:
              - Configure DMA to perform a copy operation with different source and destination parameters in hardware_handshake mode
              - Start DMA operation by setting DMAC.GO bit
              - Respond with error on destination TLUL interface
              - Wait for PLIC interrupt assertion if INTR_ENABLE.int_enable is set else poll for DMAC.DONE bit

              Checking:
              - Check that there are no TLUL transactions on destination interface after error in the input TLUL interface
              - Check if STATUS.aborted bit is set (This indicates DMA operation is aborted)
              - Check if DMA generates an alert
              '''
        stage: V2
        tests: ["dma_handshake_tl_error"]
      }
      {
        name: dma_handshake_stress
        desc: '''
              Stress test in which hardware handshake DMA operations are performed. Goal is to achieve maximum possible coverage of DMA configuration space in 'hardware handshake' mode

              Stimulus:
                - Configure DMA
                  * Randomize DMA memory region base and limit
                  * Randomize source and destination address space IDs and address pointers
                    such that all valid source and destination combinations are covered at least once
                  * Randomize total transfer width and transaction size
                  * Randomize DMAC.data_direction
                  * Randomize DMAC.FIFO_address_auto_increment_enable and DMAC.memory_address_auto_increment_enable
                  * Program DMAC register with OP code and enable 'hardware handshake' mode
                - Start DMA operation by setting DMAC.GO bit
              - Start DMA operation by setting DMAC.GO bit
              - Assert Low Speed IO (LSIO) interrupt
              - Wait for TLUL transaction on the output interface
              - Respond with random number of data items from TLUL agent in the testbench
              - Deassert LSIO interrupt
              - Wait for the operation to complete

              Checking:
              - Check if DMA operation is completed successfully in each iteration
                * Check if DMAC.GO bit is not set until the DMA operation is complete
                * Check if STATUS.busy bit is set until 'hardware handshake' mode is disabled
                * Check if STATUS.done is set after LSIO interrupt is deasserted
              '''
        stage: V2
        tests: ["dma_handshake_stress"]
      }
      {
        name: dma_memory_stress
        desc:'''
             Stress test in which random DMA operations are performed with 'memory-to-memory' mode. Goal is to achieve maximum possible coverage of DMA configuration space in 'memory-to-memory' mode

             Stimulus:
              - Configure DMA
                * Randomize DMA memory region base and limit
                * Randomize source and destination address space IDs and address pointers
                * Randomize Total transfer width and transaction size
                * Program DMAC register with OP code and disable 'hardware handshake' mode
              - Start DMA operation by setting DMAC.GO bit
              - Wait for the operation to complete
              - Repeat operation with different source and destination addresses

             Checking:
              - Check that DMA operation is completed successfully
                * Check that the number of TLUL requests matches the expected data size
                * Check that the data presented at the source TLUL interface appears unchanged on the destination TLUL interface
                * Check if STATUS.busy bit is set until the copy operation is complete
                * Check if STATUS.done bit is set after the copy operation
             '''
        stage: V2
        tests: ["dma_memory_stress"]
      }
      {
        name: dma_handshake_mem_buffer_overflow
        desc: '''
              Test to check DMA memory buffer threshold and limit behavior with 'hardware handshake' mode

              Stimulus:
              - Configure DMA for 'hardware handshake' mode
              - Set memory_buffer_address_auto_increment
              - Set memory_buffer_threshold and memory_buffer_limit such that
                * Threshold is less than the limit and
                * Threshold and limit are within the DMA memory region
              - Start DMA operation by setting DMAC.GO bit
              - Assert Low Speed IO (LSIO) interrupt
              - Wait for TLUL transaction on the output interface
              - Respond with random number of data items such that the amount exceeds either the memory_buffer_threshold or memory_buffer_limit
              - Deassert LSIO interrupt
              - Wait for the operation to complete
              - Repeat the operation with different source and destination parameters

              Checking:
              - Check if DMA operation is completed successfully in each iteration
                * Check if DMAC.GO bit is set until the DMA operation is complete
                * Check if STATUS.busy bit is set until 'hardware handshake' mode is disabled
                * Check if STATUS.done is set after LSIO interrupt is deasserted
              - Check if PLIC interrupt is asserted when memory_buffer_auto_increment is enabled
              '''
        stage: V2
        tests: ["dma_handshake_mem_buffer_overflow"]
      }
      {
        name: dma_abort
        desc: '''
              Test to check DMAC.abort functionality

              Stimulus:
              - Configure DMA to perform a copy operation randomly with different source and destination parameters
              - Randomly enable hardware_handshake mode
              - Start DMA operation
              - Abort DMA operation before completion by setting DMAC.abort
              - Wait for PLIC interrupt assertion if INTR_ENABLE.int_enable is set else poll for DMAC.DONE bit
              - Repeat operation with different source and destination parameters

              Checking:
              - Check if STATUS.aborted bit is set (This indicates DMA operation is aborted)
              - Check if there all outstanding transactions on OT internal TLUL interface are complete
              '''
        stage: V2
        tests: ["dma_memory_abort"]
      }
      {
        name: dma_illegal_transfer
        desc: '''
              Test to check DMA hardware enforced security check for direct transfer between CTN and SYS address spaces

              Stimulus:
              - Configure DMA
                * Randomize DMA memory region base and limit
                * Randomize source and destination address pointers and address space IDs such that the transfer happens between CTN and SYS address spaces
                * Randomize total transfer width and transaction size
                * Enable 'hardware handshake' mode and set DMAC.direction randomly
                * Update the OPcode in DMAC register
              - Start DMA operation
              - Wait for PLIC interrupt assertion if INTR_ENABLE.int_enable is set else poll for STATUS.abort bit

              Checking:
              - Check if STATUS.aborted bit is set (This indicates DMA operation is aborted)
              - Check if DMA generates an alert
              '''
        stage: V2S
        tests: ["dma_illegal_transfer"]
      }
      {
        name: dma_illegal_address_range
        desc: '''
              Test to check DMA hardware enforced security check for illegal source or destination address

              Stimulus:
              - Configure DMA
                * Update DMA memory region base and limit
                * Update Source and Destination address pointers and address space IDs such that the address source or destination address is outside the DMA memory region
              - Configure DMA with total transfer width and transaction size
              - Enable 'hardware handshake' mode and direction randomly
              - Start DMA operation
              - Wait for interrupt assertion if INTR_ENABLE.int_enable is set else poll for STATUS.abort bit

              Checking:
              - Check if STATUS.aborted bit is set (This indicates DMA operation is aborted)
              - Check if DMA generates an alert
              '''
        stage: V2S
        tests: ["dma_illegal_address_range"]
      }
    ]
    covergroups: [
      {
        name: dma_config_cg
        desc: '''
               - Cover Source and destination address space ID
               - Cover source and destination address
               - Cover DMA memory region base and size
               - Cover DMA memory region threshold and limit
               - Cover DMA memory region lock
               - Cover total transfer width
               - Cover transaction size
               - Cover values of each field in DMA Control register
                * OP code
                * Hardware_handshake_mode
                * Memory_buffer_auto_increment_enable
                * Fifo_auto_increment_enable
                * Data_direction
                * Abort
                * Interrupt Enable
                * Go
              - Cover values of each field in DMA Status register
                * Busy
                * Done
                * Aborted
                * Error
                * Error code
              - Cross OP code, source_Address_space_id, destination_space_id and DMA operating mode
              - Cross transfer_size, source_address_space_id and DMA operating mode
              - Cross transfer_size, destination_address_space_id and DMA operating mode
              - Cross source_address, source_address_space_id and DMA operating mode
              - Cross destination_address, destination_address_space_id and DMA operating mode
              - Cross DMA memory base, DMA memory limit and DMA operating mode
              - Cross DMA memory region lock, Write to DMA memory region base or limit and DMA operating mode
              - Cross source_address_space_id, TL error on source interface and DMA operating mode
              - Cross destination_address_space_id, TL error on destination interface and DMA operating mode
              '''
      }
      {
        name: dma_handshake_cg
        desc: '''
              Cover the following crosses only in 'hardware handshake' mode
              - Cross Destination address, memory buffer limit (if memory_buffer_auto_increment is set)
              - Cross Destination address, memory buffer threshold (if memory_buffer_auto_increment is set)
              - Cross fifo_address_auto_increment_enable and source_address_space_id
              - Cross memory_buffer_auto_increment and destination_address_space_id
              - Cross data_direction, source_address_space_id and destination_address_space_id
              - Cross data_direction, source_address_space_id and fifo_address_auto_increment_enable
              - Cross data_direction, destination_address_space_id and memory_buffer_auto_increment_enable
              '''
      }
    ]
  }
