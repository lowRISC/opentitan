// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// This sequence is specifically to ensure that the 'limit' and 'almost limit' addresses stand
// a much higher chance of being near the destination address range, whilst permitting them to be
// either inside or just outside that range.

class dma_mem_limit_vseq extends dma_generic_vseq;
  `uvm_object_utils(dma_mem_limit_vseq)
  `uvm_object_new

  constraint iters_c {num_iters inside {[2:4]};}
  constraint transactions_c {num_txns == 16;}

  // Permit only valid configurations for this test; invalid configurations are generated by stress
  // sequences.
  virtual function bit pick_if_config_valid();
    return 1'b1;
  endfunction

  // Randomization of DMA configuration and transfer properties; constraints are set to ensure that
  // the memory limit addresses shall be used, and we shall usually want them to be close to the
  // destination address range of the transfer because otherwise the 32- or 64-bit address range
  // is too large make collisions probable.
  virtual function void randomize_item(ref dma_seq_item dma_config);
    bit almost_nearby;
    bit limit_nearby;
    // Decide whether we want the 'limit' threshold to lie within the transfer
    `DV_CHECK_STD_RANDOMIZE_WITH_FATAL(limit_nearby, limit_nearby dist { 0 := 20, 1 := 80};)
    // Decide whether we want the 'almost limit' threshold to lie within the transfer
    `DV_CHECK_STD_RANDOMIZE_WITH_FATAL(almost_nearby, almost_nearby dist { 0 := 20, 1 := 80};)
    `uvm_info(`gfn, $sformatf("DMA: Choosing limit nearby = %d almost_limit nearby = %d",
                              limit_nearby, almost_nearby), UVM_MEDIUM)

    dma_config.dst_addr_limit_nearby_c.constraint_mode(limit_nearby);
    dma_config.dst_addr_almost_limit_nearby_c.constraint_mode(almost_nearby);

    // Allow only valid DMA configurations
    dma_config.valid_dma_config = 1;
    `DV_CHECK_RANDOMIZE_WITH_FATAL(
      dma_config,
      direction == DmaRcvData; // Receive from FIFO (otherwise mem limit not used)
      per_transfer_width == DmaXfer4BperTxn; // Limit to only 4B transfers
      handshake == 1'b1; // Enable hardware handshake mode
      handshake_intr_en != 0;) // At least one handshake interrupt signal must be enabled
    `uvm_info(`gfn, $sformatf("DMA: Randomized a new transaction:%s",
                              dma_config.convert2string()), UVM_MEDIUM)
    // Report the decisions here; the configuration shall always be valid (see above).
    `uvm_info(`gfn, $sformatf("DMA: Destination range [0x%0x,0x%0x) limit 0x%0x almost_limit 0x%0x",
                              dma_config.dst_addr,
                              dma_config.dst_addr + dma_config.total_data_size,
                              dma_config.dst_addr_limit, dma_config.dst_addr_almost_limit),
              UVM_MEDIUM)
  endfunction

  // The functionality of this vseq is implemented in `dma_generic_vseq`
  virtual task body();
    `uvm_info(`gfn, "DMA: Starting mem limit Sequence", UVM_LOW)
    super.body();
    `uvm_info(`gfn, "DMA: Completed mem limit Sequence", UVM_LOW)
  endtask : body
endclass
