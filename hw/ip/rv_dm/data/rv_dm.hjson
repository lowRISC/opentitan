// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{
  name:               "rv_dm",
  human_name:         "RISC-V Debug Module",
  one_line_desc:      "Enables debug support for Ibex, access protected by life cycle",
  one_paragraph_desc: '''
  RISC-V Debug Module provides a JTAG test access port (TAP) to interface the Ibex RISC-V core as well as hardware blocks attached to the TileLink on-chip interconnect.
  The interface to Ibex is compliant with the RISC-V Debug Specification 0.13.2, which in turn is supported by debug software such as OpenOCD and GDB.
  For security reasons, RISC-V Debug Module is only active in life cycles that have hardware debug enabled.
  '''
  // Unique comportable IP identifier defined under KNOWN_CIP_IDS in the regtool.
  cip_id:             "24",
  design_spec:        "../doc",
  dv_doc:             "../doc/dv",
  hw_checklist:       "../doc/checklist",
  sw_checklist:       "",
  version:            "1.0.0",
  life_stage:         "L1",
  design_stage:       "D2S",
  verification_stage: "V1",
  clocking: [
    {clock: "clk_i", reset: "rst_ni"}
  ]
  bus_interfaces: [
    { protocol: "tlul", direction: "host",   name: "sba" }
    { protocol: "tlul", direction: "device", name: "regs" }
    { protocol: "tlul", direction: "device", name: "mem" }
  ],
  scan: "true", // Enable `scanmode_i` port
  scan_reset: "true", // Enable `scan_rst_ni` port
  param_list: [
    { name:    "NrHarts",
      type:    "int",
      default: "1",
      desc:    "Number of hardware threads in the system."
      local:   "true"
    },
    { name:    "IdcodeValue",
      type:    "logic [31:0]",
      default: "32'h 0000_0001",
      desc:    "RISC-V debug module JTAG ID code."
      local:   "false",
      expose:  "true"
    },
  ]
  interrupt_list: [
  ],
  alert_list: [
    { name: "fatal_fault",
      desc: '''
      This fatal alert is triggered when a fatal TL-UL bus integrity fault is detected.
      '''
    }
  ],
  inter_signal_list: [
    { struct:  "jtag",
      type:    "req_rsp",
      name:    "jtag",
      act:     "rsp",
      package: "jtag_pkg",
      desc:    "JTAG signals for the RISC-V TAP."
    },
    { struct:  "lc_tx"
      type:    "uni"
      name:    "lc_hw_debug_en"
      act:     "rcv"
      default: "lc_ctrl_pkg::Off"
      package: "lc_ctrl_pkg"
      desc:    '''
               Multibit life cycle hardware debug enable signal coming from life cycle controller,
               asserted when the hardware debug mechanisms are enabled in the system.
               '''
    },
    { struct:  "lc_tx"
      type:    "uni"
      name:    "pinmux_hw_debug_en"
      act:     "rcv"
      default: "lc_ctrl_pkg::Off"
      package: "lc_ctrl_pkg"
      desc:    '''
               Multibit life cycle hardware debug enable signal coming from pinmux.
               This is a latched version of the lc_hw_debug_en signal and is only used to
               gate the JTAG / TAP side of the RV_DM. It is used to keep a debug session live
               while the rest of the system undergoes an NDM reset.
               '''
    },
    // TBD: should we connect this to the clock manager?
    { struct:  "logic"
      type:    "uni"
      name:    "unavailable"
      act:     "rcv"
      default: "1'b0"
      desc:    '''
               This signal indicates to the debug module that the main processor is not available
               for debug (e.g. due to a low-power state).
               '''
    },
    { struct:  "logic"
      type:    "uni"
      name:    "ndmreset_req"
      act:     "req"
      desc:    "Non-debug module reset request going to the system reset infrastructure."
    },
    { struct:  "logic"
      type:    "uni"
      name:    "dmactive"
      act:     "req"
      desc:    '''
               This signal indicates whether the debug module is active and can be used to prevent
               power down of the core and bus-attached peripherals.
               '''
    },
    { struct:  "logic [rv_dm_reg_pkg::NrHarts-1:0]"
      type:    "uni"
      name:    "debug_req"
      act:     "req"
      desc:    "This is the debug request interrupt going to the main processor."
    },
  ]
  features: [
    {
      name: "RV_DM.JTAG.FSM",
      desc: '''
               Full JTAG state machine is implemented including mandatory BYPASS
               register and optional IDCODE register.
            '''
    },
    {
      name: "RV_DM.JTAG.DTM",
      desc: '''
                A RISC-V DTM (debug transport module) is implemented accessible
                via JTAG. In particular implements the dtmcs and dmi registers
                specified in the RISC-V debug spec (along with standard JTAG TAP
                registers).
             '''
    },
    {
      name: "RV_DM.DBG.DATA_REGS",
      desc: '''
                 The DMI regs data0 and data1 are implemented.
             '''
    },
    {
      name: "RV_DM.DBG.DMCONTROL_REG",
      desc: '''
                 The DMI register dmcontrol is implemented. The following
                 optional fields have limited function or are not implemented:
                  - hartreset - Not implemented, writes ignored read zero
                  - hasel - HART masks not supported, writes ignored, read zero
                  - setresethaltreq - Not implemented, writes ignored read zero
                  - clrresethaltreq - Not implemented, writes ignored read zero
             '''
    },
    {
      name: "RV_DM.DBG.DMSTATUS_REG",
      desc: '''
                 The DMI register dmstatus is implemented. As HART masks are not
                 supported the various allX/anyX register pairs are identical.
             '''
    },
    {
      name: "RV_DM.DBG.HARTINFO_REG",
      desc: '''
                The DMI register hartinfo is implemented.
             '''
    },
    {
      name: "RV_DM.DBG.HALTSUM0_REG",
      desc: '''
                The DMI register haltsum0 is implemented.
             '''
    },
    {
      name: "RV_DM.DBG.ABSTRACT_COMMAND",
      desc: '''
                The DMI registers abstractcs/command/abstractauto are
                implemented.

                Only the Access Register Command is implemented.
             '''
    },
    {
      name: "RV_DM.DBG.PROGBUF",
      desc: '''
                The DMI implements the program buffer, with all registers
                progbuf0 - progbuf15 usable
             '''
    },
    {
      name: "RV_DM.DBG.SBA",
      desc: '''
                The DMI implements system bus access. sbdata0/sbdata1 and
                sbaddress0/sbaddress1 are implemented. However as the data and
                address bus with is 32-bits the second register of each has no
                functionality but can still be read and written.
             '''
    },
    {
      name: "RV_DM.DBG.NDM_RESET",
      desc: '''
                The debug module implements a non-debug reset, that resets the
                whole system other than the debug module. It is controlled via
                the DMI DMCONTROL register
             '''
    }
    {
      name: "RV_DM.DBG.GDB",
      desc: '''
                The debug module will work with GDB connected via OpenOCD over
                JTAG. In particular the following features will be functional
                from GDB:
                  - Halting execution and resetting
                  - Setting, hitting and deleting breakpoints using all
                    available hardware breakpoints
                  - Single stepping
                  - Reading and writing all registers
                  - Reading and writing CSRs
                  - Reading and writing memory
                  - Setting the PC to jump to some location
                  - Executing code from GDB (using the call command)
             '''
    }
  ],
  countermeasures: [
    { name: "BUS.INTEGRITY",
      desc: "End-to-end bus integrity scheme."
    }
    { name: "LC_HW_DEBUG_EN.INTERSIG.MUBI",
      desc: "The life cycle hardware debug enable signal is multibit encoded."
    }
    { name: "DM_EN.CTRL.LC_GATED",
      desc: '''
            The debug module is enabled with the LC_HW_DEBUG_EN signal.
            This enablement is implemented by gating / enabling critical
            blocks with separately buffered copies of the life cycle signal.
            This comprises the debug module interface (DMI) attached to the TAP,
            the reset request line, the system bus access module (SBA), the debug
            request output, the TL-UL adapter for the debug ROM, and the ifetch indicator
            being fed into the TL-UL adapter for the debug ROM.
            '''
    }
    { name: "SBA_TL_LC_GATE.FSM.SPARSE",
      desc: "The control FSM inside the TL-UL gating primitive is sparsely encoded."
    }
    { name: "MEM_TL_LC_GATE.FSM.SPARSE",
      desc: "The control FSM inside the TL-UL gating primitive is sparsely encoded."
    }
    { name: "EXEC.CTRL.MUBI",
      desc: '''
            The instruction fetch enable signal that is modulated with LC_HW_DEBUG_EN
            and that feeds into the TL-UL adapter is multibit encoded.
            '''
    }
  ],
  regwidth: "32",
  registers: {
    regs:[
    ]
    mem: [
      // Expansion of debug memory within rv_dm used for DV purposes. The generated reg_top is not
      // actually instantiated in RTL since the debug memory region is implemented inside the
      // vendored-in module from the PULP project.
      //
      // The debug memory region is specified in the PULP debug system documentation here:
      // https://github.com/pulp-platform/riscv-dbg/blob/master/doc/debug-system.md
      //
      // The debug module exposes a 16kB memory called debug memory. It has a ROM portion
      // (debug ROM), some memory mapped CSRs and a RAM portion (program buffer). This region is
      // accessible over the TL interface only if debug mode is active.
      { skipto: "0x100" }
      { name:  "HALTED",
        desc: '''
              Written by a hart whenever it enters debug mode.

              A hart entering debug mode must write its ID to this address to indicate that it has halted.
              When the debug module triggers a debug mode (aka halt) request to the hart, the hart will jump to the debug ROM.
              In that debug ROM, the hart must write its ID here to acknowledge completion of the request.
              When the write is received, the debug module will record that the hart is halted in its status register.
              In addition, the debug module may begin to accept abstract commands that run on that hart.

              Note that this write upon entering debug mode is also important for indicating that a sequence of debug mode instructions completed.
              In that case, the hart would write to this address while it was already halted.
              ''',
        swaccess: "wo",
        hwaccess: "hrw", // updated by write to RESUMING
        fields: [
          { bits: "0",
            resval: "0" // core ID value
          },
        ]
      },
      { skipto: "0x108" }
      { name: "GOING",
        desc: '''
              Written by a hart to acknowledge a command.

              A hart that receives an abstract command (indicated by its corresponds !!FLAGS register) must write to this address to acknowledge it received the command.
              The value written is unused, but it is conventionally 0.

              Upon receiving the write, the debug module will reset the GO field in the selected hart's !!FLAGS register.
              The debug module will transition to a state where it awaits the write to !!HALTED to indicate the command has completed.
              ''',
        swaccess: "wo",
        hwaccess: "hro",
        fields: [
          { bits: "0",
            resval: "0"
          },
        ]
      },
      { skipto: "0x110" }
     {  name:  "RESUMING"
        desc: '''
              Written by a hart to acknowledge a resume request.

              A hart that receives the command to resume from debug mode (via the RESUME flag in its !!FLAGS register) must write its ID to this address.

              This write tells the debug module that the command has been acknowledged, and the hart is no longer halted.
              ''',
        swaccess: "wo",
        hwaccess: "hro",
        fields: [
          { bits: "0",
            resval: "0" // core ID value
          },
        ]
      },
      { skipto: "0x118" }
      { name: "EXCEPTION",
        desc: "An exception was triggered while the core was in debug mode.",
        swaccess: "wo",
        hwaccess: "hro",
        fields: [
          { bits: "0",
            resval: "0"
          },
        ]
      },
      { skipto: "0x300" }
      { name: "WHERETO",
        desc: '''
              A jump instruction the hart executes to begin a command.

              When a debugger sends an abstract command to the debug module, the debug module indicates the instruction to run here, which is invariably a jump.
              The hart receiving the command must execute the instruction at this address after acknowledging the command with the write to !!GOING.

              Similarly, when a debugger requests that a hart resume, the debug module supplies a jump instruction to execute here.
              In the resume request case, the hart must execute the indicated instruction after acknolwedging the request with the write to !!RESUMING.
              ''',
        swaccess: "ro",
        hwaccess: "hrw",
        fields: [
          { bits: "31:0",
            resval: "0"
          },
        ]
      },
      { skipto: "0x338" }
      { multireg: {
          cname: "ABSTRACTCMD"
          name:  "ABSTRACTCMD"
          desc:  '''
                 A ROM containing instructions for implementing abstract commands.

                 The hart executes these instructions at the debug modules behest.
                 The debug module's jump instruction at !!WHERETO will land here, except for the AccessRegister command with the "postexec" bit set and the "transfer" bit unset.
                 See the RISC-V Debug Specification for more information on the encoding of abstract commands.
                 ''',
          count: "10"
          swaccess: "ro"
          hwaccess: "hro"
          fields: [
            { bits: "31:0"
              resval: "0"
            }
          ]
          tags: [// TODO: It is unclear how to predict these values.
                 "excl:CsrAllTests:CsrExclCheck"]
        }
      },
      { multireg: {
          cname: "PROGRAM_BUFFER"
          name:  "PROGRAM_BUFFER"
          desc:  '''
                 A buffer for the debugger to write small debug mode programs.

                 The hart may run these programs by command from the debugger.
                 See the RISC-V Debug Specification for more information about the Program Buffer and how it is used with abstract commands and the "postexec" bit.
                 ''',
          count: "8"
          swaccess: "ro"
          hwaccess: "hro"
          fields: [
            { bits: "31:0"
              resval: "0"
            }
          ]
        }
      },
      { multireg: {
          cname: "DATAADDR"
          name:  "DATAADDR"
          desc:  '''
                 Message Registers for passing arguments and/or return values for abstract commands.

                 See the RISC-V Debug Specification for more information about Message Registers and their relationship to abstract commands.
                 '''
          count: "2"
          swaccess: "rw"
          hwaccess: "hro"
          fields: [
            { bits: "31:0"
              resval: "0"
            }
          ]
          tags: [// TODO: Write-read-check will work after "activating" the debug module via JTAG.
                 "excl:CsrNonInitTests:CsrExclWriteCheck"]
        }
      },
      { skipto: "0x400" }
      { multireg: {
          cname: "FLAGS"
          name:  "FLAGS"
          desc:  '''
                 Flags indicating what a hart in debug mode should do.

                 These flags are how a debug module signals whether a hart should execute an abstract command, resume from debug mode, or remain idle.

                 Each hart has its own FLAGS register that is a single byte.
                 Bit 0 is the GO flag, indicating a request for the selected hart to execute the command.
                 Bit 1 is the RESUME flag, indication a request for the selected hart to resume from halt/ debug mode.
                 The other bits are reserved.

                 The hart finds its own FLAGS register by taking the base address of this group and adding the hart's ID to the byte address.

                 These are written by the debug module.
                 When a selected hart writes the !!GOING register, the corresponding GO flag is cleared.
                 When a selected hart writes the !!RESUMING register, the corresponding RESUME flag is cleared.
                 '''
          count: "256"
          swaccess: "ro"
          hwaccess: "hro"
          fields: [
            { bits: "31:0"
              resval: "0"
            }
          ]
        }
      },
      // Note that this region starts at `0x800` and contains the HaltAddress,
      // ResumeAddress and ExceptionAddress locations.
      { window: {
          name: "ROM"
          // ROM size (given as `items` below) must be a power of two.
          // The 512 x 4 = 2 KiB are enough to hold the 20 x 8 = 0x98 bytes
          // currently allocated in the debug ROM.
          items: "512"
          swaccess: "ro",
          desc: '''Access window into the debug ROM.'''
        }
      },
    ]
  }
}
