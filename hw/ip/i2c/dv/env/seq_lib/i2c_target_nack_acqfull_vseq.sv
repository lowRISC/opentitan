// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// This directed test exercises the automatic-nack'ing features of the DUT-Target
//
// Our stimulus here overfills the ACQFIFO, then awaits the end of the transaction generated by the
// agent when it observes the NACK from the DUT. We check that the NACK counter has incremented as
// expected (via backdoor). At the end of the test, we check the NACK counter via the frontdoor,
// and then check it has cleared via the read.
// After each stimulus transaction, we read the ACQFIFO to empty it completely.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// TESTPOINT DESC. (TP:target_mode_nack_generation)
//
// > NACK when ACQFIFO is full.
// >   - Stimulate WRITE transactions to fill the ACQFIFO (quickly), then allow the
// >     TARGET_TIMEOUT_CTRL value to elapse. Check that we nack at this point.
// >
// > TARGET_NACK_COUNT records the number of NACK'd bytes.
// >   - After some number of NACKs (e.g. generated by the cases above), check
// >     that the TARGET_NACK_COUNT contains the number of NACKs.
// >   - Reading the register clears it, so read twice and confirm zero the second time.
//
// I2C bus devices configured as: (DUT/Agent == Target/Controller)
// This testcase is interrupt driven, so the plusarg +use_intr_handler=1 is needed.
//
class i2c_target_nack_acqfull_vseq extends i2c_target_runtime_base_vseq;
  `uvm_object_utils(i2c_target_nack_acqfull_vseq)
  `uvm_object_new

  virtual task pre_start();
    super.pre_start();

    seq_runtime_us = 10_000;

    // Only write transactions.
    cfg.rd_pct = 0;
    cfg.min_data = I2C_ACQ_FIFO_DEPTH;
    cfg.max_data = I2C_ACQ_FIFO_DEPTH + 10; // Guarantee full-condition

    // CSR.TARGET_TIMEOUT_CTRL - By default, NACK when this timeout elapses.
    ral.target_timeout_ctrl.val.set(1000); // timeout in cycles of clk_i
    ral.target_timeout_ctrl.en.set(1);
    csr_update(ral.target_timeout_ctrl);

    // Use an Agent sequence that actually knows how to respond to a NACK.
    i2c_base_seq::type_id::set_type_override(i2c_controller_base_seq::get_type());

    // Disable ACK-Control mode
    cfg.ack_ctrl_en = 0;
  endtask: pre_start

  virtual task initialization();
    super.initialization();
    // Mask some interrupts that are just noise for this test
    ral.intr_enable.tx_threshold.set(0);
    ral.intr_enable.acq_threshold.set(0);
    ral.intr_enable.rx_threshold.set(0);
    ral.intr_enable.fmt_threshold.set(0);
    ral.intr_enable.rx_overflow.set(0);
    csr_update(ral.intr_enable);
  endtask: initialization

  virtual task end_of_stim_hook();
    // Check the 'nack_count' csr, but a backdoor check to avoid clearing
    // the value due to the "RC" access for software.
    csr_rd_check(.ptr(ral.target_nack_count), .compare_value(stim_cnt), .backdoor(1));

    // Cleanup for next iteration.
    empty_acqfifo();

    // If we've reached the final iteration, read nack_count via frontdoor, except read twice
    // to check the "RC" access.
    if (timer_expired) begin
      `uvm_info(`gfn, "Reading 'target_nack_count via the frontdoor now.", UVM_MEDIUM)
      csr_rd_check(.ptr(ral.target_nack_count), .compare_value(stim_cnt));
      `uvm_info(`gfn, "Reading 'target_nack_count via the frontdoor again, expecting zero.",
                UVM_MEDIUM)
      csr_rd_check(.ptr(ral.target_nack_count), .compare_value(0));
    end
  endtask

  // No interrupt handler for the acqstretch interrupt
  virtual task proc_intr_acqstretch(); endtask

  // Interrupt handler for the "cmd_complete" interrupt
  // (This overrides the parent class impl.)
  virtual task proc_intr_cmdcomplete();
    // Simply acknowledge and clear this 'event'-type interrupt.
    clear_interrupt(CmdComplete, 0);
  endtask: proc_intr_cmdcomplete

endclass: i2c_target_nack_acqfull_vseq
