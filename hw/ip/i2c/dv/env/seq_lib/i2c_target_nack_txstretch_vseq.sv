// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// This directed test exercises the automatic-nack'ing features of the DUT-Target
// In particular, this vseq stimulates NACKs via the CSR.CTRL.TX_STRETCH_CTRL_EN feature.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// TESTPOINT DESC. (TP:target_mode_nack_generation)
//
// > NACK when TARGET_TIMEOUT_CTRL threshold has elapsed.
// >   - Enable TX_STRETCH_CTRL_EN.
// >   - Stimulate read transactions, but do not clear TARGET_EVENTS.TX_PENDING when stretching.
// >   - Await the TARGET_TIMEOUT_CTRL to elapse.
// >   - Check we have NACK'd the read.
// >
// > TARGET_NACK_COUNT records the number of NACK'd bytes.
// >   - After some number of NACKs (e.g. generated by the cases above), check
// >     that the TARGET_NACK_COUNT contains the number of NACKs.
// >   - Reading the register clears it, so read twice and confirm zero the second time.
//
// I2C bus devices configured as: (DUT/Agent == Target/Controller)
// This testcase is interrupt driven, so the plusarg +use_intr_handler=1 is needed.
//
class i2c_target_nack_txstretch_vseq extends i2c_target_runtime_base_vseq;
  `uvm_object_utils(i2c_target_nack_txstretch_vseq)
  `uvm_object_new

  virtual task pre_start();
    super.pre_start();

    seq_runtime_us = 10_000;

    // Only read transactions.
    cfg.wr_pct = 0;
    cfg.min_data = 10;
    cfg.max_data = I2C_TX_FIFO_DEPTH;

    ral.ctrl.tx_stretch_ctrl_en.set(1);
    csr_update(ral.ctrl);

    // CSR.TARGET_TIMEOUT_CTRL - By default, NACK when this timeout elapses.
    ral.target_timeout_ctrl.val.set(10000); // timeout
    ral.target_timeout_ctrl.en.set(1);
    csr_update(ral.target_timeout_ctrl);

    // Use an Agent sequence that actually knows how to respond to a NACK.
    i2c_base_seq::type_id::set_type_override(i2c_controller_base_seq::get_type());

    // Disable ACK-Control mode
    cfg.ack_ctrl_en = 0;
  endtask: pre_start

  virtual task initialization();
    super.initialization();
    // Mask some interrupts that are noise for this test
    ral.intr_enable.tx_threshold.set(0);
    ral.intr_enable.acq_threshold.set(0);
    ral.intr_enable.rx_threshold.set(0);
    ral.intr_enable.fmt_threshold.set(0);
    ral.intr_enable.rx_overflow.set(0);
    csr_update(ral.intr_enable);

    // We currently disable the scoreboard checking for this test as the environment cannot
    // correctly predict the result when mid-txn NACKs are returned by the DUT.
    // This should be fixed by properly modelling this functionality.
    cfg.en_scb = 1'b0;
  endtask: initialization

  virtual task end_of_stim_hook();
    // Check the 'nack_count' csr, but a backdoor check to avoid clearing
    // the value due to the "RC" access for software.
    csr_rd_check(.ptr(ral.target_nack_count), .compare_value(stim_cnt), .backdoor(1));

    // Cleanup for next iteration.
    empty_acqfifo();

    // Clear TARGET_EVENTS for the next transaction.
    ral.target_events.tx_pending.set(1'b1);
    csr_update(ral.target_events);

    // If we've reached the final iteration, read back the nack_count again, except read twice
    // to check the "RC" access.
    if (timer_expired) begin
      `uvm_info(`gfn, "Reading 'target_nack_count via the frontdoor now.", UVM_MEDIUM)
      csr_rd_check(.ptr(ral.target_nack_count), .compare_value(stim_cnt));
      `uvm_info(`gfn, "Reading 'target_nack_count via the frontdoor again, expecting zero.",
                UVM_MEDIUM)
      csr_rd_check(.ptr(ral.target_nack_count), .compare_value(0));

      empty_acqfifo();
    end
  endtask

  // No interrupt handler for the acqstretch interrupt
  virtual task proc_intr_acqstretch(); endtask

  // Interrupt handler for the "cmd_complete" interrupt
  // (This overrides the parent class impl.)
  virtual task proc_intr_cmdcomplete();
    // Simply acknowledge and clear this 'event'-type interrupt.
    clear_interrupt(CmdComplete, 0);
  endtask: proc_intr_cmdcomplete


  // We re-use the parent class implementation for the "tx_stretch" interrupt handler.
  // It does the following:
  // - Adds data into the TXFIFO if there is space
  // - Does not clear the target_events.tx_pending bits. (This is what continues the stretch, to
  //   eventually elicit the stretch-into-timeout behaviour.)


endclass: i2c_target_nack_txstretch_vseq
