// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{
  name: "i2c"
  import_testplans: ["hw/dv/tools/dvsim/testplans/csr_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/alert_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/intr_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/tl_device_access_types_testplan.hjson",
                     "i2c_sec_cm_testplan.hjson"]
  testpoints: [
    //-----------------------------------------------
    // Tests for I2C DUT in HOST mode
    //-----------------------------------------------
    {
      name: host_smoke
      desc: '''
            Smoke test in which random (rx/tx) transactions are
            sent to the DUT and received asynchronously with scoreboard checks.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Enable DUT host
              - Clear and enable interrupt (if needed)
              - Program OVRD and FDATA registers
              - Randomize I2C timing in TIMING[0-4] registers and other parameters such as TL agent
                delays
              - Randomize address and data for read/write transactions sent to the agent by the DUT

            Checking:
              - Check the timing behavior of START, STOP, ACK, NACK, and "repeated" START
              - Read and write transfer matching
              - Command complete interrupt (cmd_complete) raised
            '''
      stage: V1
      tests: ["i2c_host_smoke"]
    }
    {
      name: host_error_intr
      desc: '''
            Test error interrupts are asserted by the Host DUT due to
            interference and unstable signals on bus.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - In host transmit mode, device (target/host) forces SDA or SCL signal low within the
                clock pulse of host SCL that asserts `sda_interference` or `scl_interference`
                interrupts
              - In host receiving mode (data or ack bits), SDA signal is changed with the
                clock pulse of host SCL that asserts `intr_sda_unstable` interrupts
              - When error interrupt assertions are detected, dut, agent, and scoreboard will be
                reset on-the-fly then new transaction can be continue programming

            Checking:
              - Ensure all intr_scl_interference, intr_sda_interference, and
                intr_sda_unstable interrupts are asserted and stay asserted until cleared
              - Ensure IP operation get back normal after on-the-fly reset finished
            '''
      stage: V2
      tests: ["i2c_host_error_intr"]
    }
    {
      name: host_stress_all
      desc: '''
            Support vseq (context) switching with random reset in between.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Combine above sequences in one test to run sequentially
                except CSR sequence and i2c_host_rx_oversample_vseq (requires zero_delays)
              - Randomly add reset between each sequence

            Checking:
              - Ensure transactions are transmitted/received correctly,
              - Ensure reset is handled correctly
            '''
      stage: V2
      tests: ["i2c_host_stress_all"]
    }
    {
      name: host_stress_all_with_rand_reset
      desc: '''
            Support random reset in parallel with stress_all and tl_errors sequences.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Combine above sequences in one test to run sequentially
                except CSR sequence and i2c_host_rx_oversample_vseq (requires zero_delays)
              - Randomly add reset within the sequences then switch to another one

            Checking:
              - Ensure transactions are transmitted/received correctly
              - Ensure reset is handled correctly
            '''
      stage: V3
      tests: ["i2c_host_stress_all_with_rand_reset"]
    }
    {
      name: host_maxperf
      desc: '''
            The Host DUT sends and receives transactions at max bandwidth.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Program `TIMINGx` registers based on I2C specification
              - Reduce access latency for all FIFOs
              - Issue long read/write back-to-back transactions
              - Read rx_fifo as soon as read data valid
              - Clear interrupt quickly

            Checking:
              - Ensure transactions are transmitted/received correctly
            '''
      stage: V2
      tests: ["i2c_host_perf"]
    }
    {
      name: host_override
      desc: '''
            Test SCL/SDA override.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Program OVRD register

            Checking:
              - Ensure scl_o, sda_o are overridden
            '''
      stage: V2
      tests: ["i2c_host_override"]
    }
    {
      name: host_fifo_watermark
      desc: '''
            Test the watermark interrupt of fmt_fifo and rx_fifo.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Program random fmt_fifo and rx_fifo watermark level
              - Write data quickly to fmt_fifo and rx_fifo for triggering watermark interrupts

            Checking:
              - Ensure the fmt_fifo and rx_fifo watermark interrupts are asserted (fmt_threshold and rx_threshold)
              - Ensure the fmt_fifo and rx_fifo watermark interrupts stay asserted until cleared
              - Ensure receving correct number of fmt_fifo and rx_fifo watermark interrupts
            '''
      stage: V2
      tests: ["i2c_host_fifo_watermark"]
    }
    {
      name: host_fifo_overflow
      desc: '''
            Test the overflow interrupt for rx_fifo.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - DUT keeps receiving a number of bytes higher than the depth of rx_fifo

            Checking:
              - Ensure excess format bytes are dropped
              - Ensure rx_overflow interrupt are asserted
            '''
      stage: V2
      tests: ["i2c_host_fifo_overflow"]
    }
    {
      name: host_fifo_reset
      desc: '''
            Test fmt_fifo and rx_fifo reset.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Fill up the fmt_fifo with data to be sent out
              - Reset the FIFO randomly after a number of bytes shows up on fmt_fifo

            Checking:
              - Ensure the remaining entries are not show up after fmt_fifo is reset
            '''
      stage: V2
      tests: ["i2c_host_fifo_reset_fmt", "i2c_host_fifo_reset_rx", "i2c_host_fifo_fmt_empty"]
    }
    {
      name: host_fifo_full
      desc: '''
            Test fmt_fifo and rx_fifo in full states.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Send enough read and write requests to fmt_fifo
              - Hold reading data from rx_fifo until FIFO is full

            Checking:
              - Check FIFO full states by reading status register
            '''
      stage: V2
      tests: ["i2c_host_fifo_full"]
    }
    {
      name: host_timeout
      desc: '''
            Test stretch_timeout interrupts.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Set timeout enable bit of TIMEOUT_CTRL register
              - Program timeout values (higher than host SCL clock pulse) into TIMEOUT_CTRL register
              - Configure agent to pull down target (device) SCL after the bit 9 (ACK) is
                transmitted

            Checking:
              - Ensure stretch_timeout is asserted and a correct number is received

            '''
      stage: V2
      tests: ["i2c_host_stretch_timeout"]
    }
    {
      name: host_rx_oversample
      desc: '''
            Host mode: test oversampling on received channel.

            Stimulus:
              - Use input clock to sample the target SDA (sample with baud rate equal to 1)
              - Drive scl_rx using input clock

            Checking:
              - Read rx data oversampled value and ensure it is same as driven value
            '''
      stage: V2
      tests: ["i2c_host_rx_oversample"]
    }
    {
      name: i2c_host_mode_toggle
      desc: '''
            Host mode: disable host mode during host mode sequence

            Stimulus:
              - Host sends an address and data but receives NACK response
                since agent is reset before transaction is complete and
                host mode is disabled
            Checking:
              - Check if DUT goes to Idle state after Host mode is disabled
              - Check that transactions process normally after recovery by running a smoketest vseq.
              - Interrupt nak is raised
            '''
      stage: V2
      tests: ["i2c_host_mode_toggle"]
    }

    //-----------------------------------------------
    // Tests for I2C DUT in TARGET mode
    //-----------------------------------------------
    {
      name: target_smoke
      desc: '''
            Smoke test in which random (rx/tx) transactions are
            sent to the DUT and received asynchronously with scoreboard checks.

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively
              - Enable DUT target
              - Clear/Enable interrupt (if needed)
              - Randomize I2C timing in TIMING 0-4 registers and other parameters such as TL agent
                delays
              - Generate random addresses which are programmed to the DUT (target)
                and used for transaction sent by the agent (host)

            Checking:
              - Check the timing behavior of START, STOP, ACK, NACK, and "repeated" START
              - Read and write transfer matching
            '''
      stage: V1
      tests: ["i2c_target_smoke"]
    }
    {
      name: target_error_intr
      desc: '''
            Test the DUT-Target's 'unexp_stop' interrupt.

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively
              - Host agent send STOP after ACK

            Checking:
              - Ensure acq_stop is asserted and stay asserted until cleared
              - Ensure IP operation gets back to normal after on-the-fly reset finished
            '''
      stage: V3
      tests: ["i2c_target_unexp_stop"]
    }
    {
      name: target_glitch
      desc: '''
            Test I2C FSM state transitions in target mode of operation.

            Stimulus:
              - Configure DUT/Agent in Target/Host mode respectively
              - Program timing parameters
              - Assert start_det and stop_det variables in i2c_fsm.sv
                to trigger transition to AcquireStart and Idle states
            Checking:
              - Ensure DUT captures ACQ FIFO data as expected
              - After every glitch, issue a simple transaction to check if DUT is behaving as expected
            '''
      stage: V2
      tests: ["i2c_target_glitch"]
    }
    {
      name: target_stress_all
      desc: '''
            Support vseq (context) switching with random reset in between.

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively
              - Combine above sequences in one test to run sequentiall except CSR sequence
              - Randomly add reset between each sequence

            Checking:
              - Ensure transactions are transmitted/received correctly
              - Ensure reset is handled correctly
            '''
      stage: V2
      tests: ["i2c_target_stress_all"]
    }
    {
      name: target_stress_all_with_rand_reset
      desc: '''
            Support random reset in parallel with stress_all and tl_errors sequences.

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively
              - Combine above sequences in one test to run sequentially
                except CSR sequence
              - Randomly add reset within the sequences then switch to another one

            Checking:
              - Ensure transactions are transmitted/received correctly
              - Ensure reset is handled correctly
            '''
      stage: V3
      tests: ["i2c_target_stress_all_with_rand_reset"]
    }
    {
      name: target_maxperf
      desc: '''
            The Host Agent sends and receives transactions at max bandwidth.

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively
              - Reduce access latency for all FIFOs
              - Issue long read/write back-to-back transactions
              - Make all FIFOs accessible without any delay
              - Clear interrupt quickly

            Checking:
              - Ensure transactions are transmitted/received correctly
            '''
      stage: V2
      tests: ["i2c_target_perf"]
    }
    {
      name: target_fifo_empty
      desc: '''
            Test tx_empty and tx_nonempty interrupt.

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively
              - Agent sends transaction to the DUT

            Checking:
              - During read transaction, ensure tx_empty interrupt is asserted when no data left
                in tx_fifo otherwise tx_empty interrupt must be de-asserted
            '''
      stage: V2
      tests: ["i2c_target_stress_rd", "i2c_target_intr_smoke"]
    }
    {
      name: target_fifo_reset
      desc: '''
            Test tx_fifo and acq_fifo reset.

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively
              - Run read write mixed traffic
              - Assert reset any period between stop and the next start

            Checking:
              - Ensure the remaining entries are not show up after each fifio is reset
            '''
      stage: V2
      tests: ["i2c_target_fifo_reset_acq", "i2c_target_fifo_reset_tx"]
    }
    {
      name: target_fifo_full
      desc: '''
            Test acq_fifo and tx_fifo in full states.

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively
              - Send enough read and write requests to acq_fifo
              - Slow down acq FIFO read process to trigger 'acq_stretch' interrupt

            Checking:
              - Check FIFO full states by reading status register
              - Whether 'acq_stretch' interrupt raised
            '''
      stage: V2
      tests: ["i2c_target_stress_wr", "i2c_target_stress_rd", "i2c_target_intr_stress_wr"]
    }
    {
      name: target_timeout
      desc: '''
            Test the 'host_timeout' interrupt.

            Stimulus:
              - Configure DUT/Agent to Host/Target mode respectively
              - Set timeout enable bit of HOST_TIMEOUT_CTRL register
              - Agent stops sending clock during an ongoing transaction

            Checking:
              - Ensure the 'host_timeout' irq is asserted and a correct number is received

            '''
      stage: V2
      tests: ["i2c_target_timeout"]
    }
    {
      name: target_clock_stretch
      desc: '''
            Test clock stretch feature of DUT Target mode.
            For the write and address transaction, when acq_fifo is full, DUT starts to stretch clock.
            For the read transaction, when dut receives read command, the tx_fifo is empty,
            DUT starts to stretch clock.
            Using read / write mixed traffic, trigger stretch condition by slowing down acq / tx
            FIFO process.

            Checking:
            Ensure all read /write data received correct on the other side without dropping any data.
            '''
      stage: V2
      tests: ["i2c_target_stretch"]
    }
    {
      name: target_loopback
      desc: '''
            Test loopback mode, which is enabled by i2c.CTRL.LLPBK.
            '''
      stage: V3
      tests: [""]
    }
    {
      name: bad_address
      desc: '''
            Test sends transactions with a randomized address including two legal (programmed) addresses.
            Run this test with dut target mode.

            Checking:
            All transactions with illegal addresses should be dropped silently and should not disturb
            transactions with legal address
            '''
      stage: V2
      tests: ["i2c_target_bad_addr"]
    }
    {
      name: target_mode_glitch
      desc: '''
            Test handling of RSTART or STOP glitches in Target mode

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively
              - Insert a "glitched" transaction (early Sr/P)
                - Issue a new transfer(RSTART) to DUT during an active transfer
                - Stop current transfer(STOP) to DUT during an active transfer
              - Continue issuing requests to check if DUT FSM handles the transaction correctly

            Checking:
              - Ensure all transactions including glitches are observed in i2c.ACQDATA FIFO
            '''
      stage: V2
      tests: ["i2c_target_hrst"]
    }
    {
      name: target_fifo_watermark
      desc: '''
            Test the watermark interrupts of acq_fifo("acq_threshold") and tx_fifo("tx_threshold").

            Stimulus:
              - Configure DUT/Agent to Target/Host mode respectively.
              - Program random acq_fifo and tx_fifo watermark level.
              - Write data into the tx_fifo above the watermark level.
              - Stimulate transactions from the Agent that fills the acq_fifo above the watermark
                level and reads data to bring the tx_fifo below the watermark level.
              - When interrupt is asserted, read the acq_fifo to bring level back down below
                the watermark.

            Checking:
              - Ensure the acq_fifo and tx_fifo watermark interrupts are asserted when crossing
                above/below the configured thresholds.
              - As Status-Type interrupts, ensure the acq_fifo and tx_fifo watermark interrupts
                stay asserted until the causes are addressed.
            '''
      stage: V2
      tests: ["i2c_target_fifo_watermarks_acq", "i2c_target_fifo_watermarks_tx"]
    }
    {
      name: host_mode_config_perf
      desc: '''
            Test bus performance matches expectation based on configured timing parameters and clk_i

            It is possible to predict the expected bus frequency during data bytes for a given configuration
            in Host-Mode, assuming that both endpoints do not automatically flow-control the bus (due to
            e.g. data starvation or backpressure).

            Stimulus
              - Configure DUT/Agent to Host/Target mode respectively
              - Randomly configure clk_i and any valid set of timing parameters
              - Ensure all transactions experience no delays (no stretching, data starvation etc.)

            Checking:
              - Calculate expected bus performance based on configuration
              - Ensure that SCL frequency during data bytes matches expectation
            '''
      stage: V2
      tests: ["i2c_host_perf", "i2c_host_perf_precise"]
    }
    {
      name: host_mode_clock_stretching
      desc: '''
            Test that the Byte-Formatted Host-Mode FSM correctly handles a Target that clock-stretches

            Host-mode has support for Targets which perform clock-stretching, and we should verify that
            this implementation is robust for long and short periods of clock stretching. In particular,
            there is a implementation restriction of "THIGH >= 4" to guarantee clock stretching is
            detectable, so behaviour should be stimulated around that edge case.
            Target-deassertion of clock stretching may not necessarily be synchronous to the Host's clock,
            so ensure the Agent may release SCL asynchronously to the Host's input clock.

            Stimulus
              - Configure DUT/Agent to Host/Target mode respectively
              - Randomly configure clk_i and any valid set of timing parameters
                - Ensure sufficient test coverage around lower bound of "THIGH".
              - Configure Agent to stretch SCL for randomized times.

            Checking:
              - Ensure that data is correctly received, and transactions complete successfully, for the
                given valid space of timing parameters.
              - Ensure that any documented restrictions are consistent with the behaviour.
            '''
      stage: V2
      tests: ["i2c_host_stretch_timeout"]
    }
    {
      name: target_mode_tx_stretch_ctrl
      desc: '''
            Test that the TX_STRETCH_CTRL feature prevents the TX

            Stimulus
              - Configure DUT/Agent to Target/Host mode respectively.
              - Randomly enable TX_STRETCH_CTRL feature and write data into the TX FIFO prior to the
                transfer start.
              - Stimulate transactions, including transactions with multiple transfers
                interspersed by RSTART conditions.

            Checking
              - Ensure that the TARGET_EVENTS.TX_PENDING bit goes high for new reads when the
                TX_STRETCH_CTRL feature is enabled.
              - Ensure that the target holds SCL low and does not continue the transfer until the
                TARGET_EVENTS.TX_PENDING bit has cleared.
            '''
      stage: V2
      tests: ["i2c_target_tx_stretch_ctrl"]
    }
    {
      name: target_mode_nack_generation
      desc: '''
            Test Target-Mode automatic NACK generation, particularly around hardware features
            such as:
              - NACK when ACQFIFO is full.
              - NACK when TARGET_TIMEOUT_CTRL threshold has elapsed.
                - The timeout is measured against the cumulative stretching time within a single
                  transaction. This accumulation resets at the end of the current transaction.
                - All further bytes are NACK'd unconditionally, awaiting the end of the transaction.
              - ACQDATA.{NACK,NACKSTART,NACKSTOP} is correctly recorded in the ACQFIFO.
              - TARGET_NACK_COUNT recording the number of NACK'd bytes.
              - NACK on address-byte from stretch-timeout (CTRL.NACK_ADDR_AFTER_TIMEOUT)

            Stimulus
              - Configure DUT/Agent to Target/Host mode respectively.
              - Elicit clock stretching by
                - Allowing the ACQFIFO to become full
                - (reads) starving the TXFIFO for data
              - Only read the ACQFIFO when it is full, possibly adding extra delays so
                that new transactions while full will be automatically NACK'd

            Checking:
              - Check *all* bytes are NACK'd when the ACQFIFO is full.
                - Address bytes are an exception, as they may/may not be be NACK'd depending
                  on the configuration of CTRL.NACK_ADDR_AFTER_TIMEOUT.
              - Check that NACKs are generated when the clock is stretched past the threshold
                configured in TARGET_TIMEOUT_CTRL.
                - Check that ACQDATA.NACK_STOP is set in this case.
              - Check that ACQDATA.{NACK,NACKSTART} are set correctly when automatic NACKs have
                space to add a new entry to the ACQFIFO.
              - Check that ACQDATA.ABYTE contains the NACKd byte when automatic NACKs have space
                to add a new entry to the ACQFIFO.
              - Readback TARGET_NACK_COUNT to check that number of NACK'd bytes matches the
                number observed by the Agent.
            '''
      stage: V2
      tests: ["i2c_target_nack_acqfull", "i2c_target_nack_acqfull_addr", "i2c_target_nack_txstretch"]
    }
    {
      name: host_mode_halt_on_nak
      desc: '''
            Test that the Halt-on-NACK feature operates correctly. This functionality is in-effect
            when a Target NACKs a byte during a DUT-Controller Write Transfer, and the Byte-Formatted
            FSM halts awaiting software to intervene.
              - The active transaction should be halted whenever a NACK is observed (except if the
                FMTFIFO entry had the NAKOK bit set).
              - Upon halting in response to observing a NACK, the CONTROLLER_EVENTS.NACK bit is set,
                and the 'controller_halt' interrupt is asserted.
              - Sofware clearing (W1C) the CONTROLLER_EVENTS CSR also deasserts the 'controller_halt'
                interrupt, and allows the FSM to continue the transfer.
              - Upon continuation, the next entry from the FMTFIFO is popped.
              - If the HOST_NACK_HANDLER_TIMEOUT is enabled and expires while awaiting 'controller_halt' to
                be handled by software, hardware will automatically end the transaction, sending a Stop
                condition and transitioning the bus to Idle.
                - If the transaction ends due to this timeout, the CONTROLLER_EVENTS.UNHANDLED_NACK_TIMEOUT
                  bit is set to alert software.

            Stimulus
              - Configure DUT/Agent to Host/Target mode respectively.
              - Stimulate transactions, and randomly allow the Target to NACK.
              - Randomize the HOST_NACK_HANDLER_TIMEOUT / 'controller_halt' handler latency, to allow
                the timeout behaviour to trigger.
              - Software should randomly disable the HOST_NACK_HANDLER_TIMEOUT mid-stretch, to disable
                the automatic stop generation.

            Checking:
              - Data validity continues to match expectation when software uses the 'controller_halt'
                interrupt to change up the dataflow.
              - During halt, the bus should have SCL asserted, SDA released.
              - If the 'controller_halt' interrupt is unhandled, after the HOST_NACK_HANDLER_TIMEOUT delay
                the Controller FSM should be observed returning to Idle, and a Stop condition should have
                been generated to end the active transaction.
              - Check that the CONTROLLER_EVENTS.UNHANDLED_NACK_TIMEOUT bit is set when the timeout is
                reached.
            '''
      stage: V2
      tests: ["i2c_host_may_nack"]
    }
    {
      name: target_mode_n_byte_ack_control
      desc: '''
            Test the (Target-Mode) N-Byte ACK control mode
            When this mode is enabled, we should expect:
            - So long as there is space in the ACQ_FIFO, write data bytes will be ACK'd if the
              auto-decremeting ACK Counter (TARGET_ACK_CTRL.NBYTES) contains a positive value.
            - If the Auto ACK Counter is zero, the clock is stretched up to the timeout configured in
              TARGET_TIMEOUT_CTRL, if the timeout is enabled. If the timeout is reached (or is configured
              to zero), the pending write byte is NACK'd immediately.
            - While stretching, writes that set TARGET_ACK_CTRL.NACK cause the pending write byte to
              be NACK'd immediately.
            - While stretching, the pending write byte is visible in ACQ_FIFO_NEXT_DATA.
            - While stretching, writing a positive integer to the Auto ACK Counter causes the transfer
              to continue, ACK'ing the pending data byte.

            Stimulus
            - Configure DUT/Agent to Target/Controller mode respectively, enable ACK control mode by
              setting CTRL.ACK_CTRL_EN to 1.
            - Generate write transfers, and allow the ACK Counter to reach 0 / timeout on stretch.
            - While stretching, sometimes write to the TARGET_ACK_CTRL.NACK bit to NACK immediately.
            - While stretching, sometimes write a new value to the ACK Counter to continue ACK'ing
              automatically.

            Checks
            - Check the ACK Counter resets to 0 at the start of each transfer.
            - Check that NACKs are generated when controlled to do so, or stretch-timeouts expire.
            - When stretching, read back ACQ_FIFO_NEXT_DATA to check it matches the previously-written
              data byte.
            '''
      stage: V2
      tests: []
    }
    {
      name: target_mode_bus_timeout
      desc: '''
            Test the bus_timeout feature (TIMEOUT_CTRL.MODE.BUS_TIMEOUT) for target mode

            Stimulus
            - Configure DUT/Agent as Target/Controller respectively.
            - Configure TIMEOUT_CTRL with TIMEOUT_CTRL.MODE == BUS_TIMEOUT and a reasonable value.
            - Start a read transaction using the agent that addresses the DUT, but halt midway-through
              and hold SCL low.

            Checking
            - The TARGET_EVENTS.BUS_TIMEOUT field should be set upon timeout.
            - The 'cmd_complete' interrupt is asserted.
            - The target ends the transaction, and {AcqStop,AcqNackStop} is added to the ACQFIFO.
            '''
      stage: V2
      tests: []
    }
    {
      name: controller_mode_bus_timeout
      desc: '''
            Test the bus_timeout feature (TIMEOUT_CTRL.MODE.BUS_TIMEOUT) for controller mode

            Stimulus
            - Configure DUT/Agent as Controller/Target respectively.
            - Configure TIMEOUT_CTRL with TIMEOUT_CTRL.MODE == BUS_TIMEOUT.
            - Start a transaction, but midway-through the Agent should stop and hold SCL low.
            - Await the bus timeout to occur.
            - Software adds new entries to the FMTFIFO/RXFIFO, then clears 'CONTROLLER_EVENTS'
              to begin a new transaction.

            Checking
            - Upon the timeout, the controller is halted, and 'controller_halt' is asserted.
            - The CONTROLLER_EVENTS.BUS_TIMEOUT field should be set upon timeout.
            - Software can begin a new transaction from the halted state after clearing the
              'CONTROLLER_EVENTS' CSR.
            '''
      stage: V2
      tests: []
    }
    {
      name: controller_mode_bus_idle_delay
      desc: '''
            The MULTI_CONTROLLER_MONITOR_EN feature allows the DUT-controller to join an
            active bus environment without stomping over other controllers and active
            transactions.
            One part of this is to ensure bus idle periods between transactions are respected.

            Stimulus
            - Configure DUT/Agent as Controller/Agent respectively.
            - Populate FMTFIFO/RXFIFO for a Controller-Mode transaction.
            - Configure HOST_TIMEOUT_CTRL with the number of idle cycles.
            - Enable CTRL.MULTI_CONTROLLER_MONITOR_EN before enabling CTRL.ENABLEHOST

            Checking
            - Check that the DUT-Controller does not begin transmitting until at least
              the number of idle cycles in HOST_TIMEOUT_CTRL has elapsed.
            '''
      stage: V2
      tests: []
    }
    {
      name: loopback_test
      desc: '''
            I2C Controller and Target modes are capable of operating simultaneously, as a valid
            multi-controller application has an endpoint attempting to start a transaction, losing
            arbitration to another controller, then accepting the transaction as addressed to the
            Target-Mode function within the same device.
            A loopback test exercises a similar function.

            Stimulus
            - Disable any I2C agents.
            - Set both CTRL.ENABLEHOST and CTRL.ENABLETARGET
            - Drive a transaction that is addressed to one of the Target-configured addresses.

            Checking
            - That data integrity is maintained, and the transaction completes normally from the
              perspective of both operating modes.
            '''
      stage: V2
      tests: []
    }
    {
      name: multi_controller_clock_synchronization
      desc: '''
            The DUT-controller should observe the I2C clock synchronization procedure when transacting on
            the bus. This allows the arbitration process to function as specified.

            Testbench
            - Common I2C bus, with the following connected devices:
              - DUT
              - x1 Agent-Controller
              - x1 Agent-Target

            Stimulus
            - Configure both controllers to use different timing parameters
            - Configure both controllers to begin a transaction, where:
              - A significant portion of the data is identical near the start of the transaction.
              - The latter data is random, so either may win arbitration.

            Checking
            - Confirm the final synchronized bus SCL is comprised of:
              - tlow of the controller with the longer value
              - thigh of the controller with the shorter value
            - Check, based on the first difference in transaction data, that arbitration is resolved as expected.
            - The data integrity of the winning controller's transaction is maintained at the target.
            - The arbitration-lost DUT behaviour is consistent with other testcases
              (e.g. "multi_controller_arbitration_lost")
            '''
      stage: V2
      tests: []
    }
    {
      name: multi_controller_arbitration_lost_interference
      desc: '''
            The DUT-controller should detect other controllers driving the bus simultaneously by observing
            SDA, and correctly back-off after determining it has lost arbitration for this transaction.
            After software has addressed the HALT-state due to lost arbitration, and the DUT has awaited the
            bus to become free again, the DUT-controller should then be able to attempt to send a new transaction.

            This test manually yanks on SDA to induce the DUT into determining it has lost arbitration (There is
            no multi-controller-aware bus agent in use). Without another controller on the bus to create a valid
            stop-condition, the DUT can only determine the bus has become free again after the bus_inactive
            timeout has elapsed.

            Testbench
            - Common I2C bus, with the following connected devices:
              - DUT
              - x1 Agent-Target

            Stimulus
            - Configure DUT/Agent as Controller/Agent respectively.
            - Configure HOST_TIMEOUT_CTRL to a sensible value for a bus-idle delay timeout.
            - Begin to drive a normal DUT-Controller transaction.
            - The testbench pulls SDA low during the transaction (while the DUT has released it).
            - Software/TB awaits the DUT to indicate arbitration has been lost.
            - The Controller-Mode FIFOs are cleared, followed by re-loading with a new transaction.
            - The 'CONTROLLER_EVENTS' csr is cleared to allow the next transaction to begin.

            Checking
            - After determining it has lost arbitration, the DUT-Controller should have released the bus.
            - The 'sda_interference' event-type interrupt should assert.
            - The 'controller_halt' interrupt is asserted, and CONTROLLER_EVENTS.LOST_ARBITRATION is set.
            - The bus becomes free after the HOST_TIMEOUT_CTRL timeout has elapsed once arbitration is lost.
            - After clearing the CONTROLLER_EVENTS csr, a new transaction can complete normally once the
              bus becomes free.
            '''
      stage: V2
      tests: []
    }
    {
      name: multi_controller_arbitration_lost
      desc: '''
            The DUT-controller should detect other controllers driving the bus simultaneously by observing
            SDA, and correctly back-off after determining it has lost arbitration for this transaction.
            After software has addressed the HALT-state due to lost arbitration, and awaiting the bus to
            become free again, the DUT-controller should then be able to attempt to send a new transaction.

            This testpoint uses another multi-controller-aware agent on the bus, and configures/stimulates
            it to begin a transaction that will win arbitration over the DUT-Controller.

            Testbench
            - Common I2C bus, with the following connected devices:
              - DUT
              - x1 Agent-Controller
              - x1 Agent-Target

            Stimulus
            - TODO

            Checking
            -
            '''
      stage: V2
      tests: []
    }
    {
      name: target_mode_arbitration_lost_interference
      desc: '''
            The DUT-Target should lose-arbitration under the condition of simultaneously acting as a
            Target-Transmitter with another Target, and observing the conflicting value of SDA. This
            is possible during read transactions when two connected bus Targets have the same address.
            When this occurs, the DUT behaves as though it has determined it should NACK, then going
            on to NACK (release bus) for the remainder of the transaction, effectively awaiting the
            transaction to end.

            This testpoint uses the TB to manually induce an arbitration loss by pulling SDA low during
            the transmit-phase of a read transaction. Once the DUT-target has determined it has lost
            arbitration, it should go on to NACK, causing the transaction to end. Once the Agent-Controller
            sends the stop condition, the DUT-Target will return to idle, awaiting the next transaction.

            Testbench
            - Common I2C bus, with the following connected devices:
              - DUT
              - x1 Agent-Controller

            Stimulus
            - Enable Target-Mode in the DUT, and pre-populate the TXFIFO with read data.
            - Drive a read transaction addressed to the DUT-Target using the Agent-Controller
            - During the transaction, yank SDA low to cause the DUT-Target to lose arbitration.
            - Await the end of the transaction.
            - Clear the FIFO state, then stimulate a new transaction to test recovery.

            Checking
            - ACQFIFO entries for bytes before arbitration is lost are inline with normal expectations.
            - Once the DUT-Target loses arbitration, the 'cmd_complete' interrupt is asserted, and
              TARGET_EVENTS.ARBITRATION_LOST is set.
            - The DUT-Target does not attempt to drive the bus until the end of the transaction.
            - Once the transaction has concluded with a STOP condition, the final ACQFIFO.SIGNAL entry
              is NACK_STOP.
            - After clearing any fifo state and TARGET_EVENTS, the DUT-Target resumes normal operation
              for both reads and writes.
            '''
      stage: V2
      tests: []
    }
    {
      name: target_mode_arbitration_lost
      desc: '''
            The DUT-Target should lose-arbitration under the condition of simultaneously acting as a
            Target-Transmitter with another Target, and observing the conflicting value of SDA. This
            is possible during read transactions when two connected bus Targets have the same address.
            When this occurs, the DUT behaves as though it has determined it should NACK, then going
            on to NACK (release bus) for the remainder of the transaction, effectively awaiting the
            transaction to end.

            Testbench
            - Common I2C bus, with the following connected devices:
              - DUT
              - x1 Agent-Controller
              - x1 Agent-Target

            Stimulus
            - Configure the DUT and the Agent-Target to contain identical addresses.
            - Configure each Target with different response data.
              - Select randomized response data, where the start of the data component is identical
                between both Targets, and the end of the datastream diverges.
            - Use the Agent-Controller to drive a read transaction with the common address.
            - After the identical-addressed transaction has concluded, disable the Agent-Target, and
              stimulate a new transaction to test recovery.

            Checking
            - ACQFIFO entries for bytes before arbitration is lost are inline with normal expectations.
            - Once the DUT-Target loses arbitration, the 'cmd_complete' interrupt is asserted, and
              TARGET_EVENTS.ARBITRATION_LOST is set.
            - The DUT-Target does not attempt to drive the bus until the end of the transaction.
            - Once the transaction has concluded with a STOP condition, the final ACQFIFO.SIGNAL entry
              is NACK_STOP.
            - After clearing any fifo state and TARGET_EVENTS, the DUT-Target resumes normal operation
              for both reads and writes.
            - Check data integrity of the read transaction based on a pre-formed expectation of which
              target should win arbitration.
            '''
      stage: V2
      tests: []
    }
    {
      name: target_mode_smbus_maxlen
      desc: '''
            The I2C ACQFIFO has been sized such that it can absorb a max-length SMBus message (a 255-byte
            Block-Write) without software intervention.
            This directed test confirms this use-case is viable by generating a stimulus message of this
            size, while disabling any interrupt/polling handlers from interacting with the DUT. The
            message content is checked by the scoreboard to be correct and complete.
            '''
      stage: V2
      tests: ["i2c_target_smbus_maxlen"]
    }
  ]
  covergroups: [
    {
      name: i2c_interrupts_cg
      desc: '''
            Cover all the interrupts raised during I2C operation in both host and target mode
            Cross interrupt with INTERRUPT_TEST register
            '''
    }
    {
      name: i2c_fifo_reset_cg
      desc: '''
            Cover the FIFO reset bits in FIFO_CTL register
            Cross fmt_threshold with FMTRST
            Cross rx_threshold with RXRST
            Cross acq_threshold with FMTRST
            Cross rx_overflow with RXRST
            Cross acq_overflow with ACQRST
            Cross tx_threshold with TXRST
            '''
    }
    {
      name: i2c_fifo_level_cg
      desc: '''
             Cover the watermark levels for all FIFO interupts
             * Cross fmt_threshold interrupt with FMT_FIFO trigger level
             * Cross rx_threshold interrupt with RX_FIFO trigger level
             * Cross acq_threshold interrupt with ACQ_FIFO trigger level
             * Cross tx_threshold interrupt with TX_FIFO trigger level
             Cover the FIFO levels in HOST_FIFO_STATUS/TARGET_FIFO_STATUS
            '''
    }
    {
      name: i2c_operating_mode_cg
      desc: '''
            * Cover the operating mode (Host/Target) of DUT
            * Cover the operating mode (Host/Target) of TB
            * Cross the operating modes of DUT and TB
            * Cover the SCL frequency
            * Cross the SCL frequency with operating mode of DUT
            '''
    }
    {
      name: i2c_rd_wr_cg
      desc: '''
            Cover the address match feature of IP
            * Cross the address match with Host and Target mode of DUT
            Cover values in Read bytes
            * Cross with operating mode of I2C
            Cover values in Write bytes
            * Cross with operating mode of I2C
            '''
    }
    {
      name: i2c_status_cg
      desc: '''
            Cover the fields in i2c.STATUS register
            '''
    }
    {
      name: i2c_scl_sca_override_cg
      desc: '''
            Cover TX override enable bit TXOVRDEN
            Cover override value of SCL
            Cover override value of SDA
            Cover oversampled value of SCL
            Cover oversampled value of SDA
            Cross override value of SCL with override enable
            Cross override value of SDA with override enable
            '''
    }
    {
      name: i2c_cmd_complete_cg
      desc: '''
            Cover cmd_complete interrupt
            Cross cmd_complete with Host mode Read and Write operation
            Cross cmd_complete with Target mode Read and Write operation
            '''
    }
    {
      name: i2c_fmt_fifo_cg
      desc: '''
            Cover the values supported by FDATA register
            * Data byte (all flags set to zero)
            * Write address byte
            * Read address byte
            * Read a number of bytes from Target with NACK
            *  Cover values ranging from 1-128 Bytes
            * Read number of bytes from Target with ACK
            *  Cover values ranging from 1-128 Bytes
            * Stop byte
            * Stop after Start (invalid transmission)
            * Write address transmission with NAKOK
            * Data transmission with NAKOK
            * Stop data with NAKOK
            Cross bytes with NACK from Target
            * Cross data byte with NAKOK and NACK from Target
            * Cross address byte with NAKOK and NACK from Target
            * Cross data byte with NAKOK and NACK from Target
            '''
    }
    {
      name: i2c_acq_fifo_cg
      desc: '''
            Cover the values supported by ACQDATA
            * Write address byte
            * Read address byte
            * Data byte
            * ACK before STOP
            * NACK before STOP
            * RSTART with previous ACK for READ
            * RSTART with previous NACK for READ
            Cover NACK behaviours
            * NACK/NACKSTART bits
            * Cross against ACQFIFO level
            * Cross against TARGET_TIMEOUT_CTRL.EN
            '''
    }
    {
      name: i2c_scl_stretch_cg
      desc: '''
            Cover SCL stretch in Host mode
            * Cover clock stretch after address byte
            * Cross stretching against THIGH, particularly around the lower bound
            Cover SCL stretch in Target mode
            Cover Target mode SCL stretch in the following scenario
            * Read command received in ACQ FIFO and more than one entry in ACQ FIFO
            '''
    }
    {
      name: i2c_timing_parameters_cg
      desc: '''
            Cover different values of Timing parameters supported by I2C IP
            '''
    }
    {
      name: i2c_protocol_cov_cg
      desc: '''
            Cover protocol transitions supported by I2C with single host
            * Cross protocol transitions with mode of operation of DUT (Host or Target)
            Cover host mode and target mode enable bits
            Cover mistimed Start or Stop glitches in target mode
            Cover the number of bytes read from Target
            Cover the number of bytes written to Target
            * Cover number of bytes as buckets instead of covering every value of number of bytes
            * Cross the number of bytes read in Target and Host mode of DUT
            * Cross the number of bytes written in Target and Host mode of DUT
            '''
    }
    {
      name: i2c_b2b_txn_cg
      desc: '''
            Cover combination of back to back read and write transfers covered in test suite
            Instantiate a separate covergroup for host and target mode of operation
            '''
    }
    {
      name: i2c_nack_timeout_cg
      desc: '''
            Cover range of possible timeout val in TARGET_TIMEOUT_CTRL
            '''
    }
    {
      name: i2c_halt_on_nack_cg
      desc: '''
            Cover range of possible timeout val in HOST_NACK_HANDLER_TIMEOUT
            * Cross timeout val with 'nak' handler latency {gt, lt}
            Cover STATUS.HOST_DISABLED_NACK_TIMEOUT
            Cover mid-halt disable of timeout en
            '''
    }
  ]
}
