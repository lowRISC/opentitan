// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{
  name: "usbdev"
  // TODO: remove the common testplans if not applicable
  import_testplans: ["hw/dv/tools/dvsim/testplans/csr_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/mem_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/intr_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/alert_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/tl_device_access_types_testplan.hjson",
                     "usbdev_sec_cm_testplan.hjson"]
  testpoints: [
    {
      name: smoke
      desc: '''
            Smoke test of simple packet transmission in both directions over the USB.

            - DV environment programs CSRs for suitable pin configuration, leaving the device
              unconnected by not driving the DP pullup.
            - Program CSRs to enable SETUP packet reception and OUT traffic on Endpoint Zero.
            - Present a buffer description in the AvBuffer, to receive the SETUP packet.
            - Enable the interface (assert DP pull up) to indicate device presence.
            - DV host-side detects device presence.
            - DV host-side transmits a SETUP packet to Address 0, Endpoint 0.
            - Check that the description of the SETUP packet appears in the RxFiFo, with the
              expected 'setup' indicator, buffer ID, and a packet length of 8 bytes.
            - Check that the SETUP packet has been received into the packet buffer memory.
            - DV host-side checks that ACK was received from usbdev in response to the SETUP packet.
            '''
      stage: V1
      tests: ["usbdev_smoke"]
    }
    {
      name: in_trans
      desc: '''
            Verify read and write 1 to clear corresponding bits of the register.

            - Configure the device for an IN transaction to a particular endpoint.
            - Read the register value to get current status of sent packets and
              then write 1s to the bits which are already high.
            - Verify that the Reading the register will show only those bits high whose corresponding
              endpoints have sent a packet and received ACK from host.
            - Writing ones must clear the corresponding bits of the register
            - Excluding the ACK for isochronous transfer.
            '''
      stage: V2
      tests: ["usbdev_in_trans"]
    }
    {
      name: data_toggle_clear
      desc: '''
            Verify the ability to clear Data Toggle bits.

            - Set any random bit of the data toggle register from bit 0 to bit 11 then
              initiate an IN/OUT transaction on the corresponding endpoint whose bit is asserted.
            - Verify that writing 0 to a particular bit (bits 0-11) resets the data toggle bit for
              that particular IN/OUT endpoint to DATA0, to resynchronize with the USB host.
            - But it does not prevent toggling of the flags upon successful transmission/receipt of
              subsequent data packets.
            '''
      stage: V2
      tests: []
    }
    {
      name: phy_pins_sense
      desc: '''
            Verify the read functionality of phy_pins_sense register via TLUL interface.

            - read the phy_pins_sense register via TLUL interface and sample the inputs
              and outputs values of the DUT at that particular instance.
            - Verify that the read value of the register should reflect the sampled values of the
              inputs and outputs.
            '''
      stage: V2
      tests: []
    }
    {
      name: wake_events
      desc: '''
            Verify the read functionality of wake_event register via TLUL interface.

            - Allow the usbdev to go to deep sleep mode then read the wake_events register
              from the TLUL interface.
            - Verify that the read value of the register should reflect the correct value of module_aon
              as well as bus_disconnected and bus_reset during deep sleep.
            '''
      stage: V2
      tests: []
    }
    {
      name: av_buffer
      desc: '''
            Verify the functionality of availability of buffer.

            - write the [4:0] bit buffer ID in the avbuffer.
            - Then send a setup/out token to the usbdev followed by data packet.
            - Then read from the buffer ID written in the AVBUFFER register.
            - Verify that the SRAM buffer supplied to the avbuffer should contain the same data
              as received in the data packet payloads.
            '''
      stage: V2
      tests: ["usbdev_av_buffer"]
    }
    {
      name: rx_fifo
      desc: '''
            Verify the functionality of rx fifo.

            - send an OUT transaction to the USBdev with appropriate data packets.
            - After successful reception read the buffer id, setup/out flag and size
              from the RX fifo earlier.
            - Then perform a read operation on the SRAM with address and control info
              provided by the rxfifo.
            - Verify that the data read from the SRAM should contain the same data as sent to the
              device in the data packet of the OUT transaction.
            '''
      stage: V2
      tests: []
    }
    {
      name: phy_config_tx_osc_test_mode
      desc: '''
            Verify the oscillator test mode when phy_config.tx_osc_test_mode is enabled.

            - Set the phy_config.tx_osc_test_mode.
            - Verify that the device starts transmitting the J/K pattern continuously.
            '''
      stage: V2
      tests: []
    }
    {
      name: phy_config_eop_single_bit_handling
      desc: '''
            Verify the correct behavior of the phy_config.eop_single_bit configuration in the PHY module
            where a single SE0 bit is recognized as an end of packet, while two successive bits are
            required otherwise.

            - set eop_single_bit field true in the phy config register and then send a packet with
              a single SE0 bit at the end followed by J state.
            - Verify that the device should recognize this eop as valid and should not raise any link_err interrupts.
            '''
      stage: V2
      tests: []
    }
    {
      name: phy_config_pinflip
      desc: '''
            Verify the functionality of Pinflip that is used to flip Dp and Dn.

            - set the pinflip field true in the phy_config register.
            - Verify that the usb_dn goes high and usb_dp will become high impedance (Z).
            '''
      stage: V2
      tests: []
    }
    {
      name: phy_config_usb_ref_disable
      desc: '''
            Verify the reference signal generation for clock synchronization.

            - set the usb_ref_disable field true in the phy_config register and SOF packet
              is sent to the device.
            - Verify that the clock synchronization signal usb_ref_0 and usb_ref_val will not be generated.
            '''
      stage: V2
      tests: []
    }
    {
      name: max_length_out_transaction
      desc: '''
            Verify the packet of maximum payload length for OUT tranasction.

            - rxenable_out bit is set along with ep_enable_out.
            - Hosts send an OUT token followed by the data packet with maximum payload length of 64 bytes.
            - Verify that the Device acknowledge through an ACK in handshake packet.
            '''
      stage: V2
      tests: ["usbdev_max_length_out_transaction"]
    }
    {
      name: max_length_in_transaction
      desc: '''
            Verify the packet of maximum payload length for IN tranasction.

            - Hosts send an IN token than device sends the data packet with maximum payload length of 64 bytes.
            - Verify that the usbdev shall respond appropriately to the ACK by recording that IN DATA packet
              was successfully transmitted.
            '''
      stage: V2
      tests: []
    }
    {
      name: min_length_out_transaction
      desc: '''
            Verify the packet of minimum payload length for OUT tranasction.

            - rxenable_out and ep_enable_out is set than Hosts send an OUT token followed by the
              data packet with minimum payload length of 0 bytes.
            - Verify that the Device acknowledge through PID ACK bit in the handshake packet.
            '''
      stage: V2
      tests: ["usbdev_min_length_out_transaction"]
    }
    {
      name: min_length_in_transaction
      desc: '''
            Verify the packet of minimum payload length for IN tranasction.

            - Hosts send an IN token than device sends the data packet with minimum payload length of 0 bytes.
            - Verify that the Host acknowledge through PID ACK bit in the handshake packet and once the ACK
              is received then in_sent register's bit will be 1.
            '''
      stage: V2
      tests: []
    }
    {
      name: random_length_out_trans
      desc: '''
            Verify the packet of random payload length for OUT tranasction.

            - rxenable_out  bit is set than Host sends an OUT token followed by the data packet with
              random payload length between 0 and 64 bytes.
            - Length from 0 inclusive to 64 inclusive should be supported.
            - Verify that the Device acknowledge through PID ACK bit in the handshake packet.
            '''
      stage: V2
      tests: ["usbdev_random_length_out_trans"]
    }
    {
      name: random_length_in_trans
      desc: '''
            Verify the packet of random payload length for IN tranasction.

            - Hosts send an IN token then device sends the data packet with random payload length between 0
              and 64 bytes.
            - Verify that the Host acknowledge through PID ACK bit in the handshake packet then in_sent
              register's bit will be 1.
            '''
      stage: V2
      tests: []
    }
    {
      name: out_stall
      desc: '''
            Verify the functionality of OUT endpoint stall.

            - sets the out_stall register's bit for a particular endpoint then host issues an OUT token packet
              followed by data packet for that endpoint.
            - Verify that the device responds with the PID STALL Handshake.
            '''
      stage: V2
      tests: ["usbdev_out_stall"]
    }
    {
      name: in_stall
      desc: '''
            Verify the functionality of IN endpoint stall.

            - sets the in_stall register's bit to 1 for a particular endpoint then host issues an IN token packet
              for a particular endpoint.
            - Verify that the device responds with the PID STALL Handshake.
            '''
      stage: V2
      tests: []
    }
    {
      name: out_iso
      desc: '''
            Verify the functionality of isochronous transfer for OUT transaction.

            - sets the out_iso register's bit to 1 for a paricular endpoint then host issues an OUT token to that
              endpoint followed by the OUT data packet.
            - Verify that the device will not send any handshake packet.
            '''
      stage: V2
      tests: []
    }
    {
      name: in_iso
      desc: '''
            Verify the functionality of isochronous transfer for IN transaction.

            - sets the in_iso register's bit to 1 for an endpoint then host issues an IN token to that endpoint.
            - Verify that the device will send data packet but will not expect any handshake packet from host.
            '''
      stage: V2
      tests: []
    }
    {
      name: pkt_received
      desc: '''
            Verify the interrupt functionality of packet reception.

            - send an OUT/SETUP token packet to an enabled endpoint while enabling the INTR_ENABLE[0] followed by the data.
            - Verify that the corresponding interrupt pin goes high after the successful OUT/SETUP packet reception.
            '''
      stage: V2
      tests: ["usbdev_pkt_received"]
    }
    {
      name: pkt_sent
      desc: '''
            Verify the interrupt functionality of packet transmission.

            - send an IN transaction token packet to an enabled endpoint while INTR_ENABLE[1] is 1.
            - Verify that the corresponding interrupt pin goes high after sending the successful IN packet.
            '''
      stage: V2
      tests: ["usbdev_pkt_sent"]
    }
    {
      name: disconnected
      desc: '''
            Verify that if VBUS is lost then link is disconnected.

            - VBUS(sense) is set to 0 while INTR_ENABLE[2] is 0.
            - Verify that the corresponding Interrupt pin goes high after the link disconnected.
            '''
      stage: V2
      tests: []
    }
    {
      name: host_lost
      desc: '''
            Verify that if link is active (ie. not completely idle) but SOF was not received from
            host for 4.096 ms, the 'host lost' interrupt becomes asserted.

            - Note that there must be _some_ non-idle signaling on the USB during this time because
              otherwise the link state will become suspended, and 'host lost' will not be signaled.
            - Send SOF from host after 4.096 ms while INTR_ENABLE [3] is set.
            - Verify that the corresponding interrupt pin goes high once the host is lost.
            - SOF should normally be received every 1 ms.
            '''
      stage: V2
      tests: []
    }
    {
      name: link_reset
      desc: '''
            Verify that if the link is at SE0 longer than 10 us indicating a link reset
            (host asserts for min 10 ms, device can react after 2.5 us) then link reset
            will raise.

            - Send an SE0 Signal for close to the 10 ms. while INTR_ENABLE [4] is set.
            - Verify that the interrupt pin link_reset goes high once the link reset.
            '''
      stage: V2
      tests: []
    }
    {
      name: link_suspend
      desc: '''
            Verify that if the line has signaled J (Idle) for longer than 3 ms and is therefore in
            suspend state the 'link suspend' will be raised.

            - Leave the link in idle state for more than 3 ms while enable the INTR_ENABLE [5] is set and
              also set the wake_control.suspend_req afterwards.
            - Verify that the interrupt pin goes high once the link suspended.
            '''
      stage: V2
      tests: []
    }
    {
      name: link_resume
      desc: '''
            Verify that when the link becomes active again after being suspended link resume will raise.

            - First suspend the link by keeping J signal for 3.1ms and then resume it by changing the
              polarity for 20ms. While the INTR_ENABLE [6] bit is set , also set the wake_control.wake_ack signal.
            - Verify that the interrupt pin link_resume goes high once the link resume.
            '''
      stage: V2
      tests: []
    }
    {
      name: av_empty
      desc: '''
            Verify the functionality of AV FIFO when av_empty signal is high and device interface is enabled.

            - Enable the interrupt for AV empty by setting INTR_ENABLE[7] and then send back to back
              packets to the device.
            - Don't service the packet reception by popping out from rx_fifo.
            - Verify that this interrupt pin goes high once the available fifo is empty.
            '''
      stage: V2
      tests: []
    }
    {
      name: rx_full
      desc: '''
            Verify the functionality of rx FIFO when rx_full signal is high and device interface is enabled.

            - Enable the interrupt for RX full by setting INTR_ENABLE[8] and then send back to back packets
              to the device.
            - Don't just service the packets received by popping out from rx_fifo.
            - Verify that this interrupt pin should go high once the received fifo is full.
            '''
      stage: V2
      tests: []
    }
    {
      name: av_overflow
      desc: '''
            Verify that if a write was done to the Available Buffer FIFO when the FIFO was full then
            av_overflow signal is high.

            - Write a particular buffer ID to the available buffer FIFO when it is already full.
            - Verify that this interrupt pin goes high indicating that the available fifo has
              reached the overflowing condition.
            '''
      stage: V2
      tests: []
    }
    {
      name: enable
      desc: '''
            Verify that USB connect to interface when enable is set.

            - set USB_CTRL_enable pin high.
            - Make sure phy_config_pinflip isn't set.
            - Verify that the usb_dp_pullup_o pin goes high.
            '''
      stage: V2
      tests: ["usbdev_enable"]
    }
    {
      name: resume_link_active
      desc: '''
            Verify that when Write a 1 to this bit to instruct usbdev to jump to the LinkResuming state
            then write will only have an effect when the device is in the LinkPowered state.

            - Perform no operation in J state for more than 3 ms.
            - Read the link state from usbstate register to see if it is in powered state and then send the
              resume signal (K state) for 20 ms and set the usbctrl.resume_link_active.
            - Verify that the resume_link_active interrupt goes high and device will be resumed.
            '''
      stage: V2
      tests: []
    }
    {
      name: device_address
      desc: '''
            Verify that the device ignores all the packets that have invalid address.

            - Assigned device address to (usbctrl[22:16]) and send packets to a valid address.
            - Send packets to invalid address.
            - Verify that the device responds to all packets sent by the DV environment (USB side)
              that are sent to its assigned address.
            - Verify that the device ignores all packets that are sent to other address.
            '''
      stage: V2
      tests: []
    }
    {
      name: link_in_err
      desc: '''
            Verify that if a packet to an IN endpoint started to be received but was then dropped due to an error
            then link_in_err will raise.

            - Send an IN token to the device for initiating an IN transaction.
            - The device should respond with IN data packets.
            - DV environment returns an invalid crc16 or unexpected PID in the handshake packet.
            - Verify that the link_in_err should go high following the handshake packet sent by the host.
            '''
      stage: V2
      tests: []
    }
    {
      name: rx_crc_err
      desc: '''
            Verify that if a CRC error occurred then rx_crc_err will raise.

            - send a packet(token/handshake/data) to the device while intentionally corrupting any of the CRC bits.
            - Verify that the rx_crc_err should go high following the reception of erroneous packet.
            '''
      stage: V2
      tests: []
    }
    {
      name: rx_pid_err
      desc: '''
            Verify that if an invalid packed identifier (PID) was received then rx_pid_err will raise.

            - send an invalid PID to the device with the higher bits not complementing the lower bits.
            - Verify that the interrupt pin goes high indicating PID error.
            '''
      stage: V2
      tests: []
    }
    {
      name: rx_bitstuff_err
      desc: '''
            Verify that if an invalid bit stuffing was received then rx_bitstuffing_err will raise.

            - generate a packet with 7 consecutive ones (bypassing bitstufffing) on data line.
            - Verify that the interrupt pin goes high indicating bitstuff error.
            '''
      stage: V2
      tests: []
    }
    {
      name: link_out_err
      desc: '''
            Verify that if a packet to an OUT endpoint started to be received but was then dropped due to an error
            then link_out_err will raise.

            - send an out packet to the device with invalid crc, token, avbuffer_empty, rx_fifo full conditions.
            - Verify that the interrupt pin goes high indicating an error in the link in OUT transaction.
            '''
      stage: V2
      tests: []
    }
    {
      name: invalid_data1_data0_toggle_test
      desc: '''
            Verify the functionality of invalid toggling of Data1 and Data0 bits.

            - send an out data packet to the device in an ongoing transaction without toggling data0 and data1
              PIDs in consecutive data packets.
            - Verify that the interrupt pin goes high indicating an error in the link while OUT transaction.
            '''
      stage: V2
      tests: []
    }
    {
      name: setup_stage
      desc: '''
            Verify the SETUP stage of enumeration.

            - Send a setup token with a valid setup packet containing the address(0), endpoint number(0)
              followed by Data0 packet requesting information about device i.e. descriptors.
            - Verify that the device ACK the setup packet and prepare for the data stage.
            '''
      stage: V2
      tests: []
    }
    {
      name: in_data_stage
      desc: '''
            Verify the IN Transfer with Device Descriptor Data.

            - Issue an IN token to request control data from the device.
            - Verify that the device should respond with a DATA packet containing the information
              required by host or a NAK packet if there is no data available.
            '''
      stage: V2
      tests: []
    }
    {
      name: out_data_stage
      desc: '''
            Verify the OUT Transfer with DEVICE Settings.

            - Send an OUT token followed by a data packet containing control data to the device.
            - Verify that the device should acknowledge the successful receipt of data by sending
              an ACK packet or return a NAK if it is still processing previous data.
            '''
      stage: V2
      tests: []
    }
    {
      name: out_status_stage
      desc: '''
            Verify the OUT Transfer for Status Reporting.

            - If the host used IN tokens during data stage then status stage is initiated with an OUT token.
            - Send an OUT token followed by a zero-length DATA0 data packet to the device.
            - Verify that the device should acknowledge the successful receipt of the status request by
              sending an ACK packet or return NAK if it is still processing or STALL if an error occurred.
            '''
      stage: V2
      tests: []
    }
    {
      name: in_status_stage
      desc: '''
            Verify the IN Transfer for Status Reporting.

            - If the host used OUT tokens during data stage then status stage must start with an IN Token.
            - Verify that the device must respond with zero length Data0 packet for succesful completion
              STALL for error and NAK for busy followed by ACK from Host.
            '''
      stage: V2
      tests: []
    }
    {
      name: endpoint_access
      desc: '''
            Verify the accessibility of all endpoint when endpoints are enabled.

            - Access all the endpoints of the device in IN and OUT direction by enabling ep_out_enable and
              ep_in_enable along with rxenable_out for OUT transaction.
            - Verify that the device should allow access to all endpoints by responding with ACK for OUT
              accesses and data_packet for IN Accesses.
            '''
      stage: V2
      tests: []
    }
    {
      name: disable_endpoint
      desc: '''
            Verify that packet transmission (IN and SETUP) and reception requests (IN) are ignored when
            endpoints are disabled.

            - Disable an endpoint by clearing bit of ep_out_enable and ep_in_enable.
            - Then initiate an IN/OUT transaction to that endpoint.
            - Verify that the Out transactions as well as IN transactions sent to the device on the
              particular endpoint will be ignored.
            '''
      stage: V2
      tests: []
    }
    {
      name: out_trans_nak
      desc: '''
            Verify the functionality of OUT transaction when rxenable_out is not set.

            - clear a particular endpoint bit for rx_enable_out register.
            - Then send an out transaction to that endpoint.
            - Verify that the OUT transactions shall be NAKED by OUT endpoints.
            '''
      stage: V2
      tests: ["usbdev_out_trans_nak"]
    }
    {
      name: setup_trans_ignored
      desc: '''
            Verify the functionality of SETUP transaction when rxenable_setup is not set.

            - clear a particular endpoint bit for rxenable_setup register.
            - Then send a setup transaction to that endpoint.
            - Verify that the SETUP transactions shall not be received by enabled OUT endpoints
              if rxenable_setup is not set.
            '''
      stage: V2
      tests: ["usbdev_setup_trans_ignored"]
    }
    {
      name: nak_trans
      desc: '''
            Verify the functionality of OUT transaction when set_nak_out is set.

            - Set_nak_out and rxenable_out are both set
            - Issue OUT transaction and observe it complete.
            - Observe rxenable_out cleared.
            - Issue OUT transaction and observe it get NAK'd.
            - Verify that the OUT transactions shall be NAKED for disabled endpoint and
              the corresponding bit in rxenable_out register will be cleared.
            '''
      stage: V2
      tests: ["usbdev_nak_trans"]
    }
    {
      name: stall_trans
      desc: '''
            Verify that by enabling in_stall/out_stall shall cause STALL response to
            attempted IN/OUT transactions.

            - setting in_stall/out_stall register bits for a particular transaction.
            - Verify that we will get STALL response when try to attempt IN/OUT transactions.
            '''
      stage: V2
      tests: []
    }
    {
      name: setup_priority_over_stall_response
      desc: '''
            Verify that by enabling STALL response shall not prevent the reception of a SETUP
            transaction/packet.SETUP shall clear both in_stall and out_stall bits for the endpoint.

            - Configure an endpoint for stall response to out transactions then send a setup
              transaction to the device on stalled endpoint.
            - Verify that the SETUP being higher in priority shall clear both in_stall and out_stall
              bits for that endpoint
            '''
      stage: V2
      tests: []
    }
    {
      name: stall_priority_over_NAK
      desc: '''
            Verify that if the configuration has both STALL and NAK enabled the STALL
            handshake will take priority.

            - Configure an endpoint with STALL as well as NAK responses then issue an OUT
              transaction to that endpoint.
            - Verify that the STALL being higher in priority will take precedence over NAK responses.
            '''
      stage: V2
      tests: []
    }
    {
      name: pending_in_trans
      desc: '''
            Verify that the a Link Reset or SETUP transaction cancels any waiting IN transactions
            by clearing the rdy bit in the configin register of all endpoints.

            - configure an endpoint for transmission by setting field in configin_ep register and
              set the rdy bit 1.Then send a SETUP transaction to that endpoint or issue a link reset.
            - Verify that the rdy bit in the configin_ep will be cleared and pend bit will be set to 1.
            '''
      stage: V2
      tests: []
    }
    {
      name: streaming_test
      desc: '''
            Verify the streaming capability of an endpoint in OUT transaction mode.

            - Issue back to back data packets to a particular enabled endpoint.
            - Read the information from RX fifo as soon as a packet is received
              along with the buffer in the SRAM.
            - Send the buffer ID back to Available buffer FIFO after successful buffer read.
            - Verify that the device must be capable of handling the streaming traffic for a
              large number of iterations without Available buffer becoming empty and RX FIFO
              going full.
            '''
      stage: V2
      tests: []
    }
    {
      name: max_clock_error_untracked
      desc: '''
            Verify the functionality of DUT at maximum clock frequency deltas.
            This test does not attempt to model the adjustment of the usb_clk oscillator,
            in response to SOF packets received from the USB host, and therefore cannot
            support the full frequency mismatch required by the USB 2.0 protocol specification.

            - Clock the device and the agent with opposite extremes of allowable frequency
              ranges and initiate a transaction with maximum data length.
            - Verify that the transactions occur successfully between the device and host agent
              in both directions, and that all transmitted bytes are decoded correctly.
            - Verify that there are no reports of bit stuffing errors or CRC errors.
            '''
      stage: V2
      tests: []
    }
    {
      name: max_clock_error_tracking
      desc: '''
            Verify the functionality of DUT at maximum clock frequency difference, adjusting the
            frequency of 'usb_clk' in response to the arrival times of the SOF packets sent
            from the USB host agent.

            - Implement tracking of the SOF packets from the host, using the 'usb_ref_pulse_o'
              signal from the DUT to adjust the USB device clock.
            - With the USB host agent operating at the maximum frequency permissible within the
              USB 2.0 protocol specification, start the USB device operating at the minimum
              permissible frequency and check that SOF packets are still received and decoded
              correctly.
            - Check that the 'usb_ref_pulse_o' signal is produced as expected, and that the
              'usb_clk' signal increases in frequency to match that of the USB host agent.
            - Verify that full length packet transmission to and from the host occurs successfully
              without reports of bit stuffing errors or CRC errors.
            - Repeat the above with the USB host agent at the minimum permissible frequency and
              the USB device starting at the maximum frequecy.
            '''
      stage: V2
      tests: []
    }
    {
      name: max_phase_error
      desc: '''
            Verify that the device and host can work in different phase corners of the 48 MHz clock.

            - Clock the device and the agent with opposite corners of phases and initiate a
              transaction with maximum data length.
            - Verify that the transaction between the host agent and device must be successful by
              raising interrupts for succesful packet reception or transmission after the end
              of the transaction.
            '''
      stage: V2
      tests: []
    }
    {
      name: min_inter_pkt_delay
      desc: '''
            Verify the minimum 2 bit times from the SE0-to-J transition (from EOP) to the
            J-to-K transition.

            - Ensure that the successive packets follow the minimum interpacket delay.
            - Verify that the device will raise a link_err interrupt if the gap between
              successive packets is less than 2 bit times.
            '''
      stage: V2
      tests: []
    }
    {
      name: max_inter_pkt_delay
      desc: '''
            Verify the maximum 6 bit times from the SE0-to-J transition (from EOP) to
            the J-to-K transition.

            - Ensure that the successive packets follow the maximum interpacket delay.
            - Verify that the device must raise timeout error for transaction that takes
              more than max interpacket delay.
            '''
      stage: V2
      tests: []
    }
    {
      name: device_timeout_missing_host_handshake
      desc: '''
            Verify that the device must time out an IN transaction if it does not
            receive handshake packets from the host.

            - Initiate a transaction with USBdev with an IN token and accept data packets
              from the device.
            - Don't send any handshake packet to the device.
            - Verify that after waiting for a specific timeout limit the device will timeout
              that transaction and can be seen from the in_sent register of the device.
              The register bit will be 0 for the endpoint involved in the transaction.
            '''
      stage: V2
      tests: []
    }
    {
      name: device_timeout
      desc: '''
            Verify that the device times out transactions when a host packet is 18 bit times
            after the preceding one in the same transaction.

            - Generate a host packet 18 bit times than the preceding packet in the same
              transaction.
            - Verify that the device time out the transaction when a host packet is 18 bit times
              after the preceding one in the same transaction.
            '''
      stage: V2
      tests: []
    }
    {
      name: nak_to_out_trans_when_avbuffer_empty_rxfifo_full
      desc: '''
            Verify that the device sends out NAK responses to OUT transactions when
            available buffer is empty and RX FIFO is full.

            - send out packets to the device at such a rate that avbuffer gets empty and
              RX Fifo becomes full.
            - Verify that the device unable to consume packets at such a rate will set NAK
              responses even though endpoint is enabled.
            '''
      stage: V2
      tests: []
    }
    {
      name: aon_wake_resume
      desc: '''
            Verify that the AON/Wake module is able to detect Resume Signaling and indicate that
            via the USB device register interface.

            - Connect the USB device to the USB host model.
            - Send Suspend Signaling to the USB device.
            - Verify that the 'link_suspend' interrupt is raised indicating that the USB has been
              Idle (J) for at least 3ms.
            - Enable the AON/Wake module, leaving it to maintain the pull up state.
            - Initiate Resume Signaling, driving the USB into the 'K' state.
            - Check that the 'wake_req_aon_o' signal from the 'usbdev_aon_wake' module becomes
              asserted.
            - Read from the 'wake_events' CSR of the USB device and check that the 'bus_not_idle'
              bit is asserted.
            - Disable the AON/Wake module and verify that the USB device is still connected,
              ie. the DP pullup is enabled and DP is high.
            '''
      stage: V2
      tests: []
    }
    {
      name: aon_wake_reset
      desc: '''
            Verify that the AON/Wake module is able to detect Reset Signaling and indicate that
            via the USB device register interface.

            - Connect the USB device to the USB host model.
            - Enable the AON/Wake module, leaving it to maintain the pull up state.
            - Perform a Bus Reset, driving SE0 state onto the USB for at least 10us; the
              specification requires at least 10ms of Reset Signaling for a full reset, but the
              AON/Wake module should respond a lot faster, to allow time for chip start up and
              software reinitialization.
            - Check that the 'wake_req_aon_o' signal from the 'usbdev_aon_wake' module becomes
              asserted.
            - Read from the 'wake_events' CSR of the USB device and check that the 'bus_reset'
              bit is asserted.
            - Disable the AON/Wake module and verify that the USB device is still connected,
              ie. the DP pullup is enabled and DP is high.
            '''
      stage: V2
      tests: []
    }
    {
      name: aon_wake_disconnect
      desc: '''
            Verify that the AON/Wake module is able to detect Bus Disconnection and indicate that
            via the USB device register interface.

            - Connect the USB device to the USB host model.
            - Enable the AON/Wake module, leaving it to maintain the pull up state.
            - Verify that the DP pull up remains asserted, indicating the presence of the device
              on the USB.
            - Lower the VBUS/SENSE signal.
            - Check that the 'wake_req_aon_o' signal from the 'usbdev_aon_wake' module becomes
              asserted.
            - Read from the 'wake_events' CSR of the USB device and check that the 'disconnected'
              bit is asserted.
            - Check that the DP pull up is no longer asserted; it shall be dropped by the
              usbdev_aon_wake module to protect against spurious reconnection.
            - Disable the AON/Wake module and verify that the USB device remains disconnected.
            '''
      stage: V2
      tests: []
    }
    {
      name: invalid_sync
      desc: '''
            Randomized interspersing of valid and invalid USB traffic. Generate bit-level changes
            on the USB that do not constitute valid SYNC signaling, interspersed with valid USB
            traffic to/from the device.

            - Set up the device with a single IN and a single OUT endpoint.
            - Fully populate the Available OUT Buffer FIFO.
            - Stream and check known traffic to (OUT) and from (IN) the device, with the CSR
              side simply returning unmodified every OUT packet that is received.
            - Randomly select whether to send an OUT packet, request an IN packet or generate
              invalid noise (never including a valid SYNC signal) on the USB.
            - Verify that all data has been streamed successfully, and that the USB device continued
              to operate correctly, ignoring all of the invalid signaling.
            '''
      stage: V2
      tests: []
    }
    {
      name: spurious_tokens_ignored
      desc: '''
            Check that the device ignores packets with unexpected tokens such as NYET, PRE...
            Also test ACK and NAK when not in response to a transmitted IN packet.

            - Randomly transmit valid token packets that use unexpected/unsupported PIDs and,
              in the case of ACK/NAK handshake packet that are out of sequence.
            - This is important in ensuring that the USB device/communications does not fail in
              the event of host handshake responses (to IN packets) being delayed.
            - Test all possible PIDs other than SETUP, OUT and IN, including invalid PIDs where
              the lower and upper nibbles are not complementary, and DATA0 and DATA1 PIDs without
              a preceding SETUP, OUT or IN token packet.
            '''
      stage: V2
      tests: []
    }
    {
      name: low_speed_traffic
      desc: '''
            Test that Low Speed traffic on the bus in the downstream direction is appropriately
            ignored and does not cause the USB device to enter an invalid state.
            Background: Hubs are permitted to propagate downstream Low Speed signaling to Full
            Speed devices on other ports.

            - Connect the USB device, with a SETUP- and OUT-capable endpoint.
            - Repeatedly generate and check valid SETUP and OUT packets at Full Speed signaling
              speeds, whilst interspersing Full Speed traffic that consists of PRE tokens followed
              by randomized packet contents at Low Speed signaling.
            - Check that the USB device receives correctly all of the SETUP and OUT packets and is
              unaffected by the Low Speed signaling.
            - In particular, check that it does not generate unexpected interrupts because these
              could devalue the diagnostic use of those interrupts in detecting and reporting
              unreliable connections.
            '''
      stage: V2
      tests: []
    }
    {
      name: rand_bus_resets
      desc: '''
            Ensure that all of SETUP, OUT and IN traffic are robust against randomized
            bus resets from the USB and that communications may successfully be resumed after
            subsequent reconfiguration.

            - Configure the USB device to receive SETUP, OUT and IN traffic (the regular
              Default Pipe, ie. just Endpoint Zero, should suffice).
            - During the process of normal device configuration, issue a Bus Reset to the device at
              a random time (ensuring that it may occur during all transaction types), and then
              restart the configuration, checking that it completes successfully this time when no
              reset occurs.
            - The intention is to ensure that the internal state machines and logic do not get
              stuck or hold persistent inappropriate state.
            '''
      stage: V2
      tests: []
    }
    {
      name: rand_disconnects
      desc: '''
            Ensure that all of SETUP, OUT and IN traffic are robust against randomized
            disconnection of the USB and that communications may successfully be resumed after a
            bus reset and reconfiguration. (The bus reset should occur have a disconnection that
            was host-initiated, and before configuration traffic commences.)

            - Configure the USB device to receive SETUP, OUT and IN traffic (the regular
              Default Pipe, ie. just Endpoint Zero should suffice).
            - During the process of normal device configuration, disconnect the USB at a random
              time (ensuring that it may occur during all transaction types), and then restart
              the configuration after a Bus Reset and check that
              configuration completes successfully this time when no disconnection occurs.
            '''
      stage: V2
      tests: []
    }
    {
      name: max_usb_traffic
      desc: '''
            Verify operation under maximal traffic to maximal endpoints, exercising all transfer
            types and all packet lengths, with randomized delays on the CSR side when receiving
            packets, supplying packets, making buffers available for use, and responding to
            interrupts.
            '''
      stage: V2
      tests: []
    }
    {
      name: stress_usb_traffic
      desc: '''
            Derived from 'max_usb_traffic' this also randomly introduces unexpected token packets,
            low speed traffic, invalid traffic, bus resets and disconnects, to ensure that these do
            not interfere with the transmission and reception of valid traffic.
            '''
      stage: V2
      tests: []
    }
    {
      name: in_packet_retraction
      desc: '''
            Exercise retraction of IN packets for Isochronous streams, prioritizing the delivery of
            the most recent data over the reliable delivery of all data presented.

            - Configure a single IN endpoint for Isochronous support.
            - Repeatedly poll for and collect IN packets from the USB host model, randomizing the
              delays between collection attempts.
            - Present a stream of Isochronous packets on the IN endpoint, with each packet containing
              a serial number. Randomize the times between packet presentations, and keep on the CSR
              side a record of which packets were retracted/overwritten rather than being transmitted
              successfully to the host.
            - Check that the CSR side and the USB host model agree on which packets were successfully
              transmitted from the device to the host.
            '''
      stage: V2
      tests: []
    }
    {
      name: data_toggle_restore
      desc: '''
            Verify that each of the IN and OUT Data Toggle bits may be both set and cleared by
            software to ensure that resuming communications after returning from Deep Sleep
            is possible.

            - Ensure that the USB device disconnected (pull up not enabled) such that no
              communications shall occur with the device.
            - Set all of the even-numbered OUT Data Toggle bits to 1 and all of the odd-numbered
              OUT Data Toggle bits to 0.
            - Check that the OUT Data Toggle bits read as 0x555.
            - Set all of the even-numbered IN Data Toggle bits to 0 and all of the odd-numbered
              IN Data Toggle bits to 1.
            - Check that the IN Data Toggle bits read as 0xAAA.
            - Check that the OUT Data Toggle bits read as 0x555.
            - Invert all of the OUT Data Toggle bits.
            - Invert all of the IN Data Toggle bits.
            - Check that the OUT Data Toggle bits read as 0xAAA.
            - Check that the IN Data Toggle bits read as 0x555.
            - Set all of the OUT Data Toggle bits to random values.
            - Set all of the IN Data Toggle bits to random values.
            - Check that all of the OUT and IN Data Toggle bits read back as expected.
            '''
      stage: V2
      tests: []
    }
    {
      name: setup_priority
      desc: '''
            Verify that the final slot of the Rx FIFO is reserved for use by SETUP packets only.
            The final slot of the Rx FIFO buffer shall never be assigned to an OUT DATA packet
            because it could force the USB device to be unresponsive to a SETUP DATA packet.

            - Configure the USB device to receive SETUP packets on Endpoint Zero.
            - Configure endpoint 1 to receive OUT DATA packets.
            - Place 1 buffer in the Available SETUP Buffer FIFO.
            - Place 8 buffers in the Available OUT Buffer FIFO.
            - Transmit 7 OUT DATA packets to endpoint 1, checking that each packet is
              ACKed, but do not read from Rx FIFO.
            - Check that the Rx FIFO contains 7 buffers.
            - Transmit 1 OUT DATA packet to endpoint 1.
            - Verify that the OUT DATA packet is NAKed as expected.
            - Check that the Rx FIFO depth is still 7.
            - Transmit a SETUP DATA packet to Endpoint Zero, checking that the packet is ACKed.
            - Check that the Rx FIFO depth is now 8.
            - Read the packets from the Rx FIFO, checking the properties of each of the 7 OUT
              DATA packets and the final 1 SETUP DATA packet in turn.
            '''
      stage: V2
      tests: []
    }
    {
      name: fifo_resets
      desc: '''
            Test the software-controlled FIFO reset functionality, introduced as a contingency
            for error recovery and to permit reconfiguration of the USB device hardware without
            resorting to use of the block-level asynchronous reset.

            - Populate the USBDEV FIFOs with packets randomly.
            - Choose a random set of FIFOs to reset.
            - Check the FIFO levels match expectations.
            - Note: the handling of the Received Buffer FIFO requires configuration of,
              and transmission of packets to, the USB device since there is no direct means
              to inject packets from the CSR side.
            '''
      stage: V2
      tests: ["usbdev_fifo_rst"]
    }
  ]
}
