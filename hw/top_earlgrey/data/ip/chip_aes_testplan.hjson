// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{
  name: chip_aes
  testpoints: [
    {
      name: chip_sw_aes_enc
      desc: '''Verify the AES operation.

            Procedure:
            -Set up the desired operation, ECB mode, 256b key length, and set the engine to
            manual operation. Set mask_reseeding to 1 per block.
            -Trigger the encryption by loading the plaintext.
            -Wait for the AES operation to complete by polling the status register and read the
            result.

            -The above procedure should be performed twice. First for encryption. Second for
            decryption of the result using the same key.
            -Check that the decryption result matches the original plaintext.
            '''
      features: [
        "AES.MODE.ECB",
        "AES.KEY_LEN.256",
        "AES.MANUAL_OPERATION",
      ]
      stage: V2
      si_stage: SV2
      lc_states: ["TEST_UNLOCKED", "PROD"]
      tests: ["chip_sw_aes_enc",
              "chip_sw_aes_enc_jitter_en"]
      bazel: ["//sw/device/tests:aes_smoketest"]
    }
    {
      name: chip_sw_aes_multi_block
      desc: '''Verify the AES operations on multi-block messages.
            This test should be performed for all supported modes (ECB, CBC, CFB-128, OFB and CTR)
            and all supported key lengths (128/192/256).

            Note: The number of message blocks has to be at least 4.

            Note: AES should start this test using the automatic (default) operation. This means
                  that the MANUAL_OPERATION bit in CTRL_SHADOWED register is set to 0.

            Procedure:
            -Configure the desired operation, mode, key length, and set the engine to automatic
             operation. Configure the IV for modes that require it.
            -Using dif_aes_start()  and dif_aes_process_data(), encrypt the message.
            -Check the output for correctness against the expected value.

            -The above procedure should be performed twice. First for encryption. Second for
            decryption of the result using the same key (and same IV if needed).
            -Check that the decryption result matches the original plaintext.
            '''
      features: [
        "AES.MODE.ECB",
        "AES.MODE.CBC",
        "AES.MODE.CFB-128",
        "AES.MODE.OFB",
        "AES.MODE.CTR",
        "AES.KEY_LEN.128",
        "AES.KEY_LEN.192",
        "AES.KEY_LEN.256",
      ]
      stage: V2
      si_stage: SV3
      lc_states: ["PROD"]
      tests: []
      bazel: [
        "//sw/device/tests/crypto:aes_functest",
      ]
    }
    {
      name: chip_sw_aes_interrupt_encryption
      desc: '''Verify that a multi-block encryption can be interrupted and continued.

            This test should:
              - start the encryption of a four-block message.
              - interrupt it after two blocks by reading back the IV register.
              - perform an encryption of a different message using a different key.
              - re-store and complete the original encryption

            Note: AES should start this test using the automatic (default) operation. This means
                  that the MANUAL_OPERATION bit in CTRL_SHADOWED register is set to 0.

            Procedure:
            -Configure encryption using the desired mode, key length, IV, and set the engine to
            automatic operation.
            -Using dif_aes_process_data, encrypt the first two blocks.
            -Using dif_aes_read_iv read the IV. Note that AES has automatically updated the content
             of this register. This IV will be needed later to continue this encryption.
            -De-initialize automatic operation. This step is necessary to clear all registers.
            -Perform an encryption using a different data and key. Message size, key size and mode
             can be chosen arbitrarily.
            -Continue the original encryption:
                -Configure the operation using the previously read IV
                -Process the remaining plaintext blocks using dif_aes_process_data
            -Decrypt the result (using the original key and IV)
            -Check that the decryption result matches the original plaintext.
            '''
      features: [
        "AES.MODE.CBC",
        "AES.MODE.CFB-128",
        "AES.MODE.OFB",
        "AES.MODE.CTR",
      ]
      stage: V2
      si_stage: SV3
      lc_states: ["PROD"]
      tests: []
    }
    {
      name: chip_sw_aes_entropy
      desc: '''Verify the AES entropy input used by the internal PRNGs.

            - Configure encryption using the CBC mode, key length 256, and set the engine to
              manual operation.
            - Write the initial key share, IV and data in CSRs (known combinations).
            - Write the PRNG_RESEED bit to reseed the internal state of the PRNG.
            - Poll the status idle bit to ensure reseed operation is complete.
            - Trigger the AES operation to run and wait for it to complete.
            - Check the ciphertext against the expected value.
            - Write the KEY_IV_DATA_IN_CLEAR and DATA_OUT_CLEAR trigger bits to 1 and wait for it to
              complete by polling the status idle bit.
            - Read back the data out CSRs - they should all read garbage values.
            - Assertion check verifies that the IV are also garbage, i.e. different from the
              originally written values.
            '''
      features: [
        "AES.MODE.CBC",
        "AES.CLEAR.DATA_OUT",
        "AES.CLEAR.KEY_IV_DATA_IN",
      ]
      stage: V2
      si_stage: SV3
      lc_states: ["PROD"]
      tests: ["chip_sw_aes_entropy"]
      bazel: ["//sw/device/tests:aes_entropy_test"]
    }
    {
      name: chip_sw_aes_prng_reseed
      desc: '''Verify that PRNG reseeding is triggered

            This test should start encryption, disable the EDN, and verify that the
            encryption stalls when reseed is required. Afterwards it should verify that AES
            finishes encryption after EDN is re-enabled.

            Procedure:
            -Configure encryption using the ECB mode, desired key length, and set the engine to
            automatic operation.
                -Set the mask_reseeding to once per 64 blocks (kDifAesReseedPer64Block)
            -Using dif_aes_process_data() encrypt some number of blocks (fewer than 64).
            -Disable the EDN using dif_edn_stop().
            -Encrypt more blocks and verify that encryption stalls after 64 blocks.
                -Once the first 64 blocks are encrypted, a reseed request will be sent to EDN.
                Since the EDN should be disabled at this point, this should cause encryption
                to stall.
            -Re-enable EDN. In order to do this it is required to first disable and re-enable the
             CSRNG. In order to re-enable CSRNG, it is required to first disable and re-enable
             the entropy source. The following sequence of steps should be used:
                -Disable CSRNG
                -Disable Entropy Source
                -Enable Entropy Source
                -Enable CSRNG
                -Enable EDN
            -Verify that the AES completes encryption of the remaining blocks.

            -Repeat the test for a reseed rate kDifAesReseedPer8kBlock and a message longer than 8K
            blocks.
            '''
      features: [
        "AES.MODE.ECB",
        "AES.PRNG.RESEED_RATE",
      ]
      stage: V2
      si_stage: SV3
      lc_states: ["PROD"]
      tests: ["chip_sw_aes_prng_reseed"]
    }
    {
      name: chip_sw_aes_force_prng_reseed
      desc: '''Verify that when KEY_TOUCH_FORCES_RESEED is set, the PRNG reseed is
               triggered every time a key changes

            Procedure:
            -Configures the auxiliary options for AES to enable KEY_TOUCH_FORCES_RESEED
            -Disable the EDN using dif_edn_stop()
            -Configure the encryption operation, mode, key length, and set the engine to manual
             operation.
            -Set up encryption using aes_testutils_setup_encryption()
              -At this point dif_aes_start() will write the key register which will trigger reseed
               request. This request will stall the encryption until EDN is re-enabled.
            -Verify that the encryption stalls.
            -Re-enable EDN. In order to do this it is required to first disable and re-enable the
             CSRNG. In order to re-enable CSRNG, it is required to first disable and re-enable
             the entropy source. The following sequence of steps should be used:
                -Disable CSRNG
                -Disable Entropy Source
                -Enable Entropy Source
                -Enable CSRNG
                -Enable EDN
            -Verify that the AES completes encryption.
            '''
      features: [
        "AES.MODE.ECB",
        "AES.PRNG.KEY_TOUCH_FORCES_RESEED",
      ]
      stage: V2
      si_stage: SV3
      lc_states: ["PROD"]
      tests: ["chip_sw_aes_force_prng_reseed"]
    }
    {
      name: chip_sw_aes_idle
      desc: '''Verify AES idle signaling to clkmgr.

            - Write the AES clk hint to 0 within clkmgr to indicate AES clk can be gated and
              verify that the AES clk hint status within clkmgr reads 0 (AES is disabled).
            - Write the AES clk hint to 1 within clkmgr to indicate AES clk can be enabled.
            - Initiate an AES operation with a known key, plain text and digest, write AES clk
              hint to 0 and verify that the AES clk hint status within clkmgr now reads 1 (AES
              is enabled), before the AES operation is complete.
            - After the AES operation is complete verify that the AES clk hint status within
              clkmgr now reads 0 again (AES is disabled).
            - Write the AES clk hint to 1, read and check the AES output for correctness.
            '''
      features: [
        "AES.MODE.ECB",
      ]
      stage: V2
      si_stage: SV3
      lc_states: ["PROD"]
      tests: ["chip_sw_aes_idle"]
      bazel: ["//sw/device/tests:aes_idle_test"]
    }
    {
      name: chip_sw_aes_sideload
      desc: '''Verify the AES sideload mechanism.

            - Configure the keymgr to generate an aes key.
            - Configure the AES to use the sideloaded key.
            - Load the plaintext into the AES.
            - Trigger the AES encryption and wait for it to complete.
            - Verify that the ciphertext is different from the plaintext.
            - Load the ciphertext into the AES.
            - Trigger the AES decryption and wait for it to complete.
            - Verify that the output is equal to the plain text.
            - Clear the key in the keymgr and decrypt the ciphertext again.
            - Verify that output is not equal to the plain text.
            '''
      features: [
        "AES.MODE.ECB",
        "AES.KEY.SIDELOAD",
      ]
      stage: V2
      si_stage: SV3
      lc_states: ["PROD", "DEV"]
      tests: ["chip_sw_keymgr_sideload_aes"]
      bazel: [
        "//sw/device/tests/crypto:aes_sideload_functest",
        "//sw/device/tests/crypto:keymgr_sideload_aes_test",
        "//sw/device/tests/crypto:aes_kwp_sideload_functest",
      ]
    }
    {
      name: chip_sw_aes_masking_off
      desc: '''Verify the AES masking off feature for ES.

            - Perform known-answer test using CSRNG SW application interface.
            - Verify CSRNG produces the deterministic seed leading to an all-zero output of the AES
              masking PRNG.
            - Configure EDN to perform a CSRNG instantiate followed by repeated generate and reseed
              commands using the maximum amount of additional data and no entropy input in automatic
              mode.
            - Let CSRNG produce and forward to EDN the deterministic seed leading to an all-zero
              output of the AES masking PRNG.
            - Initialize AES and set the force_masks configuration bit.
            - Configure an AES key of which the second share is zero.
            - Trigger a reseed operation of the masking PRNG inside AES to load the deterministic
              seed produced by CSRNG and distributed by EDN.
            - Verify that the masking PRNG outputs an all-zero vector. (Note: This may not be
              possible to verify in silicon.)
            - Encrypt a message of multiple blocks using AES.
            - Verify that the second share of the initial, intermediate and output state is zero.
            - Verify that the second share of the SubBytes input and output is zero. (Note: This
              may not possible to verify in silicon.)
            - Verify that the produced cipher text is correct.
            - Repeat the entire procedure with PRNG_RESEED_RATE set to PER_1. Verify that the
              second share of intermediate and output state is not zero.

            Notes for silicon targets:
            - The AES.PRNG.FORCE_MASKS feature is relevant for penetration testing only and a SCA evaluation setup is required for its verification.
              This is done using other routines as part of the experimental setup for penetration testing.
              The only thing that can be tested on silicon / FPGA for SiVal is the known-answer test using the CSRNG SW application interface for which a dedicated SiVal test exists.
              For this reason, the chip_sw_aes_masking_off test is run in simulation only.
            '''
      features: [
        "AES.PRNG.FORCE_MASKS"
      ]
      stage: V2S
      si_stage: NA
      tests: ["chip_sw_aes_masking_off"]
     }
  ]
}
