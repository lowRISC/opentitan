// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// TOP Earlgrey configuration
{ name: "earlgrey",
  type: "top",

  /////////////////////////////////////////////////////////////
  // Seed for compile-time random constants                  //
  // NOTE: REPLACE THIS WITH A NEW VALUE BEFORE THE TAPEOUT  //
  /////////////////////////////////////////////////////////////
  rnd_cnst_seed: 4881560218908238235

  // 32-bit datawidth
  datawidth: "32",

  // Power information for the design
  power: {
    // Power domains supported by the design
    // Aon represents domain aon
    // 0 represents domain 0
    domains: ["Aon", "0"],

    // Default power domain used for the design
    default: "0"
  },

  // This is the clock data structure of the design.
  // The hier path refers to the clock reference path (struct / port)
  //   - The top/ext desgination follows the same scheme as inter-module
  // The src key indicates the raw clock sources in the design
  // The groups key indicates the various clock groupings in the design
  clocks: {

    hier_paths: {
      top: "clkmgr_aon_clocks.", // top level is a struct
      ext: "",                   // ext is a port of the clock name
    },

    // Clock Source attributes
    // name: Name of group.
    // aon:  Whether the clock is free running all the time.
    //       If it is, the clock is not hanlded by clkmgr.
    // freq: Absolute frequency of clk in Hz
    srcs: [
      { name: "main", aon: "no",  freq: "100000000" }
      { name: "io",   aon: "no",  freq: "96000000" }
      { name: "usb",  aon: "no",  freq: "48000000" }
      { name: "aon",  aon: "yes", freq: "200000" }
    ],

    // Derived clock source attributes
    // name: Name of group.
    // aon:  Whether the clock is free running all the time.
    //       If it is, the clock is not hanlded by clkmgr.
    // freq: Absolute frequency of clk in Hz
    // src:  From which clock source is the clock derived
    // div:  Ratio between derived clock and source clock
    derived_srcs: [
      { name: "io_div2", aon: "no", div: 2, src: "io", freq: "48000000" }
      { name: "io_div4", aon: "no", div: 4, src: "io", freq: "24000000" }
    ],

    // Clock Group attributes
    // name: name of group.
    //
    // src: The hierarchical source of the clock
    // "ext"  - clock is supplied from a port of the top module
    // "top"  - clock is supplied from a net inside the top module
    //
    // sw_cg: whether software is allowed to gate the clock
    // "no"   - software is not allowed to gate clocks
    // "yes"  - software is allowed to gate clocks
    // "hint" - software can provide a hint, and hw controls the rest
    //
    // unique: whether each module in the group can be separately gated
    //         if sw_cg is "no", this field has no meaning
    // "yes"  - each clock is individually controlled
    // "no"   - the group is controlled as one single unit
    //
    // The powerup and proc groups are unique.
    // The powerup group of clocks do not feed through the clock
    // controller as they manage clock controller behavior
    // The proc group is not peripheral, and directly hardwired

    groups: [
      // the powerup group is used exclusively by clk/pwr/rstmgr/pinmux
      { name: "powerup", src:"top", sw_cg: "no"                   }
      { name: "trans",   src:"top", sw_cg: "hint", unique: "yes", }
      { name: "infra",   src:"top", sw_cg: "no",                  }
      { name: "secure",  src:"top", sw_cg: "no"                   }
      { name: "peri",    src:"top", sw_cg: "yes",  unique: "no"   }
      { name: "timers",  src:"top", sw_cg: "no"                   }
      { name: "proc",
        src: "no",
        sw_cg: "no",
        unique: "no",
        clocks: {
          clk_proc_main: main
        }
      }
    ],
  },

  // This is the reset data strcture of the design.
  // The hier path refers to the reset reference path (struct / port)
  //   - The top/ext desgination follows the same scheme as inter-module
  // The node key represents all the known resets in the design
  resets: {

    hier_paths: {
      top: "rstmgr_aon_resets.", // top level is a struct
      ext: "",                   // ext is a port of the clock name
    },

    // Reset node attributes
    // name: name of reset.
    //
    // gen: whether the reset is generated
    // true: it is a generated reset inside rstmgr
    // false: it is a hardwired design reset inside rstmgr (roots and por)
    // For non-generated resets, the parent / domain definitions have no meaning.
    //
    // type: the reset type [ext, top]
    // ext: the reset is coming in from the ports, external to earlgrey
    // int: the reset is only used inside rstmgr
    // top: the reset is output from rstmgr to top level struct
    //
    // parent: The parent reset
    // If type is "ext", there is no root, since it is external
    //
    // domains: The power domains of a particular reset
    // This is a list of of the supported power domains.
    // Valid values are Aon and (power domain)0 ~ (power domain)1.
    // If no value is supplied, the default is only the Aon version.
    //
    // clk:  related clock domain for synchronous release
    // If type is "por", there is not related clock, since it is
    // likely external or generated from a voltage comparator
    //
    nodes: [
      { name: "rst_ni",      gen: false, type: "ext",                                                          }
      { name: "por_aon",     gen: false, type: "top", domains: ["Aon"     ],                    clk: "aon"     }
      { name: "lc_src",      gen: false, type: "int", domains: ["Aon", "0"],                    clk: "io_div4" }
      { name: "sys_src",     gen: false, type: "int", domains: ["Aon", "0"],                    clk: "io_div4" }
      { name: "por",         gen: true,  type: "top", domains: ["Aon"     ], parent: "por_aon", clk: "main"    }
      { name: "por_io",      gen: true,  type: "top", domains: ["Aon",    ], parent: "por_aon", clk: "io"      }
      { name: "por_io_div2", gen: true,  type: "top", domains: ["Aon",    ], parent: "por_aon", clk: "io_div2" }
      { name: "por_io_div4", gen: true , type: "top", domains: ["Aon",    ], parent: "por_aon", clk: "io_div4" }
      { name: "por_usb",     gen: true,  type: "top", domains: ["Aon",    ], parent: "por_aon", clk: "usb"     }
      { name: "lc",          gen: true,  type: "top", domains: [       "0"], parent: "lc_src",  clk: "main"    }
      { name: "lc_io_div4",  gen: true,  type: "top", domains: [       "0"], parent: "lc_src",  clk: "io_div4" }
      { name: "sys",         gen: true,  type: "top", domains: [       "0"], parent: "sys_src", clk: "main"    }
      { name: "sys_io_div4", gen: true,  type: "top", domains: ["Aon", "0"], parent: "sys_src", clk: "io_div4" }
      { name: "sys_aon",     gen: true,  type: "top", domains: ["Aon", "0"], parent: "sys_src", clk: "aon"     }
      { name: "spi_device",  gen: true,  type: "top", domains: [       "0"], parent: "sys_src", clk: "io_div2", sw: 1 }
      { name: "spi_host0",   gen: true,  type: "top", domains: [       "0"], parent: "sys_src", clk: "io",      sw: 1 }
      { name: "spi_host1",   gen: true,  type: "top", domains: [       "0"], parent: "sys_src", clk: "io_div2", sw: 1 }
      { name: "usb",         gen: true,  type: "top", domains: [       "0"], parent: "sys_src", clk: "usb",     sw: 1 }
      { name: "i2c0",        gen: true,  type: "top", domains: [       "0"], parent: "sys_src", clk: "io_div2", sw: 1 },
      { name: "i2c1",        gen: true,  type: "top", domains: [       "0"], parent: "sys_src", clk: "io_div2", sw: 1 },
      { name: "i2c2",        gen: true,  type: "top", domains: [       "0"], parent: "sys_src", clk: "io_div2", sw: 1 },
    ]
  }

  // Number of cores: used in rv_plic and timer
  num_cores: "1",


  // `host` defines the host only components in the system (such as processor)
  // This should eventually be used to cover more functionality, but for now,
  // it is a temporary solution for top level connectivity
  host: [
    { name: "rv_core_ibex",
      type: "rv_core_ibex",
      inter_signal_list: [
        { struct:  "esc_tx",
          type:    "uni",
          name:    "esc_nmi_tx",
          act:     "rcv",
          package: "prim_esc_pkg",
        },

        { struct:  "esc_rx",
          type:    "uni",
          name:    "esc_nmi_rx",
          act:     "req",
          package: "prim_esc_pkg",
        },

        { struct:  "crash_dump",
          type:    "uni",
          name:    "crash_dump",
          act:     "req",
          package: "ibex_pkg",
        },

        { struct:  "lc_tx_t",
          type:    "uni",
          name:    "lc_cpu_en",
          act:     "rcv",
          package: "lc_ctrl_pkg",
        },

        { struct:  "ram_1p_cfg_t",
          type:    "uni",
          name:    "ram_cfg",
          act:     "rcv",
          package: "prim_ram_1p_pkg"
        },

        { struct:  "alert_event",
          type:    "uni",
          name:    "fatal_intg_event",
          act:     "req",
          package: "rv_core_ibex_peri_pkg",
        },

        { struct:  "alert_event",
          type:    "uni",
          name:    "fatal_core_event",
          act:     "req",
          package: "rv_core_ibex_peri_pkg",
        },

        { struct:  "alert_event",
          type:    "uni",
          name:    "recov_core_event",
          act:     "req",
          package: "rv_core_ibex_peri_pkg",
        },

        { struct:  "region_cfg",
          type:    "uni",
          name:    "ibus_region_cfg",
          act:     "rcv",
          width:   "2",
          package: "rv_core_ibex_peri_pkg",
        },

        { struct:  "region_cfg",
          type:    "uni",
          name:    "dbus_region_cfg",
          act:     "rcv",
          width:   "2",
          package: "rv_core_ibex_peri_pkg",
        },
      ],
    }
  ]

  // `module` defines the peripherals.
  // Details are coming from each modules' config file `ip.hjson`
  // TODO: Define parameter here
  // attr: There are a few types of modules supported
     //   normal(default): Normal, non-templated modules that will be instantiated
     //   templated:   These modules are templated and must be run through topgen
     //   reggen_top:  These modules are not templated, but need to have reggen run
     //                because they live exclusively in hw/top_* instead of hw/ip_*.
     //                These modules are also instantiated in the top level.
     //   reggen_only: Similar to reggen_top, but are not instantiated in the top level.
  module: [
    { name: "uart0",    // instance name
      type: "uart",     // Must be matched to the ip name in `ip.hson` (_reg, _cfg permitted)
                        // and `hw/ip/{type}`

      // clock connections defines the port to top level clock connection
      // the ip.hjson will declare the clock port names
      // If none are defined at ip.hjson, clk_i is used by default
      clock_srcs: {clk_i: "io_div4"},

      // reset connections defines the port to top level reset connection
      // the ip.hjson will declare the reset port names
      // If none are defined at ip.hjson, rst_ni is used by default
      reset_connections: {rst_ni: "sys_io_div4"},
      base_addr: "0x40000000",
    },
    { name: "uart1",    // instance name
      type: "uart",     // Must be matched to the ip name in `ip.hson` (_reg, _cfg permitted)
                        // and `hw/ip/{type}`

      // clock connections defines the port to top level clock connection
      // the ip.hjson will declare the clock port names
      // If none are defined at ip.hjson, clk_i is used by default
      clock_srcs: {clk_i: "io_div4"},

      // reset connections defines the port to top level reset connection
      // the ip.hjson will declare the reset port names
      // If none are defined at ip.hjson, rst_ni is used by default
      reset_connections: {rst_ni: "sys_io_div4"},
      base_addr: "0x40010000",
    },
    { name: "uart2",    // instance name
      type: "uart",     // Must be matched to the ip name in `ip.hson` (_reg, _cfg permitted)
                        // and `hw/ip/{type}`

      // clock connections defines the port to top level clock connection
      // the ip.hjson will declare the clock port names
      // If none are defined at ip.hjson, clk_i is used by default
      clock_srcs: {clk_i: "io_div4"},

      // reset connections defines the port to top level reset connection
      // the ip.hjson will declare the reset port names
      // If none are defined at ip.hjson, rst_ni is used by default
      reset_connections: {rst_ni: "sys_io_div4"},
      base_addr: "0x40020000",
    },
    { name: "uart3",    // instance name
      type: "uart",     // Must be matched to the ip name in `ip.hson` (_reg, _cfg permitted)
                        // and `hw/ip/{type}`

      // clock connections defines the port to top level clock connection
      // the ip.hjson will declare the clock port names
      // If none are defined at ip.hjson, clk_i is used by default
      clock_srcs: {clk_i: "io_div4"},

      // reset connections defines the port to top level reset connection
      // the ip.hjson will declare the reset port names
      // If none are defined at ip.hjson, rst_ni is used by default
      reset_connections: {rst_ni: "sys_io_div4"},
      base_addr: "0x40030000",
    },
    { name: "gpio",
      type: "gpio",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "peri",
      reset_connections: {rst_ni: "sys_io_div4"},
      base_addr: "0x40040000",
    }
    { name: "spi_device",
      type: "spi_device",
      clock_srcs: {clk_i: "io_div4", scan_clk_i: "io_div2"},
      clock_group: "peri",
      reset_connections: {rst_ni: "spi_device"},
      base_addr: "0x40050000",
    },
    { name: "spi_host0",
      type: "spi_host",
      clock_srcs: {clk_i: "io_div4", clk_core_i: "io"},
      clock_group: "peri",
      reset_connections: {rst_ni: "spi_host0", rst_core_ni: "spi_host0"},
      base_addr: "0x40060000",
    },
    { name: "spi_host1",
      type: "spi_host",
      clock_srcs: {clk_i: "io_div4", clk_core_i: "io_div2"},
      clock_group: "peri",
      reset_connections: {rst_ni: "spi_host1", rst_core_ni: "spi_host1"},
      base_addr: "0x40070000",
    },
    { name: "i2c0",
      type: "i2c",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "peri",
      reset_connections: {rst_ni: "i2c0"},
      base_addr: "0x40080000",
    },
    { name: "i2c1",
      type: "i2c",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "peri",
      reset_connections: {rst_ni: "i2c1"},
      base_addr: "0x40090000",
    },
    { name: "i2c2",
      type: "i2c",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "peri",
      reset_connections: {rst_ni: "i2c2"},
      base_addr: "0x400A0000",
    },
    { name: "pattgen",
      type: "pattgen",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "peri",
      reset_connections: {rst_ni: "sys_io_div4"},
      base_addr: "0x400E0000",
    },
    { name: "rv_timer",
      type: "rv_timer",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "timers",
      reset_connections: {rst_ni: "sys_io_div4"},
      base_addr: "0x40100000",
    },
    { name: "usbdev",
      type: "usbdev",
      clock_srcs: {clk_i: "io_div4", clk_aon_i: "aon", clk_usb_48mhz_i: "usb"},
      clock_group: "peri",
      clock_reset_export: ["ast"],
      reset_connections: {rst_ni: "sys_io_div4", rst_aon_ni: "sys_aon", rst_usb_48mhz_ni: "usb"},
      base_addr: "0x40110000",
    },
    { name: "otp_ctrl",
      type: "otp_ctrl",
      clock_srcs: {clk_i: "io_div4", clk_edn_i: "main"},
      clock_group: "timers",
      reset_connections: {rst_ni: "lc_io_div4", rst_edn_ni: "sys"},
      base_addr: "0x40130000",
    },
    { name: "lc_ctrl",
      type: "lc_ctrl",
      clock_srcs: {clk_i: "io_div4", clk_kmac_i: "main"},
      clock_group: "timers",
      reset_connections: {rst_ni: "lc_io_div4", rst_kmac_ni: "sys"},
      base_addr: "0x40140000",
    },
    { name: "alert_handler",
      type: "alert_handler",
      clock_srcs: {clk_i: "io_div4", clk_edn_i: "main"},
      clock_group: "timers",
      reset_connections: {rst_ni: "sys_io_div4", rst_edn_ni: "sys"},
      base_addr: "0x40150000",
      attr: "templated",
      localparam: {
        EscCntDw:  32,
        AccuCntDw: 16,
        LfsrSeed:  "0x7FFFFFFF"
      }
    },
    // dummy module to capture the alert handler escalation signals
    // and test them by converting them into IRQs
//    { name: "nmi_gen",
//      type: "nmi_gen",
//      clock_srcs: {clk_i: "io_div4"},
//      clock_group: "timers",
//      reset_connections: {rst_ni: "sys_io_div4"},
//      base_addr: "0x40160000",
//    }
    { name: "pwrmgr_aon",
      type: "pwrmgr",
      clock_srcs: {clk_i: "io_div4", clk_slow_i: "aon"},
      clock_group: "powerup",
      reset_connections: {rst_ni: "por", rst_slow_ni: "por_aon"},
      domain: "Aon",
      base_addr: "0x40400000",
      attr: "templated",

    },
    { name: "rstmgr_aon",
      type: "rstmgr",
      clock_srcs: {clk_i: "io_div4", clk_aon_i: "aon", clk_main_i: "main", clk_io_i: "io", clk_usb_i: "usb",
                   clk_io_div2_i: "io_div2", clk_io_div4_i: "io_div4"},
      clock_group: "powerup",
      reset_connections: {rst_ni: "rst_ni"},
      domain: "Aon",
      base_addr: "0x40410000",
      attr: "templated",
    },
    { name: "clkmgr_aon",
      type: "clkmgr",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "powerup",
      reset_connections: {rst_ni: "por_io_div4", rst_main_ni: "por", rst_io_ni: "por_io", rst_usb_ni: "por_usb"
                          rst_io_div2_ni: "por_io_div2", rst_io_div4_ni: "por_io_div4"},
      domain: "Aon",
      base_addr: "0x40420000",
      attr: "templated",
    },
    { name: "sysrst_ctrl_aon",
      type: "sysrst_ctrl",
      clock_srcs: {clk_i: "io_div4", clk_aon_i: "aon"},
      clock_group: "secure",
      reset_connections: {rst_ni: "sys_io_div4", rst_aon_ni: "sys_aon"},
      domain: "Aon",
      base_addr: "0x40430000"
    },
    { name: "adc_ctrl_aon",
      type: "adc_ctrl",
      clock_srcs: {clk_i: "io_div4", clk_aon_i: "aon"},
      clock_group: "peri",
      reset_connections: {rst_ni: "sys_io_div4", rst_slow_ni: "sys_aon"},
      clock_reset_export: ["ast"],
      domain: "Aon",
      base_addr: "0x40440000"
    },
    { name: "pwm_aon",
      type: "pwm",
      clock_srcs: {clk_i: "io_div4", clk_core_i: "aon"},
      clock_group: "powerup",
      reset_connections: {rst_ni: "sys_io_div4", rst_core_ni: "sys_aon"},
      domain: "Aon",
      base_addr: "0x40450000",
    },
    { name: "pinmux_aon",
      type: "pinmux",
      clock_srcs: {clk_i: "io_div4", clk_aon_i: "aon"},
      clock_group: "powerup",
      reset_connections: {rst_ni: "sys_io_div4", rst_aon_ni: "sys_aon"},
      domain: "Aon",
      base_addr: "0x40460000",
      attr: "templated",
    },
    { name: "aon_timer_aon",
      type: "aon_timer",
      clock_srcs: {clk_i: "io_div4", clk_aon_i: "aon"},
      clock_group: "timers",
      reset_connections: {rst_ni: "sys_io_div4", rst_aon_ni: "sys_aon"},
      domain: "Aon",
      base_addr: "0x40470000",
      attr: "templated",
    },
    { name: "ast",
      type: "ast",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "secure",
      clock_reset_export: ["ast"],
      reset_connections: {rst_ni: "sys_io_div4"},
      base_addr: "0x40480000",
      attr: "reggen_only",
    },
    { name: "sensor_ctrl_aon",
      type: "sensor_ctrl",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "secure",
      clock_reset_export: ["ast"],
      reset_connections: {rst_ni: "sys_io_div4"},
      domain: "Aon",
      base_addr: "0x40490000",
      attr: "reggen_top",
    },
    { name: "sram_ctrl_ret_aon",
      type: "sram_ctrl",
      clock_srcs: {clk_i: "io_div4", clk_otp_i: "io_div4"},
      clock_group: "peri",
      reset_connections: {rst_ni: "sys_io_div4", rst_otp_ni: "lc_io_div4"},
      domain: "Aon",
      base_addr: "0x40500000"
    },
    { name: "flash_ctrl",
      type: "flash_ctrl",
      clock_srcs: {clk_i: "main", clk_otp_i: "io_div4"},
      clock_group: "infra",
      reset_connections: {rst_ni: "lc", rst_otp_ni: "lc_io_div4"},
      base_addrs: {core: "0x41000000", prim: "0x41008000"}
      attr: "templated",
    },
    { name: "rv_dm",
      type: "rv_dm",
      clock_srcs: {clk_i: "main"},
      clock_group: "infra",
      reset_connections: {rst_ni: "lc"},
      // Note that this module also contains a bus host.
      base_addrs: {rom: "0x00010000", regs: "0x41200000"}
    },
    { name: "rv_plic",
      type: "rv_plic",
      clock_srcs: {clk_i: "main"},
      clock_group: "secure",
      reset_connections: {rst_ni: "sys"},
      base_addr: "0x41010000",
      attr: "templated",
    },
    { name: "aes",
      type: "aes",
      clock_srcs: {clk_i: "main", clk_edn_i: "main"},
      clock_group: "trans",
      reset_connections: {rst_ni: "sys", rst_edn_ni: "sys"},
      base_addr: "0x41100000",
    },
    { name: "hmac",
      type: "hmac",
      clock_srcs: {clk_i: "main"},
      clock_group: "trans",
      reset_connections: {rst_ni: "sys"},
      base_addr: "0x41110000",
    },
    { name: "kmac"
      type: "kmac"
      clock_srcs: {clk_i: "main", clk_edn_i: "main"}
      clock_group: "trans"
      reset_connections: {rst_ni: "sys", rst_edn_ni: "sys"}
      base_addr: "0x41120000"
    },
    { name: "keymgr",
      type: "keymgr",
      clock_srcs: {clk_i: "main", clk_edn_i: "main"},
      clock_group: "secure",
      reset_connections: {rst_ni: "sys", rst_edn_ni: "sys"},
      base_addr: "0x41130000",
    },
    { name: "csrng",
      type: "csrng",
      clock_srcs: {clk_i: "main"},
      clock_group: "secure",
      reset_connections: {rst_ni: "sys"},
      base_addr: "0x41150000",
    },
    { name: "entropy_src",
      type: "entropy_src",
      clock_srcs: {clk_i: "main"},
      clock_group: "secure",
      reset_connections: {rst_ni: "sys"},
      clock_reset_export: ["ast"],
      base_addr: "0x41160000",
    },
    { name: "edn0",
      type: "edn",
      clock_srcs: {clk_i: "main"},
      clock_group: "secure",
      reset_connections: {rst_ni: "sys"},
      clock_reset_export: ["ast"],
      base_addr: "0x41170000",
    },
    { name: "edn1",
      type: "edn",
      clock_srcs: {clk_i: "main"},
      clock_group: "secure",
      reset_connections: {rst_ni: "sys"},
      base_addr: "0x41180000",
    },
    { name: "sram_ctrl_main",
      type: "sram_ctrl",
      clock_srcs: {clk_i: "main", clk_otp_i: "io_div4"},
      clock_group: "secure",
      reset_connections: {rst_ni: "sys", rst_otp_ni: "lc_io_div4"},
      base_addr: "0x411C0000",
    },
    { name: "otbn",
      type: "otbn",
      clock_srcs: {clk_i: "main", clk_edn_i: "main", clk_otp_i: "io_div4"},
      clock_group: "trans",
      reset_connections: {rst_ni: "sys", rst_edn_ni: "sys", rst_otp_ni: "lc_io_div4"},
      base_addr: "0x411D0000",
    },
    { name: "rom_ctrl",
      type: "rom_ctrl",
      clock_srcs: {clk_i: "main"},
      clock_group: "infra",
      reset_connections: {rst_ni: "sys"},
      base_addrs: {rom: "0x00008000", regs: "0x411e0000"}
    },
    { name: "rv_core_ibex_peri",
      type: "rv_core_ibex_peri",
      clock_srcs: {clk_i: "main"},
      clock_group: "infra",
      reset_connections: {rst_ni: "sys"},
      base_addr: "0x411F0000",
    },
  ]

  // Memories (ROM, RAM, eFlash) are defined at the top.
  // It utilizes the primitive cells but configurable
  memory: [
    { name: "ram_main",
      clock_srcs: {clk_i: "main"},
      clock_group: "infra",
      reset_connections: {rst_ni: "sys"},
      type: "ram_1p_scr",
      base_addr: "0x10000000",
      size: "0x20000",
      byte_write: "true",
      // data integrity width
      integ_width: 7,
      exec: "1",
      inter_signal_list: [
        { struct: "tl"
          package: "tlul_pkg"
          type: "req_rsp"
          act: "rsp"
          name: "tl"
        },
        // Interface to SRAM controller
        { struct:  "sram_scr",
          package: "sram_ctrl_pkg"
          type:    "req_rsp",
          name:    "sram_scr",
          act:     "rsp",
        },
        { struct:  "sram_scr_init",
          package: "sram_ctrl_pkg"
          type:    "req_rsp",
          name:    "sram_scr_init",
          act:     "rsp",
        },
        { struct:  "tl_instr_en",
          package: "tlul_pkg"
          type:    "uni",
          name:    "en_ifetch",
          act:     "rcv",
        },
        { struct:  "logic",
          package: ""
          type:    "uni",
          name:    "intg_error",
          act:     "req",
        },
        // Interface to memory configuration
        { struct:  "ram_1p_cfg",
          package: "prim_ram_1p_pkg",
          type:    "uni",
          name:    "cfg",
          act:     "rcv"
        }
      ]
    },
    { name: "ram_ret_aon",
      clock_srcs: {clk_i: "io_div4"},
      clock_group: "infra",
      reset_connections: {rst_ni: "sys_io_div4"},
      domain: "Aon",
      type: "ram_1p_scr",
      base_addr: "0x40600000",
      size: "0x1000",
      byte_write: "true",
      // data integrity width
      integ_width: 7,
      exec: "0",
      inter_signal_list: [
        { struct: "tl"
          package: "tlul_pkg"
          type: "req_rsp"
          act: "rsp"
          name: "tl"
        },
        // Interface to SRAM controller
        { struct:  "sram_scr",
          package: "sram_ctrl_pkg"
          type:    "req_rsp",
          name:    "sram_scr",
          act:     "rsp",
        },
        { struct:  "sram_scr_init",
          package: "sram_ctrl_pkg"
          type:    "req_rsp",
          name:    "sram_scr_init",
          act:     "rsp",
        },
        { struct:  "tl_instr_en",
          package: "tlul_pkg"
          type:    "uni",
          name:    "en_ifetch",
          act:     "rcv",
        },
        { struct:  "logic",
          package: ""
          type:    "uni",
          name:    "intg_error",
          act:     "req",
        },
        // Interface to memory configuration
        { struct:  "ram_1p_cfg",
          package: "prim_ram_1p_pkg",
          type:    "uni",
          name:    "cfg",
          act:     "rcv"
        }
      ]
    },
    { name: "eflash",
      clock_srcs: {clk_i: "main"},
      clock_group: "infra",
      reset_connections: {rst_ni: "lc"},
      type: "eflash",
      base_addr: "0x20000000",
      banks: 2,
      pages_per_bank: 256,
      program_resolution: 8, // maximum number of flash words allowed to program at one time
      swaccess: "ro",
      inter_signal_list: [
        { struct: "flash",    // flash_req_t, flash_rsp_t
          type: "req_rsp",
          name: "flash_ctrl", // flash_ctrl_i (req), flash_ctrl_o (rsp)
          act:  "rsp",
        },
        { struct: "tl"
          package: "tlul_pkg"
          type: "req_rsp"
          act: "rsp"
          name: "tl"
        },
        { struct: "lc_tx",
          package: "lc_ctrl_pkg",
          type: "uni"
          act: "rcv"
          name: "lc_nvm_debug_en"
        },
        { struct: "lc_tx"
          package: "lc_ctrl_pkg"
          type: "uni"
          act: "rcv"
          name: "flash_bist_enable"
        },
        { struct: "logic"
          package: ""
          type: "uni"
          act: "rcv"
          name: "flash_power_down_h"
        },
        { struct: "logic"
          package: ""
          type: "uni"
          act: "rcv"
          name: "flash_power_ready_h"
        },
        { struct: "logic",
          package: "",
          width: "4",
          type: "uni"
          act: "rcv"
          name: "flash_test_mode_a"
        },
        { struct: "logic",
          package: "",
          type: "uni"
          act: "rcv"
          name: "flash_test_voltage_h"
        },
        { struct: "ast_dif",
          package: "ast_pkg",
          type: "uni"
          act: "req"
          name: "flash_alert"
        },
      ],
    },
  ],

  // The port data structure is not something that should be used liberally.
  // It is used specifically to assign special attributes to specific ports.
  // For example, this allows us to designate a port as part of inter-module
  // connections.
  port: [
    { name: "ast",
      inter_signal_list: [
        { struct: "edn",
          type: "req_rsp",
          name: "edn",
          // The activity direction for a port inter-signal is "opposite" of
          // what the external module actually needs.
          act:  "rsp",
          package: "edn_pkg",
        },

        { struct: "lc_tx",
          type: "uni",
          name: "lc_dft_en",
          // The activity direction for a port inter-signal is "opposite" of
          // what the external module actually needs.
          act:  "req",
          package: "lc_ctrl_pkg",
        },

        { struct:  "ram_1p_cfg",
          package: "prim_ram_1p_pkg",
          type:    "uni",
          name:    "ram_1p_cfg",
          // The activity direction for a port inter-signal is "opposite" of
          // what the external module actually needs.
          act:     "rcv"
        },

        { struct:  "ram_2p_cfg",
          package: "prim_ram_2p_pkg",
          type:    "uni",
          name:    "ram_2p_cfg",
          // The activity direction for a port inter-signal is "opposite" of
          // what the external module actually needs.
          act:     "rcv"
        },

        { struct:  "rom_cfg",
          package: "prim_rom_pkg",
          type:    "uni",
          name:    "rom_cfg",
          // The activity direction for a port inter-signal is "opposite" of
          // what the external module actually needs.
          act:     "rcv"
        }
      ]
    },
  ]

  // Inter-module Connection.
  // format:
  //    requester: [ resp1, resp2, ... ],
  //
  //  the field and value should be module_inst.port_name
  //  e.g flash_ctrl0.flash: [flash_phy0.flash_ctrl]
  inter_module: {
    'connect': {
      'ast.ram_1p_cfg'          : ['otbn.ram_cfg', 'ram_main.cfg', 'ram_ret_aon.cfg', 'rv_core_ibex.ram_cfg'],
      'ast.ram_2p_cfg'          : ['spi_device.ram_cfg', 'usbdev.ram_cfg'],
      'ast.rom_cfg'             : ['rom_ctrl.rom_cfg'],
      'alert_handler.crashdump' : ['rstmgr_aon.alert_dump'],
      'alert_handler.esc_rx'    : ['rv_core_ibex.esc_nmi_rx',
                                   'lc_ctrl.esc_scrap_state0_rx',
                                   'lc_ctrl.esc_scrap_state1_rx'
                                   'pwrmgr_aon.esc_rst_rx'],
      'alert_handler.esc_tx'    : ['rv_core_ibex.esc_nmi_tx',
                                   'lc_ctrl.esc_scrap_state0_tx',
                                   'lc_ctrl.esc_scrap_state1_tx',
                                   'pwrmgr_aon.esc_rst_tx'],
      'csrng.csrng_cmd'         : ['edn0.csrng_cmd', 'edn1.csrng_cmd'],
      'csrng.entropy_src_hw_if' : ['entropy_src.entropy_src_hw_if'],
      'csrng.cs_aes_halt'       : ['entropy_src.cs_aes_halt'],
      'flash_ctrl.flash'        : ['eflash.flash_ctrl'],
      'flash_ctrl.keymgr'       : ['keymgr.flash'],
      'flash_ctrl.otp'          : ['otp_ctrl.flash_otp_key'],
      'flash_ctrl.rma_req'      : ['lc_ctrl.lc_flash_rma_req'],
      'flash_ctrl.rma_ack'      : ['lc_ctrl.lc_flash_rma_ack'],
      'flash_ctrl.rma_seed'     : ['lc_ctrl.lc_flash_rma_seed'],
      'sram_ctrl_main.sram_scr' : ['ram_main.sram_scr'],
      'sram_ctrl_main.sram_scr_init' : ['ram_main.sram_scr_init'],
      'sram_ctrl_ret_aon.sram_scr' : ['ram_ret_aon.sram_scr'],
      'sram_ctrl_ret_aon.sram_scr_init' : ['ram_ret_aon.sram_scr_init'],
      'sram_ctrl_main.en_ifetch'    : ['ram_main.en_ifetch'],
      'sram_ctrl_ret_aon.en_ifetch' : ['ram_ret_aon.en_ifetch'],
      'ram_main.intg_error'     : ['sram_ctrl_main.intg_error'],
      'ram_ret_aon.intg_error'  : ['sram_ctrl_ret_aon.intg_error'],
      'otp_ctrl.sram_otp_key'   : ['sram_ctrl_main.sram_otp_key',
                                   'sram_ctrl_ret_aon.sram_otp_key']
      'pwrmgr_aon.pwr_flash'    : ['flash_ctrl.pwrmgr'],
      'pwrmgr_aon.pwr_rst'      : ['rstmgr_aon.pwr'],
      'pwrmgr_aon.pwr_clk'      : ['clkmgr_aon.pwr'],
      'pwrmgr_aon.pwr_otp'      : ['otp_ctrl.pwr_otp'],
      'pwrmgr_aon.pwr_lc'       : ['lc_ctrl.pwr_lc'],
      'pwrmgr_aon.strap'        : ['pinmux_aon.strap_en'],
      'pwrmgr_aon.low_power'    : ['pinmux_aon.sleep_en','aon_timer_aon.sleep_mode'],
      'rom_ctrl.pwrmgr_data'    : ['pwrmgr_aon.rom_ctrl'],
      'rom_ctrl.keymgr_data'    : ['keymgr.rom_digest'],
      'flash_ctrl.keymgr'       : ['keymgr.flash'],
      'alert_handler.crashdump' : ['rstmgr_aon.alert_dump'],
      'rv_core_ibex.crash_dump'  : ['rstmgr_aon.cpu_dump'],
      'csrng.entropy_src_hw_if' : ['entropy_src.entropy_src_hw_if'],

      // usbdev connection to pinmux
      'usbdev.usb_out_of_rst'   : ['pinmux_aon.usb_out_of_rst'],
      'usbdev.usb_aon_wake_en'  : ['pinmux_aon.usb_aon_wake_en'],
      'usbdev.usb_aon_wake_ack' : ['pinmux_aon.usb_aon_wake_ack'],
      'usbdev.usb_suspend'      : ['pinmux_aon.usb_suspend'],
      'pinmux_aon.usb_state_debug' : ['usbdev.usb_state_debug'],

      // Edn connections
      'edn0.edn'              : ['keymgr.edn', 'otp_ctrl.edn', 'ast.edn', 'kmac.entropy',
                                 'alert_handler.edn', 'aes.edn', 'otbn.edn_urnd'],
      'edn1.edn'              : ['otbn.edn_rnd'],

      // OTBN OTP scramble key
      'otp_ctrl.otbn_otp_key' : ['otbn.otbn_otp_key'],

      // KeyMgr Sideload & KDF function
      'otp_ctrl.otp_keymgr_key' : ['keymgr.otp_key'],
      'keymgr.kmac_key'         : ['kmac.keymgr_key']

      // KMAC Application Interface
      'kmac.app'                : ['keymgr.kmac_data',    // Keymgr needs to be at index 0
                                   'lc_ctrl.kmac_data',   // LC needs to be at index 1
                                   'rom_ctrl.kmac_data'], // ROM needs to be at index 2

      // The idle connection is automatically connected through topgen.
      // The user does not need to explicitly declare anything other than
      // an empty list.
      'clkmgr_aon.idle'         : [],

      // Pinmux JTAG signals
      'pinmux_aon.lc_jtag' : ['lc_ctrl.jtag'],
      'pinmux_aon.rv_jtag' : ['rv_dm.jtag'],

      // OTP LC interface
      'otp_ctrl.otp_lc_data'   : ['lc_ctrl.otp_lc_data'],
      'lc_ctrl.lc_otp_program' : ['otp_ctrl.lc_otp_program'],

      // Diversification constant coming from life cycle
      'lc_ctrl.lc_keymgr_div'  : ['keymgr.lc_keymgr_div'],

      // LC function control signal broadcast
      'lc_ctrl.lc_dft_en'          : ['otp_ctrl.lc_dft_en',
                                      'pinmux_aon.lc_dft_en',
                                      'ast.lc_dft_en',
                                      'clkmgr_aon.lc_dft_en'
                                     ],
      'lc_ctrl.lc_nvm_debug_en'    : ['eflash.lc_nvm_debug_en'],
      'lc_ctrl.lc_hw_debug_en'     : ['sram_ctrl_main.lc_hw_debug_en',
                                      'sram_ctrl_ret_aon.lc_hw_debug_en',
                                      'pinmux_aon.lc_hw_debug_en',
                                      'csrng.lc_hw_debug_en',
                                      'rv_dm.lc_hw_debug_en'],
      'lc_ctrl.lc_cpu_en'          : ['rv_core_ibex.lc_cpu_en'],
      'lc_ctrl.lc_keymgr_en'       : ['keymgr.lc_keymgr_en'],
      'lc_ctrl.lc_escalate_en'     : ['aes.lc_escalate_en',
                                      'otbn.lc_escalate_en',
                                      'otp_ctrl.lc_escalate_en',
                                      'sram_ctrl_main.lc_escalate_en',
                                      'sram_ctrl_ret_aon.lc_escalate_en',
                                      'aon_timer_aon.lc_escalate_en',
                                      'flash_ctrl.lc_escalate_en'],

      'lc_ctrl.lc_check_byp_en'    : ['otp_ctrl.lc_check_byp_en'],
      'lc_ctrl.lc_clk_byp_req'     : ['clkmgr_aon.lc_clk_byp_req'],
      'lc_ctrl.lc_clk_byp_ack'     : ['clkmgr_aon.lc_clk_byp_ack'],

      // LC access control signal broadcast
      'lc_ctrl.lc_creator_seed_sw_rw_en'   : ['otp_ctrl.lc_creator_seed_sw_rw_en',
                                              'flash_ctrl.lc_creator_seed_sw_rw_en'],
      'lc_ctrl.lc_owner_seed_sw_rw_en'     : ['flash_ctrl.lc_owner_seed_sw_rw_en'],
      'lc_ctrl.lc_iso_part_sw_rd_en'       : ['flash_ctrl.lc_iso_part_sw_rd_en'],
      'lc_ctrl.lc_iso_part_sw_wr_en'       : ['flash_ctrl.lc_iso_part_sw_wr_en'],
      'lc_ctrl.lc_seed_hw_rd_en'           : ['otp_ctrl.lc_seed_hw_rd_en',
                                              'flash_ctrl.lc_seed_hw_rd_en'],


      // rv core ibex peripheral connections
      'rv_core_ibex.fatal_intg_event' : ['rv_core_ibex_peri.fatal_intg_event'],
      'rv_core_ibex.fatal_core_event' : ['rv_core_ibex_peri.fatal_core_event'],
      'rv_core_ibex.recov_core_event' : ['rv_core_ibex_peri.recov_core_event'],
      'rv_core_ibex_peri.ibus_region_cfg' : ['rv_core_ibex.ibus_region_cfg'],
      'rv_core_ibex_peri.dbus_region_cfg' : ['rv_core_ibex.dbus_region_cfg'],

      // spi passthrough connection
      'spi_device.passthrough'     : ['spi_host0.passthrough']

      // Debug module reset request to reset manager
      'rv_dm.ndmreset_req' : ['rstmgr_aon.ndmreset_req']
    }

    // top is to connect to top net/struct.
    // It defines the signal in the top and connect from the module,
    // use of the signal is up to top template
    'top': [
        'rstmgr_aon.resets', 'rstmgr_aon.rst_cpu_n',
        'pwrmgr_aon.pwr_cpu', 'pwrmgr_aon.fetch_en',
        'clkmgr_aon.clocks',

        // Debug request from debug module to CPU
        'rv_dm.debug_req',

        // Xbars
        'main.tl_corei', 'main.tl_cored',

        // Pinmux JTAG signals for the tool-inserted DFT TAP
        'pinmux_aon.dft_jtag',

        // OTP HW_CFG Broadcast signals.
        // TODO(#6713): The actual struct breakout and mapping currently needs to
        // be performed by hand in the toplevel template.
        'otp_ctrl.otp_hw_cfg',
        'csrng.otp_en_csrng_sw_app_read',
        'entropy_src.otp_en_entropy_src_fw_read',
        'entropy_src.otp_en_entropy_src_fw_over',
        'lc_ctrl.otp_device_id',
        'keymgr.otp_device_id',
        'sram_ctrl_main.otp_en_sram_ifetch',
        'sram_ctrl_ret_aon.otp_en_sram_ifetch'
    ],

    // ext is to create port in the top.
    'external': {
        'adc_ctrl_aon.adc'             : 'adc'
        'ast.edn'                      : '',
        'ast.lc_dft_en'                : '',
        'ast.ram_1p_cfg'               : 'ram_1p_cfg',
        'ast.ram_2p_cfg'               : 'ram_2p_cfg',
        'ast.rom_cfg'                  : 'rom_cfg',
        'clkmgr_aon.clk_main'          : 'clk_main',  // clock inputs
        'clkmgr_aon.clk_io'            : 'clk_io',    // clock inputs
        'clkmgr_aon.clk_usb'           : 'clk_usb',   // clock inputs
        'clkmgr_aon.clk_aon'           : 'clk_aon',   // clock inputs
        'clkmgr_aon.jitter_en'         : 'clk_main_jitter_en',
        'clkmgr_aon.ast_clk_byp_req'   : 'ast_clk_byp_req',
        'clkmgr_aon.ast_clk_byp_ack'   : 'ast_clk_byp_ack',
        'eflash.flash_alert'           : 'flash_alert',
        'eflash.flash_bist_enable'     : 'flash_bist_enable',
        'eflash.flash_power_down_h'    : 'flash_power_down_h',
        'eflash.flash_power_ready_h'   : 'flash_power_ready_h',
        'entropy_src.entropy_src_rng'  : 'es_rng',
        'entropy_src.rng_fips'         : 'es_rng_fips',
        'peri.tl_ast'                  : 'ast_tl',
        'pinmux_aon.dft_strap_test'    : 'dft_strap_test'
        'pinmux_aon.dft_hold_tap_sel'  : 'dft_hold_tap_sel',
        'pwrmgr_aon.pwr_ast'           : 'pwrmgr_ast',
        'otp_ctrl.otp_ast_pwr_seq'     : '',
        'otp_ctrl.otp_ast_pwr_seq_h'   : '',
        'otp_ctrl.otp_alert'           : 'otp_alert',
        'sensor_ctrl_aon.ast_alert'    : 'sensor_ctrl_ast_alert',
        'sensor_ctrl_aon.ast_status'   : 'sensor_ctrl_ast_status',
        'sensor_ctrl_aon.ast2pinmux'   : 'ast2pinmux',
        'sensor_ctrl_aon.ast_init_done': 'ast_init_done',
        'usbdev.usb_ref_val'           : '',
        'usbdev.usb_ref_pulse'         : '',
    },
  },

  // Crossbars: having a top level crossbar
  // This version assumes all crossbars are instantiated at the top.
  // Assume xbar.hjson is located in the same directory of top.hjson
  xbar: [
    { name: "main",
      clock_srcs: {clk_main_i: "main", clk_fixed_i: "io_div4"},
      clock_group: "infra",
      reset: "sys",
      reset_connections: {rst_main_ni: "sys", rst_fixed_ni: "sys_io_div4"}
    },
    { name: "peri",
      clock_srcs: {clk_peri_i: "io_div4"},
      clock_group: "infra",
      reset: "sys_io_div4",
      reset_connections: {rst_peri_ni: "sys_io_div4"},
    }
  ],

  // ===== PINMUX & PINOUT ======================================================

  pinout: {
    // IO power bank declaration.
    // This list defines the IO bank power domains on the ASIC.
    // Each individual pad must be in one of the declared power domains.
    banks: ['VCC', 'AVCC', 'VIOA', 'VIOB'],
    // Pad declaration.
    // Each entry must have the following four keys:
    //
    // - name: Name of the pad (this will be exposed at the chiplevel).
    //
    // - type: Pad type (this maps to the pad types defined in prim_pad_wrapper_pkg.sv)
    //
    // - bank: Specifies in which of the IO power banks this pad lives.
    //
    // - connection: Can have either of the following values:
    //
    //               1) 'direct': This is a dedicated IO Pad that is directly connected to a peripheral.
    //
    //               2) 'manual': This is a dedicated IO signal that is not directly connected to a
    //                            peripheral. It needs to be manually wired up in the template.
    //
    //               3) 'muxed': This is a muxed IO pad that will be connected to the pinmux.
    //
    // Optionally, each pad can also have a 'desc' field for further description.
    pads: [
      // Special manually connected pads
      { name: 'POR_N'           , type: 'InputStd', bank: 'VCC' , connection: 'manual', desc: 'System reset'},
      { name: 'USB_P'           , type: 'BidirTol', bank: 'VCC' , connection: 'manual', desc: 'USB P signal'},
      { name: 'USB_N'           , type: 'BidirTol', bank: 'VCC' , connection: 'manual', desc: 'USB N signal'},
      { name: 'CC1'             , type: 'InputStd', bank: 'AVCC', connection: 'manual', desc: 'ADC input 1'},
      { name: 'CC2'             , type: 'InputStd', bank: 'AVCC', connection: 'manual', desc: 'ADC input 2'},
      { name: 'FLASH_TEST_VOLT' , type: 'AnalogIn0',bank: 'VCC' , connection: 'manual', desc: 'Flash test voltage input'},
      { name: 'FLASH_TEST_MODE0', type: 'InputStd', bank: 'VCC' , connection: 'manual', desc: 'Flash test mode signal'},
      { name: 'FLASH_TEST_MODE1', type: 'InputStd', bank: 'VCC' , connection: 'manual', desc: 'Flash test mode signal'},
      { name: 'OTP_EXT_VOLT'    , type: 'AnalogIn1',bank: 'VCC' , connection: 'manual', desc: 'OTP external voltage input'},
      // Dedicated IOs
      { name: 'SPI_HOST_D0'     , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI host data'},
      { name: 'SPI_HOST_D1'     , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI host data'},
      { name: 'SPI_HOST_D2'     , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI host data'},
      { name: 'SPI_HOST_D3'     , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI host data'},
      { name: 'SPI_HOST_CLK'    , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI host clock'},
      { name: 'SPI_HOST_CS_L'   , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI host chip select'},
      { name: 'SPI_DEV_D0'      , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI device data'},
      { name: 'SPI_DEV_D1'      , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI device data'},
      { name: 'SPI_DEV_D2'      , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI device data'},
      { name: 'SPI_DEV_D3'      , type: 'BidirStd', bank: 'VIOA', connection: 'direct', desc: 'SPI device data'},
      { name: 'SPI_DEV_CLK'     , type: 'InputStd', bank: 'VIOA', connection: 'direct', desc: 'SPI device clock'},
      { name: 'SPI_DEV_CS_L'    , type: 'InputStd', bank: 'VIOA', connection: 'direct', desc: 'SPI device chip select'},
      // IOA
      { name: 'IOA0'            , type: 'BidirStd', bank: 'VIOA', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOA1'            , type: 'BidirStd', bank: 'VIOA', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOA2'            , type: 'BidirStd', bank: 'VIOA', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOA3'            , type: 'BidirStd', bank: 'VIOA', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOA4'            , type: 'BidirStd', bank: 'VIOA', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOA5'            , type: 'BidirStd', bank: 'VIOA', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOA6'            , type: 'BidirOd',  bank: 'VIOA', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOA7'            , type: 'BidirOd',  bank: 'VIOA', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOA8'            , type: 'BidirOd',  bank: 'VIOA', connection: 'muxed' , desc: 'Muxed IO pad'},
      // IOB
      { name: 'IOB0'            , type: 'BidirStd', bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB1'            , type: 'BidirStd', bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB2'            , type: 'BidirStd', bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB3'            , type: 'BidirStd', bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB4'            , type: 'BidirStd', bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB5'            , type: 'BidirStd', bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB6'            , type: 'BidirStd', bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB7'            , type: 'BidirStd', bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB8'            , type: 'BidirStd', bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB9'            , type: 'BidirOd' , bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB10'           , type: 'BidirOd' , bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB11'           , type: 'BidirOd' , bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOB12'           , type: 'BidirOd' , bank: 'VIOB', connection: 'muxed' , desc: 'Muxed IO pad'},
      // IOC
      { name: 'IOC0'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC1'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC2'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC3'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC4'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC5'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC6'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC7'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC8'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC9'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC10'           , type: 'BidirOd' , bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC11'           , type: 'BidirOd' , bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOC12'           , type: 'BidirOd' , bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      // IOR
      { name: 'IOR0'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR1'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR2'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR3'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR4'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR5'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR6'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR7'            , type: 'BidirStd', bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR8'            , type: 'BidirOd' , bank: 'VCC' , connection: 'direct', desc: 'Dedicated sysrst_ctrl output (ec_rst_l)'},
      { name: 'IOR9'            , type: 'BidirOd' , bank: 'VCC' , connection: 'direct', desc: 'Dedicated sysrst_ctrl output (pwrb_out)'},
      { name: 'IOR10'           , type: 'BidirOd' , bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR11'           , type: 'BidirOd' , bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR12'           , type: 'BidirOd' , bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
      { name: 'IOR13'           , type: 'BidirOd' , bank: 'VCC' , connection: 'muxed' , desc: 'Muxed IO pad'},
    ]
  }

  pinmux: {
    // Signal to pinmux/pad mapping.
    // Each entry in the list below must have the following two mandatory keys:
    //
    // - instance: This is the comportable IO instance name where the IO signal comes from.
    //
    // - connection: This key is similar to the connection key in the pinout/pad configuration and
    //               can have either of the following values:
    //
    //               1) 'direct': This is a dedicated IO signal that is directly connected to a pad.
    //                            Such an IO signal must also specify the 'port' and 'pad' keys
    //                            (see further below).
    //
    //               2) 'manual': This is a dedicated IO signal that is not directly connected to a pad.
    //                            It needs to be manually wired up in the template.
    //                            Such an IO signal may have a 'port' key, but no 'pad' key.
    //
    //               3) 'muxed': This is a muxed IO signal that will be connected to the pinmux.
    //                           Such an IO signal may have a 'port' key, but no 'pad' key.
    //
    // Depending on the connection type specified, each entry may have the following optional keys:
    //
    // - port: Name of the available IO signal of the instance.
    //         This is required for 'direct' connections, but optional for the others.
    //         Individual signals of a bus IO signal must be indexed with square brackets, e.g. mybus[1].
    //         Not specifying this key or setting it to an empty string acts as a wild card
    //         and includes all available IOs of this instance.
    //
    // - pad: Name of the pad the 'direct' connection should connect to.
    //        This is not required for 'muxed' and 'manual' connections.
    //
    // - desc: Optional description field.
    //
    // - attr: Manual direct IOs may specify an additional pad attr field.
    //         This is used to create the correct pad attribute CSR for that DIO channel (since the
    //         DIO is manual, there is no way to automatically infer the corresponding pad type).
    //
    signals: [
      // SPI Host0
      { instance: 'spi_host0',       port: 'sck',          connection: 'direct', pad: 'SPI_HOST_CLK' , desc: ''},
      { instance: 'spi_host0',       port: 'csb',          connection: 'direct', pad: 'SPI_HOST_CS_L', desc: ''},
      { instance: 'spi_host0',       port: 'sd[0]',        connection: 'direct', pad: 'SPI_HOST_D0'  , desc: ''},
      { instance: 'spi_host0',       port: 'sd[1]',        connection: 'direct', pad: 'SPI_HOST_D1'  , desc: ''},
      { instance: 'spi_host0',       port: 'sd[2]',        connection: 'direct', pad: 'SPI_HOST_D2'  , desc: ''},
      { instance: 'spi_host0',       port: 'sd[3]',        connection: 'direct', pad: 'SPI_HOST_D3'  , desc: ''},
      // SPI Device
      { instance: 'spi_device',      port: 'sck',          connection: 'direct', pad: 'SPI_DEV_CLK'  , desc: ''},
      { instance: 'spi_device',      port: 'csb',          connection: 'direct', pad: 'SPI_DEV_CS_L' , desc: ''},
      { instance: 'spi_device',      port: 'sd[0]',        connection: 'direct', pad: 'SPI_DEV_D0'   , desc: ''},
      { instance: 'spi_device',      port: 'sd[1]',        connection: 'direct', pad: 'SPI_DEV_D1'   , desc: ''},
      { instance: 'spi_device',      port: 'sd[2]',        connection: 'direct', pad: 'SPI_DEV_D2'   , desc: ''},
      { instance: 'spi_device',      port: 'sd[3]',        connection: 'direct', pad: 'SPI_DEV_D3'   , desc: ''},
      // USBDEV
      // TODO: #6043
      { instance: 'usbdev',          port: 'd',            connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      { instance: 'usbdev',          port: 'dp',           connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      { instance: 'usbdev',          port: 'dn',           connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      { instance: 'usbdev',          port: 'sense',        connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      { instance: 'usbdev',          port: 'se0',          connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      { instance: 'usbdev',          port: 'dp_pullup',    connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      { instance: 'usbdev',          port: 'dn_pullup',    connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      { instance: 'usbdev',          port: 'tx_mode_se',   connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      { instance: 'usbdev',          port: 'suspend',      connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      { instance: 'usbdev',          port: 'rx_enable',    connection: 'manual', pad: ''             , desc: '', attr: 'BidirTol'},
      // MIOs
      { instance: "gpio",            port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "uart0",           port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "uart1",           port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "uart2",           port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "uart3",           port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "i2c0",            port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "i2c1",            port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "i2c2",            port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "pattgen",         port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "spi_host1",       port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "flash_ctrl",      port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sensor_ctrl_aon", port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "pwm_aon",         port: '',             connection: 'muxed' , pad: ''             , desc: ''},
      // Sysrst ctrl has both muxed and dedicated IOs
      { instance: "sysrst_ctrl_aon", port: 'ac_present',   connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'ec_rst_in_l',  connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'key0_in',      connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'key1_in',      connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'key2_in',      connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'pwrb_in',      connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'bat_disable',  connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'ec_rst_out_l', connection: 'direct', pad: 'IOR8'         , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'key0_out',     connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'key1_out',     connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'key2_out',     connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'pwrb_out',     connection: 'direct', pad: 'IOR9'         , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'lid_open',     connection: 'muxed' , pad: ''             , desc: ''},
      { instance: "sysrst_ctrl_aon", port: 'z3_wakeup',    connection: 'muxed' , pad: ''             , desc: ''},
    ],

    num_wkup_detect: 8
    wkup_cnt_width:  8
  }

  // Implementation targets.
  // This defines the configuration of the target-specific chip-levels  to
  // generate from the shared template. Each target uses the same base
  // configuration for the  pinmux and pinout as defined above, and the
  // generated software constants for the pinmux DIF do not change among the
  // implementation targets. However, in order to accommodate slight
  // differences among the ASIC, FPGA emulation and simulation environments,
  // it is possible to make very limited pinout changes below. In particular,
  // it is possible to remove and tie-off specific pads, or add more 'manual'
  // pads that need to be manually connected in the template. It is also possible
  // to override the JTAG and strap locations indices, since the testing and DFT
  // setups may differ among the targets.
  targets: [
    { name: 'asic',

      // Pinout Changes.
      pinout: {
        // This is a list of pad names to remove from the base pinout defined
        // above. Removed pads will be stubbed off such that their inputs
        // signals are driven  with zero. Output signals and output enables
        // will be left unconnected. If no changes are needed, this list can
        // be left empty.
        remove_pads: [],

        // This is a list of additional "manual" pads to add to the pinout.
        // The pad entries have the same format as the pad entries in the pinout
        // configuration above. However, the 'connection' key must always be set
        // to 'manual' as it is not possible to connect these additional pads
        // to the pinmux or peripherals.
        add_pads: [],
      },

      pinmux: {
        // Special signal positions. Each entry in the list below creates a
        // target-specific pad position parameter in the  chiplevel hierarchy
        // that can be used to parameterize certain IPs like the pinmux or
        // padring. This is mainly used to define the pad positions of special
        // test and DFT signals such as the JTAG signals and the TAP and DFT
        // straps. Straps in this context are special pads that get sampled at
        // boot time during certain life cycle states in order to determine
        // DFT modes and the TAP mux selection index (the JTAG signals can be
        // muxed to either the lifecycle TAP, DFT TAP or RISC-V processor
        // TAP). TODO: add more documentation to https://docs.opentitan.org/hw/ip/pinmux/doc/index.html
        // Each entry must have the following two keys:
        //
        // - name: Basename for the SV parameter.
        //
        // - pad: The pad name that this special signal maps to. The generated
        //        parameter will be assigned the corresponding pad index.
        //
        // Each entry may have an optional 'desc' key for further description.
        special_signals: [
          // Straps
          { name: 'tap0',   pad: 'IOC8', desc: 'TAP strap signal.'  },
          { name: 'tap1',   pad: 'IOC5', desc: 'TAP strap signal.'  },
          { name: 'dft0',   pad: 'IOC3', desc: 'DFT strap signal.'  },
          { name: 'dft1',   pad: 'IOC4', desc: 'DFT strap signal.'  },
          // JTAG
          { name: 'tck',    pad: 'IOR3', desc: 'JTAG tck signal.'    },
          { name: 'tms',    pad: 'IOR0', desc: 'JTAG tms signal.'    },
          { name: 'trst_n', pad: 'IOR4', desc: 'JTAG trst_n signal.' },
          { name: 'tdi',    pad: 'IOR2', desc: 'JTAG tdi signal.'    },
          { name: 'tdo',    pad: 'IOR1', desc: 'JTAG tdo signal.'    },
        ],
      }
    },
    { name: 'cw310',

      pinout: {
        remove_pads: [
          'CC1', 'CC2',
          'SPI_DEV_D2', 'SPI_DEV_D3'
          'SPI_HOST_CLK', 'SPI_HOST_CS_L',
          'SPI_HOST_D0', 'SPI_HOST_D1', 'SPI_HOST_D2', 'SPI_HOST_D3',
          'FLASH_TEST_VOLT', 'OTP_EXT_VOLT'
          'FLASH_TEST_MODE0', 'FLASH_TEST_MODE1',
          'IOB10', 'IOB11', 'IOB12',
          'IOC0', 'IOC1', 'IOC12',
          'IOR0', 'IOR1', 'IOR2', 'IOR3', 'IOR4', 'IOR5', 'IOR6', 'IOR7', 'IOR8', 'IOR9', 'IOR10', 'IOR11', 'IOR12', 'IOR13'
        ],

        add_pads: [
          // Additional infrastucture pads
          { name: 'IO_CLK',           type: 'InputStd', bank: 'VCC', connection: 'manual', desc: 'Extra clock input for FPGA target'}
          { name: 'IO_JSRST_N',       type: 'InputStd', bank: 'VCC', connection: 'manual', desc: 'Dedicated JTAG system reset input'}
          // Custom USB pads
          { name: 'IO_USB_SENSE0',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB signal for FPGA target'}
          { name: 'IO_USB_DNPULLUP0', type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB signal for FPGA target'}
          { name: 'IO_USB_DPPULLUP0', type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB signal for FPGA target'}
          { name: 'IO_UPHY_DP_TX',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_DN_TX',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_DP_RX',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_DN_RX',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_D_RX',     type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_OE_N',     type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_SENSE',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_DPPULLUP', type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
        ],
      },

pinmux: {
        special_signals: [
          // Straps
          { name: 'tap0',   pad: 'IOC0' ,        desc: 'TAP strap signal, maps to a stubbed-off MIO.'  },
          { name: 'tap1',   pad: 'IOB7',         desc: 'TAP strap signal, maps to MIO pad 16.'         },
          { name: 'dft0',   pad: 'IOC1' ,        desc: 'DFT strap signal, maps to a stubbed-off MIO.'  },
          { name: 'dft1',   pad: 'IOC12',        desc: 'DFT strap signal, maps to a stubbed-off MIO.'  },
          // JTAG
          { name: 'tck',    pad: 'SPI_DEV_CLK' , desc: 'JTAG tck signal, overlaid on SPI_DEV.'   },
          { name: 'tms',    pad: 'SPI_DEV_CS_L', desc: 'JTAG tms signal, overlaid on SPI_DEV.'   },
          { name: 'trst_n', pad: 'IOB9'        , desc: 'JTAG trst_n signal, maps to MIO pad 18.' },
          { name: 'tdi',    pad: 'SPI_DEV_D0'  , desc: 'JTAG tdi signal, overlaid on SPI_DEV.'   },
          { name: 'tdo',    pad: 'SPI_DEV_D1'  , desc: 'JTAG tdo signal, overlaid on SPI_DEV.'   },
        ],
      }
    }
    { name: 'nexysvideo',

      pinout: {
        remove_pads: [
          'CC1', 'CC2',
          'SPI_DEV_D2', 'SPI_DEV_D3'
          'SPI_HOST_CLK', 'SPI_HOST_CS_L',
          'SPI_HOST_D0', 'SPI_HOST_D1', 'SPI_HOST_D2', 'SPI_HOST_D3',
          'FLASH_TEST_VOLT', 'OTP_EXT_VOLT'
          'FLASH_TEST_MODE0', 'FLASH_TEST_MODE1',
          'IOB10', 'IOB11', 'IOB12',
          'IOC0', 'IOC1', 'IOC12',
          'IOR0', 'IOR1', 'IOR2', 'IOR3', 'IOR4', 'IOR5', 'IOR6', 'IOR7', 'IOR8', 'IOR9', 'IOR10', 'IOR11', 'IOR12', 'IOR13'
        ],

        add_pads: [
          // Additional infrastucture pads
          { name: 'IO_CLK',           type: 'InputStd', bank: 'VCC', connection: 'manual', desc: 'Extra clock input for FPGA target'}
          { name: 'IO_JSRST_N',       type: 'InputStd', bank: 'VCC', connection: 'manual', desc: 'Dedicated JTAG system reset input'}
          // Custom USB pads
          { name: 'IO_USB_SENSE0',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB signal for FPGA target'}
          { name: 'IO_USB_DNPULLUP0', type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB signal for FPGA target'}
          { name: 'IO_USB_DPPULLUP0', type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB signal for FPGA target'}
          { name: 'IO_UPHY_DP_TX',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_DN_TX',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_DP_RX',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_DN_RX',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_D_RX',     type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_OE_N',     type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_SENSE',    type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
          { name: 'IO_UPHY_DPPULLUP', type: 'BidirStd', bank: 'VCC', connection: 'manual', desc: 'Manual USB UPHY signal for FPGA target'}
        ],
      },

pinmux: {
        special_signals: [
          // Straps
          { name: 'tap0',   pad: 'IOC0' ,        desc: 'TAP strap signal, maps to a stubbed-off MIO.'  },
          { name: 'tap1',   pad: 'IOB7',         desc: 'TAP strap signal, maps to MIO pad 16.'         },
          { name: 'dft0',   pad: 'IOC1' ,        desc: 'DFT strap signal, maps to a stubbed-off MIO.'  },
          { name: 'dft1',   pad: 'IOC12',        desc: 'DFT strap signal, maps to a stubbed-off MIO.'  },
          // JTAG
          { name: 'tck',    pad: 'SPI_DEV_CLK' , desc: 'JTAG tck signal, overlaid on SPI_DEV.'   },
          { name: 'tms',    pad: 'SPI_DEV_CS_L', desc: 'JTAG tms signal, overlaid on SPI_DEV.'   },
          { name: 'trst_n', pad: 'IOB9'        , desc: 'JTAG trst_n signal, maps to MIO pad 18.' },
          { name: 'tdi',    pad: 'SPI_DEV_D0'  , desc: 'JTAG tdi signal, overlaid on SPI_DEV.'   },
          { name: 'tdo',    pad: 'SPI_DEV_D1'  , desc: 'JTAG tdo signal, overlaid on SPI_DEV.'   },
        ],
      }
    }
  ]
}
