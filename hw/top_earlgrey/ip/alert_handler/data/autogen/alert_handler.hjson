// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
// util/topgen.py -t hw/top_earlgrey/data/top_earlgrey.hjson --alert-handler-only -o hw/top_earlgrey/

// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
# ALERT_HANDLER register template
#
# Parameter (given by Python tool)
#  - n_alerts:    Number of alert sources
#  - esc_cnt_dw:  Width of escalation counter
#  - accu_cnt_dw: Width of accumulator
#  - async_on:    Enables asynchronous sygnalling between specific alert RX/TX pairs
#  - n_classes:   Number of supported classes (leave this at 4 at the moment)

{
  name: "ALERT_HANDLER",
  clock_primary: "clk_i",
  other_clock_list: [ "clk_edn_i" ],
  reset_primary: "rst_ni",
  other_reset_list: [ "rst_edn_ni" ],
  bus_device: "tlul",
  regwidth: "32",
  hier_path: "i_reg_wrap"
  param_list: [
    // Random netlist constants
    { name:      "RndCnstLfsrSeed",
      desc:      "Compile-time random bits for initial LFSR seed",
      type:      "alert_pkg::lfsr_seed_t"
      randcount: "32",
      randtype:  "data", // randomize randcount databits
    }
    { name:      "RndCnstLfsrPerm",
      desc:      "Compile-time random permutation for LFSR output",
      type:      "alert_pkg::lfsr_perm_t"
      randcount: "32",
      randtype:  "perm", // random permutation for randcount elements
    }
    // Normal parameters
    { name: "NAlerts",
      desc: "Number of peripheral inputs",
      type: "int",
      default: "27",
      local: "true"
    },
    { name: "EscCntDw",
      desc: "Number of peripheral outputs",
      type: "int",
      default: "32",
      local: "true"
    },
    { name: "AccuCntDw",
      desc: "Number of peripheral outputs",
      type: "int",
      default: "16",
      local: "true"
    },
    { name: "AsyncOn",
      desc: "Number of peripheral outputs",
      type: "logic [NAlerts-1:0]",
      default: "27'b111011111100001100000001111",
      local: "true"
    },
    { name: "N_CLASSES",
      desc: "Number of classes",
      type: "int",
      default: "4",
      local: "true"
    },
    { name: "N_ESC_SEV",
      desc: "Number of escalation severities",
      type: "int",
      default: "4",
      local: "true"
    },
    { name: "N_PHASES",
      desc: "Number of escalation phases",
      type: "int",
      default: "4",
      local: "true"
    },
    { name: "N_LOC_ALERT",
      desc: "Number of local alerts phases",
      type: "int",
      default: "4",
      local: "true"
    },
    { name: "PING_CNT_DW",
      desc: "Width of ping counter",
      type: "int",
      default: "24",
      local: "true"
    },
    { name: "PHASE_DW",
      desc: "Width of phase ID",
      type: "int",
      default: "2",
      local: "true"
    },
    { name: "CLASS_DW",
      desc: "Width of class ID",
      type: "int",
      default: "2",
      local: "true"
    },
  ],

  inter_signal_list: [
    { struct:  "alert_crashdump",
      type:    "uni",
      name:    "crashdump",
      act:     "req",
      package: "alert_pkg"
    },
    { struct:  "edn"
      type:    "req_rsp"
      name:    "edn"
      act:     "req"
      width:   "1"
      package: "edn_pkg"
    },
    { struct:  "esc_rx"
      type:    "uni"
      name:    "esc_rx"
      act:     "rcv"
      width:   "4", // N_ESC_SEV
      package: "prim_esc_pkg"
    },
    { struct:  "esc_tx"
      type:    "uni"
      name:    "esc_tx"
      act:     "req"
      width:   "4", // N_ESC_SEV
      package: "prim_esc_pkg"
    },
  ]
# interrupt registers for the classes
  interrupt_list: [
    { name: "classa",
      desc: '''
            Interrupt state bit of Class A. Set by HW in case an alert within this class triggered. Defaults true, write one to clear.
            ''',
    },
    { name: "classb",
      desc: '''
            Interrupt state bit of Class B. Set by HW in case an alert within this class triggered. Defaults true, write one to clear.
            ''',
    },
    { name: "classc",
      desc: '''
            Interrupt state bit of Class C. Set by HW in case an alert within this class triggered. Defaults true, write one to clear.
            ''',
    },
    { name: "classd",
      desc: '''
            Interrupt state bit of Class D. Set by HW in case an alert within this class triggered. Defaults true, write one to clear.
            ''',
    },
  ],

  registers: [
# register locks for alerts and class configs
    { name: "REGWEN",
      desc: '''
            Register write enable for all control registers.
            ''',
      swaccess: "rw0c",
      hwaccess: "hro",
      fields: [
        {
            bits:   "0",
            desc: ''' When true, the alert enable and escalation configuration registers can be modified.
            When false, they become read-only. Defaults true, write one to clear. Note that this needs to be
            cleared after initial configuration at boot in order to lock in the configuration and activate
            the ping testing.
            '''
            resval: 1,
        },
      ]
    },
    { name:     "PING_TIMEOUT_CYC",
      desc:     '''
                Ping timeout cycle count.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        {
          # TODO: add PING_CNT_DW parameter here
          bits: "23:0",
          resval:   32,
          desc: '''Timeout value in cycles. If an alert receiver or an escalation sender does not
          respond to a ping within this timeout window, a pingfail alert will be raised.
          '''
        }
      ]
    }
# all alerts
    {skipto: "0x20"},
    { multireg: { name:     "ALERT_EN",
                  desc:     '''Enable register for alerts.
                  ''',
                  count:    "NAlerts",
                  swaccess: "rw",
                  hwaccess: "hro",
                  regwen:   "REGWEN",
                  cname:    "alert",
                  tags:     [// Enable `alert_en` might cause top-level escalators to trigger
                             // unexpected reset
                             "excl:CsrAllTests:CsrExclWrite"]
                 fields: [
                    { bits: "0",
                      name: "EN_A",
                      desc: "Alert enable "
                    }
                  ]
                }
    },
    {skipto: "0x120"},
    { multireg: { name:     "ALERT_CLASS",
                  desc:     '''Class assignment of alerts.
                  ''',
                  count:    "NAlerts",
                  swaccess: "rw",
                  hwaccess: "hro",
                  regwen:   "REGWEN",
                  cname:    "alert",
                  fields: [
                    {
                      # TODO: bitwidth should be parameterized with CLASS_DW
                      bits: "1:0",
                      name: "CLASS_A",
                      desc: "Classification ",
                      enum: [
                              { value: "0", name: "ClassA", desc: "" },
                              { value: "1", name: "ClassB", desc: "" },
                              { value: "2", name: "ClassC", desc: "" },
                              { value: "3", name: "ClassD", desc: "" },
                            ]
                    }
                  ]
                }
    },
    {skipto: "0x220"},
    { multireg: {
      name: "ALERT_CAUSE",
      desc: "Alert Cause Register",
      count: "NAlerts",
      cname: "ALERT",
      swaccess: "rw1c",
      hwaccess: "hrw",
      fields: [
        { bits: "0", name: "A", desc: "Cause bit " }
      ],
      tags: [// The value of this register is determined by triggering different kinds of alerts
             // Cannot be auto-predicted so excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
      }
    },
# local alerts
    {skipto: "0x320"},
    { multireg: { name:     "LOC_ALERT_EN",
                  desc:     '''Enable register for the aggregated local alerts "alert
                  pingfail" (0), "escalation pingfail" (1), "alert integfail" (2) and "escalation integfail" (3).
                  ''',
                  count:    "N_LOC_ALERT",
                  swaccess: "rw",
                  hwaccess: "hro",
                  regwen:   "REGWEN",
                  cname:    "local alert",
                  fields: [
                    { bits: "0",
                      name: "EN_LA",
                      desc: "Alert enable "
                    }
                  ]
                }
    },
    { multireg: { name:     "LOC_ALERT_CLASS",
                  desc:     '''Class assignment of local alerts. "alert
                  pingfail" (0), "escalation pingfail" (1), "alert integfail" (2) and "escalation integfail" (3).
                  ''',
                  count:    "N_LOC_ALERT",
                  swaccess: "rw",
                  hwaccess: "hro",
                  regwen:   "REGWEN",
                  cname:    "local alert",
                  fields: [
                    {
                      # TODO: bitwidth should be parameterized with CLASS_DW
                      bits: "1:0",
                      name: "CLASS_LA",
                      desc: "Classification ",
                      enum: [
                              { value: "0", name: "ClassA", desc: "" },
                              { value: "1", name: "ClassB", desc: "" },
                              { value: "2", name: "ClassC", desc: "" },
                              { value: "3", name: "ClassD", desc: "" },
                            ]
                    }
                  ]
                }
    },
    { multireg: {
      name: "LOC_ALERT_CAUSE",
      desc: '''Alert Cause Register for Local Alerts. "alert
      pingfail" (0), "escalation pingfail" (1), "alert integfail" (2) and "escalation integfail" (3).
      ''',
      count: "N_LOC_ALERT",
      cname: "LOC_ALERT",
      swaccess: "rw1c",
      hwaccess: "hrw",
      tags: [// Top level CSR automation test, CPU clock is disabled, so escalation response will
             // not send back to alert handler. This will set loc_alert_cause and could not predict
             // automatically.
             // TODO: remove the exclusion after set up top-level esc_receiver_driver
             "excl:CsrNonInitTests:CsrExclCheck"],
      fields: [
        { bits: "0", name: "LA", desc: "Cause bit " }
      ]
      }
    },
# classes

    { name:     "CLASSA_CTRL",
      desc:     "Escalation control register for alert Class A. Can not be modified if !!REGWEN is false."
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "0",
          name: "EN",
          desc: '''
                Enable escalation mechanisms (accumulation and
                interrupt timeout) for Class A. Note that interrupts can fire
                regardless of whether the escalation mechanisms are enabled for
                this class or not.
                ''',
        }
        { bits: "1",
          name: "LOCK",
          desc: '''
                Enable automatic locking of escalation counter for class A.
                If true, there is no way to stop the escalation protocol for class A
                once it has been triggered.
                '''
        }
        { bits: "2",
          name: "EN_E0",
          resval: 1,
          desc: "Enable escalation signal 0 for Class A",
        }
        { bits: "3",
          name: "EN_E1",
          resval: 1,
          desc: "Enable escalation signal 1 for Class A",
        }
        { bits: "4",
          name: "EN_E2",
          resval: 1,
          desc: "Enable escalation signal 2 for Class A",
        }
        { bits: "5",
          name: "EN_E3",
          resval: 1,
          desc: "Enable escalation signal 3 for Class A",
        }
        # TODO: bitwidth should be parameterized with PHASE_DW
        { bits: "7:6",
          name: "MAP_E0",
          resval: 0,
          desc: "Determines in which escalation phase escalation signal 0 shall be asserted.",
        }
        { bits: "9:8",
          name: "MAP_E1",
          resval: 1,
          desc: "Determines in which escalation phase escalation signal 1 shall be asserted.",
        }
        { bits: "11:10",
          name: "MAP_E2",
          resval: 2,
          desc: "Determines in which escalation phase escalation signal 2 shall be asserted.",
        }
        { bits: "13:12",
          name: "MAP_E3",
          resval: 3,
          desc: "Determines in which escalation phase escalation signal 3 shall be asserted.",
        }
      ]
    },
    { name:     "CLASSA_REGWEN",
      desc:     '''
                Clear enable for escalation protocol of Class A alerts.
                '''
      swaccess: "rw0c",
      hwaccess: "hwo",
      fields: [
      {   bits:   "0",
          desc:   '''Register defaults to true, can only be cleared. This register is set
          to false by the hardware if the escalation protocol has been triggered and the bit
          !!CLASSA_CTRL.LOCK is true.
          ''',
          resval: 1,
        }
      ],
      tags: [// The value of this register is set to false only by hardware,
             // under the condition that escalation is triggered and the corresponding lock bit is true
             // Cannot not be auto-predicted so it is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSA_CLR",
      desc:     '''
                Clear for esclation protocol of Class A.
                '''
      swaccess: "wo",
      hwaccess: "hro",
      hwqe:     "true",
      regwen:   "CLASSA_REGWEN",
      fields: [
        { bits: "0",
          desc: '''Writing to this register clears the accumulator and aborts escalation
          (if it has been triggered). This clear is disabled if !!CLASSA_REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSA_ACCUM_CNT",
      desc:     '''
                Current accumulation value for alert Class A. Software can clear this register
                with a write to !!CLASSA_CLR register unless !!CLASSA_REGWEN is false.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "15:0" }
      ],
      tags: [// The value of this register is determined by how many alerts have been triggered
             // Cannot be auto-predicted so it is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSA_ACCUM_THRESH",
      desc:     '''
                Accumulation threshold value for alert Class A.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "15:0",
          desc: '''Once the accumulation value register is equal to the threshold escalation will
          be triggered on the next alert occurrence within this class A begins. Note that this
          register can not be modified if !!REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSA_TIMEOUT_CYC",
      desc:     '''
                Interrupt timeout in cycles.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0",
          desc: '''If the interrupt corresponding to this class is not
          handled within the specified amount of cycles, escalation will be triggered.
          Set to a positive value to enable the interrupt timeout for Class A. The timeout is set to zero
          by default, which disables this feature. Note that this register can not be modified if
          !!REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSA_PHASE0_CYC",
      desc:     '''
                Duration of escalation phase 0 for Class A.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSA_PHASE1_CYC",
      desc:     '''
                Duration of escalation phase 1 for Class A.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSA_PHASE2_CYC",
      desc:     '''
                Duration of escalation phase 2 for Class A.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSA_PHASE3_CYC",
      desc:     '''
                Duration of escalation phase 3 for Class A.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSA_ESC_CNT",
      desc:     '''
                Escalation counter in cycles for Class A.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "31:0",
          desc: '''Returns the current timeout or escalation count (depending on !!CLASSA_STATE).
          This register can not be directly cleared. However, SW can indirectly clear as follows.

          If the class is in the Timeout state, the timeout can be aborted by clearing the
          corresponding interrupt bit.

          If this class is in any of the escalation phases (e.g. Phase0), escalation protocol can be
          aborted by writing to !!CLASSA_CLR. Note however that has no effect if !!CLASSA_REGWEN
          is set to false (either by SW or by HW via the !!CLASSA_CTRL.LOCK feature).
          '''
        }
      ],
      tags: [// The value of this register is determined by counting how many cycles the escalation phase has lasted
             // Cannot be auto-predicted so excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSA_STATE",
      desc:     '''
                Current escalation state of Class A. See also !!CLASSA_ESC_CNT.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "2:0",
          enum: [
                  { value: "0b000", name: "Idle",     desc: "No timeout or escalation triggered." },
                  { value: "0b001", name: "Timeout",  desc: "IRQ timeout counter is active." },
                  { value: "0b011", name: "Terminal", desc: "Terminal state after escalation protocol." },
                  { value: "0b100", name: "Phase0",   desc: "Escalation Phase0 is active." },
                  { value: "0b101", name: "Phase1",   desc: "Escalation Phase1 is active." },
                  { value: "0b110", name: "Phase2",   desc: "Escalation Phase2 is active." },
                  { value: "0b111", name: "Phase3",   desc: "Escalation Phase3 is active." }
                ]
        }
      ],
      tags: [// The current escalation state cannot be auto-predicted
             // so this register is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },

    { name:     "CLASSB_CTRL",
      desc:     "Escalation control register for alert Class B. Can not be modified if !!REGWEN is false."
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "0",
          name: "EN",
          desc: '''
                Enable escalation mechanisms (accumulation and
                interrupt timeout) for Class B. Note that interrupts can fire
                regardless of whether the escalation mechanisms are enabled for
                this class or not.
                ''',
        }
        { bits: "1",
          name: "LOCK",
          desc: '''
                Enable automatic locking of escalation counter for class B.
                If true, there is no way to stop the escalation protocol for class B
                once it has been triggered.
                '''
        }
        { bits: "2",
          name: "EN_E0",
          resval: 1,
          desc: "Enable escalation signal 0 for Class B",
        }
        { bits: "3",
          name: "EN_E1",
          resval: 1,
          desc: "Enable escalation signal 1 for Class B",
        }
        { bits: "4",
          name: "EN_E2",
          resval: 1,
          desc: "Enable escalation signal 2 for Class B",
        }
        { bits: "5",
          name: "EN_E3",
          resval: 1,
          desc: "Enable escalation signal 3 for Class B",
        }
        # TODO: bitwidth should be parameterized with PHASE_DW
        { bits: "7:6",
          name: "MAP_E0",
          resval: 0,
          desc: "Determines in which escalation phase escalation signal 0 shall be asserted.",
        }
        { bits: "9:8",
          name: "MAP_E1",
          resval: 1,
          desc: "Determines in which escalation phase escalation signal 1 shall be asserted.",
        }
        { bits: "11:10",
          name: "MAP_E2",
          resval: 2,
          desc: "Determines in which escalation phase escalation signal 2 shall be asserted.",
        }
        { bits: "13:12",
          name: "MAP_E3",
          resval: 3,
          desc: "Determines in which escalation phase escalation signal 3 shall be asserted.",
        }
      ]
    },
    { name:     "CLASSB_REGWEN",
      desc:     '''
                Clear enable for escalation protocol of Class B alerts.
                '''
      swaccess: "rw0c",
      hwaccess: "hwo",
      fields: [
      {   bits:   "0",
          desc:   '''Register defaults to true, can only be cleared. This register is set
          to false by the hardware if the escalation protocol has been triggered and the bit
          !!CLASSB_CTRL.LOCK is true.
          ''',
          resval: 1,
        }
      ],
      tags: [// The value of this register is set to false only by hardware,
             // under the condition that escalation is triggered and the corresponding lock bit is true
             // Cannot not be auto-predicted so it is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSB_CLR",
      desc:     '''
                Clear for esclation protocol of Class B.
                '''
      swaccess: "wo",
      hwaccess: "hro",
      hwqe:     "true",
      regwen:   "CLASSB_REGWEN",
      fields: [
        { bits: "0",
          desc: '''Writing to this register clears the accumulator and aborts escalation
          (if it has been triggered). This clear is disabled if !!CLASSB_REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSB_ACCUM_CNT",
      desc:     '''
                Current accumulation value for alert Class B. Software can clear this register
                with a write to !!CLASSB_CLR register unless !!CLASSB_REGWEN is false.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "15:0" }
      ],
      tags: [// The value of this register is determined by how many alerts have been triggered
             // Cannot be auto-predicted so it is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSB_ACCUM_THRESH",
      desc:     '''
                Accumulation threshold value for alert Class B.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "15:0",
          desc: '''Once the accumulation value register is equal to the threshold escalation will
          be triggered on the next alert occurrence within this class B begins. Note that this
          register can not be modified if !!REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSB_TIMEOUT_CYC",
      desc:     '''
                Interrupt timeout in cycles.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0",
          desc: '''If the interrupt corresponding to this class is not
          handled within the specified amount of cycles, escalation will be triggered.
          Set to a positive value to enable the interrupt timeout for Class B. The timeout is set to zero
          by default, which disables this feature. Note that this register can not be modified if
          !!REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSB_PHASE0_CYC",
      desc:     '''
                Duration of escalation phase 0 for Class B.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSB_PHASE1_CYC",
      desc:     '''
                Duration of escalation phase 1 for Class B.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSB_PHASE2_CYC",
      desc:     '''
                Duration of escalation phase 2 for Class B.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSB_PHASE3_CYC",
      desc:     '''
                Duration of escalation phase 3 for Class B.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSB_ESC_CNT",
      desc:     '''
                Escalation counter in cycles for Class B.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "31:0",
          desc: '''Returns the current timeout or escalation count (depending on !!CLASSB_STATE).
          This register can not be directly cleared. However, SW can indirectly clear as follows.

          If the class is in the Timeout state, the timeout can be aborted by clearing the
          corresponding interrupt bit.

          If this class is in any of the escalation phases (e.g. Phase0), escalation protocol can be
          aborted by writing to !!CLASSB_CLR. Note however that has no effect if !!CLASSB_REGWEN
          is set to false (either by SW or by HW via the !!CLASSB_CTRL.LOCK feature).
          '''
        }
      ],
      tags: [// The value of this register is determined by counting how many cycles the escalation phase has lasted
             // Cannot be auto-predicted so excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSB_STATE",
      desc:     '''
                Current escalation state of Class B. See also !!CLASSB_ESC_CNT.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "2:0",
          enum: [
                  { value: "0b000", name: "Idle",     desc: "No timeout or escalation triggered." },
                  { value: "0b001", name: "Timeout",  desc: "IRQ timeout counter is active." },
                  { value: "0b011", name: "Terminal", desc: "Terminal state after escalation protocol." },
                  { value: "0b100", name: "Phase0",   desc: "Escalation Phase0 is active." },
                  { value: "0b101", name: "Phase1",   desc: "Escalation Phase1 is active." },
                  { value: "0b110", name: "Phase2",   desc: "Escalation Phase2 is active." },
                  { value: "0b111", name: "Phase3",   desc: "Escalation Phase3 is active." }
                ]
        }
      ],
      tags: [// The current escalation state cannot be auto-predicted
             // so this register is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },

    { name:     "CLASSC_CTRL",
      desc:     "Escalation control register for alert Class C. Can not be modified if !!REGWEN is false."
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "0",
          name: "EN",
          desc: '''
                Enable escalation mechanisms (accumulation and
                interrupt timeout) for Class C. Note that interrupts can fire
                regardless of whether the escalation mechanisms are enabled for
                this class or not.
                ''',
        }
        { bits: "1",
          name: "LOCK",
          desc: '''
                Enable automatic locking of escalation counter for class C.
                If true, there is no way to stop the escalation protocol for class C
                once it has been triggered.
                '''
        }
        { bits: "2",
          name: "EN_E0",
          resval: 1,
          desc: "Enable escalation signal 0 for Class C",
        }
        { bits: "3",
          name: "EN_E1",
          resval: 1,
          desc: "Enable escalation signal 1 for Class C",
        }
        { bits: "4",
          name: "EN_E2",
          resval: 1,
          desc: "Enable escalation signal 2 for Class C",
        }
        { bits: "5",
          name: "EN_E3",
          resval: 1,
          desc: "Enable escalation signal 3 for Class C",
        }
        # TODO: bitwidth should be parameterized with PHASE_DW
        { bits: "7:6",
          name: "MAP_E0",
          resval: 0,
          desc: "Determines in which escalation phase escalation signal 0 shall be asserted.",
        }
        { bits: "9:8",
          name: "MAP_E1",
          resval: 1,
          desc: "Determines in which escalation phase escalation signal 1 shall be asserted.",
        }
        { bits: "11:10",
          name: "MAP_E2",
          resval: 2,
          desc: "Determines in which escalation phase escalation signal 2 shall be asserted.",
        }
        { bits: "13:12",
          name: "MAP_E3",
          resval: 3,
          desc: "Determines in which escalation phase escalation signal 3 shall be asserted.",
        }
      ]
    },
    { name:     "CLASSC_REGWEN",
      desc:     '''
                Clear enable for escalation protocol of Class C alerts.
                '''
      swaccess: "rw0c",
      hwaccess: "hwo",
      fields: [
      {   bits:   "0",
          desc:   '''Register defaults to true, can only be cleared. This register is set
          to false by the hardware if the escalation protocol has been triggered and the bit
          !!CLASSC_CTRL.LOCK is true.
          ''',
          resval: 1,
        }
      ],
      tags: [// The value of this register is set to false only by hardware,
             // under the condition that escalation is triggered and the corresponding lock bit is true
             // Cannot not be auto-predicted so it is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSC_CLR",
      desc:     '''
                Clear for esclation protocol of Class C.
                '''
      swaccess: "wo",
      hwaccess: "hro",
      hwqe:     "true",
      regwen:   "CLASSC_REGWEN",
      fields: [
        { bits: "0",
          desc: '''Writing to this register clears the accumulator and aborts escalation
          (if it has been triggered). This clear is disabled if !!CLASSC_REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSC_ACCUM_CNT",
      desc:     '''
                Current accumulation value for alert Class C. Software can clear this register
                with a write to !!CLASSC_CLR register unless !!CLASSC_REGWEN is false.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "15:0" }
      ],
      tags: [// The value of this register is determined by how many alerts have been triggered
             // Cannot be auto-predicted so it is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSC_ACCUM_THRESH",
      desc:     '''
                Accumulation threshold value for alert Class C.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "15:0",
          desc: '''Once the accumulation value register is equal to the threshold escalation will
          be triggered on the next alert occurrence within this class C begins. Note that this
          register can not be modified if !!REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSC_TIMEOUT_CYC",
      desc:     '''
                Interrupt timeout in cycles.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0",
          desc: '''If the interrupt corresponding to this class is not
          handled within the specified amount of cycles, escalation will be triggered.
          Set to a positive value to enable the interrupt timeout for Class C. The timeout is set to zero
          by default, which disables this feature. Note that this register can not be modified if
          !!REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSC_PHASE0_CYC",
      desc:     '''
                Duration of escalation phase 0 for Class C.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSC_PHASE1_CYC",
      desc:     '''
                Duration of escalation phase 1 for Class C.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSC_PHASE2_CYC",
      desc:     '''
                Duration of escalation phase 2 for Class C.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSC_PHASE3_CYC",
      desc:     '''
                Duration of escalation phase 3 for Class C.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSC_ESC_CNT",
      desc:     '''
                Escalation counter in cycles for Class C.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "31:0",
          desc: '''Returns the current timeout or escalation count (depending on !!CLASSC_STATE).
          This register can not be directly cleared. However, SW can indirectly clear as follows.

          If the class is in the Timeout state, the timeout can be aborted by clearing the
          corresponding interrupt bit.

          If this class is in any of the escalation phases (e.g. Phase0), escalation protocol can be
          aborted by writing to !!CLASSC_CLR. Note however that has no effect if !!CLASSC_REGWEN
          is set to false (either by SW or by HW via the !!CLASSC_CTRL.LOCK feature).
          '''
        }
      ],
      tags: [// The value of this register is determined by counting how many cycles the escalation phase has lasted
             // Cannot be auto-predicted so excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSC_STATE",
      desc:     '''
                Current escalation state of Class C. See also !!CLASSC_ESC_CNT.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "2:0",
          enum: [
                  { value: "0b000", name: "Idle",     desc: "No timeout or escalation triggered." },
                  { value: "0b001", name: "Timeout",  desc: "IRQ timeout counter is active." },
                  { value: "0b011", name: "Terminal", desc: "Terminal state after escalation protocol." },
                  { value: "0b100", name: "Phase0",   desc: "Escalation Phase0 is active." },
                  { value: "0b101", name: "Phase1",   desc: "Escalation Phase1 is active." },
                  { value: "0b110", name: "Phase2",   desc: "Escalation Phase2 is active." },
                  { value: "0b111", name: "Phase3",   desc: "Escalation Phase3 is active." }
                ]
        }
      ],
      tags: [// The current escalation state cannot be auto-predicted
             // so this register is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },

    { name:     "CLASSD_CTRL",
      desc:     "Escalation control register for alert Class D. Can not be modified if !!REGWEN is false."
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "0",
          name: "EN",
          desc: '''
                Enable escalation mechanisms (accumulation and
                interrupt timeout) for Class D. Note that interrupts can fire
                regardless of whether the escalation mechanisms are enabled for
                this class or not.
                ''',
        }
        { bits: "1",
          name: "LOCK",
          desc: '''
                Enable automatic locking of escalation counter for class D.
                If true, there is no way to stop the escalation protocol for class D
                once it has been triggered.
                '''
        }
        { bits: "2",
          name: "EN_E0",
          resval: 1,
          desc: "Enable escalation signal 0 for Class D",
        }
        { bits: "3",
          name: "EN_E1",
          resval: 1,
          desc: "Enable escalation signal 1 for Class D",
        }
        { bits: "4",
          name: "EN_E2",
          resval: 1,
          desc: "Enable escalation signal 2 for Class D",
        }
        { bits: "5",
          name: "EN_E3",
          resval: 1,
          desc: "Enable escalation signal 3 for Class D",
        }
        # TODO: bitwidth should be parameterized with PHASE_DW
        { bits: "7:6",
          name: "MAP_E0",
          resval: 0,
          desc: "Determines in which escalation phase escalation signal 0 shall be asserted.",
        }
        { bits: "9:8",
          name: "MAP_E1",
          resval: 1,
          desc: "Determines in which escalation phase escalation signal 1 shall be asserted.",
        }
        { bits: "11:10",
          name: "MAP_E2",
          resval: 2,
          desc: "Determines in which escalation phase escalation signal 2 shall be asserted.",
        }
        { bits: "13:12",
          name: "MAP_E3",
          resval: 3,
          desc: "Determines in which escalation phase escalation signal 3 shall be asserted.",
        }
      ]
    },
    { name:     "CLASSD_REGWEN",
      desc:     '''
                Clear enable for escalation protocol of Class D alerts.
                '''
      swaccess: "rw0c",
      hwaccess: "hwo",
      fields: [
      {   bits:   "0",
          desc:   '''Register defaults to true, can only be cleared. This register is set
          to false by the hardware if the escalation protocol has been triggered and the bit
          !!CLASSD_CTRL.LOCK is true.
          ''',
          resval: 1,
        }
      ],
      tags: [// The value of this register is set to false only by hardware,
             // under the condition that escalation is triggered and the corresponding lock bit is true
             // Cannot not be auto-predicted so it is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSD_CLR",
      desc:     '''
                Clear for esclation protocol of Class D.
                '''
      swaccess: "wo",
      hwaccess: "hro",
      hwqe:     "true",
      regwen:   "CLASSD_REGWEN",
      fields: [
        { bits: "0",
          desc: '''Writing to this register clears the accumulator and aborts escalation
          (if it has been triggered). This clear is disabled if !!CLASSD_REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSD_ACCUM_CNT",
      desc:     '''
                Current accumulation value for alert Class D. Software can clear this register
                with a write to !!CLASSD_CLR register unless !!CLASSD_REGWEN is false.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "15:0" }
      ],
      tags: [// The value of this register is determined by how many alerts have been triggered
             // Cannot be auto-predicted so it is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSD_ACCUM_THRESH",
      desc:     '''
                Accumulation threshold value for alert Class D.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "15:0",
          desc: '''Once the accumulation value register is equal to the threshold escalation will
          be triggered on the next alert occurrence within this class D begins. Note that this
          register can not be modified if !!REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSD_TIMEOUT_CYC",
      desc:     '''
                Interrupt timeout in cycles.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0",
          desc: '''If the interrupt corresponding to this class is not
          handled within the specified amount of cycles, escalation will be triggered.
          Set to a positive value to enable the interrupt timeout for Class D. The timeout is set to zero
          by default, which disables this feature. Note that this register can not be modified if
          !!REGWEN is false.
          '''
        }
      ]
    },
    { name:     "CLASSD_PHASE0_CYC",
      desc:     '''
                Duration of escalation phase 0 for Class D.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSD_PHASE1_CYC",
      desc:     '''
                Duration of escalation phase 1 for Class D.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSD_PHASE2_CYC",
      desc:     '''
                Duration of escalation phase 2 for Class D.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSD_PHASE3_CYC",
      desc:     '''
                Duration of escalation phase 3 for Class D.
                '''
      swaccess: "rw",
      hwaccess: "hro",
      regwen:   "REGWEN",
      fields: [
        { bits: "31:0" ,
          desc: '''Escalation phase duration in cycles. Note that this register can not be
          modified if !!REGWEN is false.'''
        }
      ]
    }
    { name:     "CLASSD_ESC_CNT",
      desc:     '''
                Escalation counter in cycles for Class D.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "31:0",
          desc: '''Returns the current timeout or escalation count (depending on !!CLASSD_STATE).
          This register can not be directly cleared. However, SW can indirectly clear as follows.

          If the class is in the Timeout state, the timeout can be aborted by clearing the
          corresponding interrupt bit.

          If this class is in any of the escalation phases (e.g. Phase0), escalation protocol can be
          aborted by writing to !!CLASSD_CLR. Note however that has no effect if !!CLASSD_REGWEN
          is set to false (either by SW or by HW via the !!CLASSD_CTRL.LOCK feature).
          '''
        }
      ],
      tags: [// The value of this register is determined by counting how many cycles the escalation phase has lasted
             // Cannot be auto-predicted so excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
    { name:     "CLASSD_STATE",
      desc:     '''
                Current escalation state of Class D. See also !!CLASSD_ESC_CNT.
                '''
      swaccess: "ro",
      hwaccess: "hwo",
      hwext:    "true",
      fields: [
        { bits: "2:0",
          enum: [
                  { value: "0b000", name: "Idle",     desc: "No timeout or escalation triggered." },
                  { value: "0b001", name: "Timeout",  desc: "IRQ timeout counter is active." },
                  { value: "0b011", name: "Terminal", desc: "Terminal state after escalation protocol." },
                  { value: "0b100", name: "Phase0",   desc: "Escalation Phase0 is active." },
                  { value: "0b101", name: "Phase1",   desc: "Escalation Phase1 is active." },
                  { value: "0b110", name: "Phase2",   desc: "Escalation Phase2 is active." },
                  { value: "0b111", name: "Phase3",   desc: "Escalation Phase3 is active." }
                ]
        }
      ],
      tags: [// The current escalation state cannot be auto-predicted
             // so this register is excluded from read check
             "excl:CsrNonInitTests:CsrExclWriteCheck"]
    },
  ],
}
