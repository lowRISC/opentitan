// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// TOP Earlgrey configuration
{ name: "earlgrey",
  type: "top",

  datawidth: "32",  # 32-bit datawidth

  clocks: [
    { name: "main", freq: "100000000" }
  ]

  // Reset attributes
  // name: name of reset. Real name is `name`_rst_n
  // type: reset type, either root or leaf
  // root: if reset type not root, the root reset it is related to
  // clk:  related clock domain for synchronous release
  resets: [
    { name: "lc", type: "root", clk: "main"}
    { name: "sys", type: "root", clk: "main"}
    { name: "spi_device", type: "leaf", root: "sys", clk: "main"}
  ]

  // Number of cores: used in rv_plic and timer
  num_cores: "1",

  // `module` defines the peripherals.
  // Details are coming from each modules' config file `ip.hjson`
  // TODO: Define parameter here
  module: [
    { name: "uart",     // instance name
      type: "uart",     // Must be matched to the ip name in `ip.hson` (_reg, _cfg permitted)
                        // and `hw/ip/{type}`

      // clock_connections is the top level structure that specifies how clocks are connected
      // to each peripheral. For each peripheral clock port, there is a
      // clk_port : top_level_clk_net pairing.
      // The clk_port is defined in ip.hjson using two variables:
      // clock_primary - the primary clock for the perpheral
      // other_clock_list - secondary clocks for the peripheral
      // The primary clock port is important as it indicates which clock
      // drives the ip TLUL interface
      clock_connections: {clk_i: "main"},

      reset: "sys",     // reset is the top level net that connects to the IP
                        // The ip.hjson will declare the reset port names, these will then
                        // be hooked up at the top level.
                        // If nothing is declared at the ip.hjson level, a default name of
                        // `rst_ni` is assumed
      base_addr: "0x40000000",
    },
    { name: "gpio",
      type: "gpio",
      clock_connections: {clk_i: "main"},
      reset: "sys",
      base_addr: "0x40010000",
    }

    { name: "spi_device",
      type: "spi_device",
      clock_connections: {clk_i: "main"},
      base_addr: "0x40020000",
    },
    { name: "flash_ctrl",
      type: "flash_ctrl",
      clock_connections: {clk_i: "main"},
      reset: "lc",
      base_addr: "0x40030000",
    },
    { name: "rv_timer",
      type: "rv_timer",
      clock_connections: {clk_i: "main"},
      reset: "sys",
      base_addr: "0x40080000",
    },
    { name: "hmac",
      type: "hmac",
      clock_connections: {clk_i: "main"},
      reset: "sys",
      base_addr: "0x40120000",
    },
    { name: "rv_plic",
      type: "rv_plic",
      clock_connections: {clk_i: "main"},
      reset: "sys",
      base_addr: "0x40090000",
      generated: "true"         // Indicate this module is generated in the topgen
      parameter: {
        // FIND_MAX determines the algorithm for searching highest priority interrupt.
        // Available: { SEQUENTIAL, MATRIX }
        FIND_MAX: "MATRIX",     // Parameter as key
      }
    }
  ]

  // Memories (ROM, RAM, eFlash) are defined at the top.
  // It utilizes the primitive cells but configurable
  memory: [
    { name: "rom",      clock_connections: {clk_i: "main"}, reset: "sys", type: "rom",    base_addr: "0x00008000", size: "0x2000"  },
    { name: "ram_main", clock_connections: {clk_i: "main"}, reset: "sys", type: "ram_1p", base_addr: "0x10000000", size: "0x10000" },
    { name: "eflash",   clock_connections: {clk_i: "main"}, reset: "lc",  type: "eflash", base_addr: "0x20000000", size: "0x80000" },
  ],

  debug_mem_base_addr: "0x1A110000",

  // Crossbars: having a top level crossbar
  // This version assumes all crossbars are instantiated at the top.
  // Assume xbar.hjson is located in the same directory of top.hjson
  xbar: [
    { name: "main",
      clock_connections: {clk_main_i: "main"},
      reset: "sys",
    },
  ],

  // ===== INTERRUPT CTRL =====================================================
  // `rv_plic`  will be instantiate (need to be defined in `module` field
  // If interrupt is not defined, it uses the order from the module list
  // and include every modules.
  // first item goes to LSB of the interrupt source
  interrupt_module: ["gpio", "uart", "spi_device", "flash_ctrl", "hmac" ]

  // RV_PLIC has two searching algorithm internally to pick the most highest priority interrupt
  // source. "sequential" is smaller but slower, "matrix" is larger but faster.
  // Choose depends on the criteria. Currently it is set to "matrix" to meet FPGA timing @ 50MHz

  // generated:
  interrupt: [
  ]

  // TODO: ALERT HANDLER

  // TODO: PINMUX

}
