// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// UVM Registers auto-generated by `reggen` containing data structure
// Do Not Edit directly

// Forward declare all register/memory/block classes
typedef class spi_device_reg_intr_state;
typedef class spi_device_reg_intr_enable;
typedef class spi_device_reg_intr_test;
typedef class spi_device_reg_control;
typedef class spi_device_reg_cfg;
typedef class spi_device_reg_fifo_level;
typedef class spi_device_reg_async_fifo_level;
typedef class spi_device_reg_status;
typedef class spi_device_reg_rxf_ptr;
typedef class spi_device_reg_txf_ptr;
typedef class spi_device_reg_rxf_addr;
typedef class spi_device_reg_txf_addr;
typedef class spi_device_mem_buffer;
typedef class spi_device_reg_block;

typedef class flash_ctrl_reg_intr_state;
typedef class flash_ctrl_reg_intr_enable;
typedef class flash_ctrl_reg_intr_test;
typedef class flash_ctrl_reg_control;
typedef class flash_ctrl_reg_addr;
typedef class flash_ctrl_reg_region_cfg_regwen;
typedef class flash_ctrl_reg_mp_region_cfg0;
typedef class flash_ctrl_reg_mp_region_cfg1;
typedef class flash_ctrl_reg_mp_region_cfg2;
typedef class flash_ctrl_reg_mp_region_cfg3;
typedef class flash_ctrl_reg_mp_region_cfg4;
typedef class flash_ctrl_reg_mp_region_cfg5;
typedef class flash_ctrl_reg_mp_region_cfg6;
typedef class flash_ctrl_reg_mp_region_cfg7;
typedef class flash_ctrl_reg_default_region;
typedef class flash_ctrl_reg_bank_cfg_regwen;
typedef class flash_ctrl_reg_mp_bank_cfg;
typedef class flash_ctrl_reg_op_status;
typedef class flash_ctrl_reg_status;
typedef class flash_ctrl_reg_scratch;
typedef class flash_ctrl_reg_fifo_lvl;
typedef class flash_ctrl_mem_prog_fifo;
typedef class flash_ctrl_mem_rd_fifo;
typedef class flash_ctrl_reg_block;

typedef class rv_timer_reg_ctrl;
typedef class rv_timer_reg_cfg0;
typedef class rv_timer_reg_timer_v_lower0;
typedef class rv_timer_reg_timer_v_upper0;
typedef class rv_timer_reg_compare_lower0_0;
typedef class rv_timer_reg_compare_upper0_0;
typedef class rv_timer_reg_intr_enable0;
typedef class rv_timer_reg_intr_state0;
typedef class rv_timer_reg_intr_test0;
typedef class rv_timer_reg_block;

typedef class gpio_reg_intr_state;
typedef class gpio_reg_intr_enable;
typedef class gpio_reg_intr_test;
typedef class gpio_reg_data_in;
typedef class gpio_reg_direct_out;
typedef class gpio_reg_masked_out_lower;
typedef class gpio_reg_masked_out_upper;
typedef class gpio_reg_direct_oe;
typedef class gpio_reg_masked_oe_lower;
typedef class gpio_reg_masked_oe_upper;
typedef class gpio_reg_intr_ctrl_en_rising;
typedef class gpio_reg_intr_ctrl_en_falling;
typedef class gpio_reg_intr_ctrl_en_lvlhigh;
typedef class gpio_reg_intr_ctrl_en_lvllow;
typedef class gpio_reg_ctrl_en_input_filter;
typedef class gpio_reg_block;

typedef class hmac_reg_intr_state;
typedef class hmac_reg_intr_enable;
typedef class hmac_reg_intr_test;
typedef class hmac_reg_cfg;
typedef class hmac_reg_cmd;
typedef class hmac_reg_status;
typedef class hmac_reg_wipe_secret;
typedef class hmac_reg_key0;
typedef class hmac_reg_key1;
typedef class hmac_reg_key2;
typedef class hmac_reg_key3;
typedef class hmac_reg_key4;
typedef class hmac_reg_key5;
typedef class hmac_reg_key6;
typedef class hmac_reg_key7;
typedef class hmac_reg_digest0;
typedef class hmac_reg_digest1;
typedef class hmac_reg_digest2;
typedef class hmac_reg_digest3;
typedef class hmac_reg_digest4;
typedef class hmac_reg_digest5;
typedef class hmac_reg_digest6;
typedef class hmac_reg_digest7;
typedef class hmac_reg_msg_length_lower;
typedef class hmac_reg_msg_length_upper;
typedef class hmac_mem_msg_fifo;
typedef class hmac_reg_block;

typedef class uart_reg_intr_state;
typedef class uart_reg_intr_enable;
typedef class uart_reg_intr_test;
typedef class uart_reg_ctrl;
typedef class uart_reg_status;
typedef class uart_reg_rdata;
typedef class uart_reg_wdata;
typedef class uart_reg_fifo_ctrl;
typedef class uart_reg_fifo_status;
typedef class uart_reg_ovrd;
typedef class uart_reg_val;
typedef class uart_reg_timeout_ctrl;
typedef class uart_reg_block;

typedef class rv_plic_reg_ip0;
typedef class rv_plic_reg_ip1;
typedef class rv_plic_reg_le0;
typedef class rv_plic_reg_le1;
typedef class rv_plic_reg_prio0;
typedef class rv_plic_reg_prio1;
typedef class rv_plic_reg_prio2;
typedef class rv_plic_reg_prio3;
typedef class rv_plic_reg_prio4;
typedef class rv_plic_reg_prio5;
typedef class rv_plic_reg_prio6;
typedef class rv_plic_reg_prio7;
typedef class rv_plic_reg_prio8;
typedef class rv_plic_reg_prio9;
typedef class rv_plic_reg_prio10;
typedef class rv_plic_reg_prio11;
typedef class rv_plic_reg_prio12;
typedef class rv_plic_reg_prio13;
typedef class rv_plic_reg_prio14;
typedef class rv_plic_reg_prio15;
typedef class rv_plic_reg_prio16;
typedef class rv_plic_reg_prio17;
typedef class rv_plic_reg_prio18;
typedef class rv_plic_reg_prio19;
typedef class rv_plic_reg_prio20;
typedef class rv_plic_reg_prio21;
typedef class rv_plic_reg_prio22;
typedef class rv_plic_reg_prio23;
typedef class rv_plic_reg_prio24;
typedef class rv_plic_reg_prio25;
typedef class rv_plic_reg_prio26;
typedef class rv_plic_reg_prio27;
typedef class rv_plic_reg_prio28;
typedef class rv_plic_reg_prio29;
typedef class rv_plic_reg_prio30;
typedef class rv_plic_reg_prio31;
typedef class rv_plic_reg_prio32;
typedef class rv_plic_reg_prio33;
typedef class rv_plic_reg_prio34;
typedef class rv_plic_reg_prio35;
typedef class rv_plic_reg_prio36;
typedef class rv_plic_reg_prio37;
typedef class rv_plic_reg_prio38;
typedef class rv_plic_reg_prio39;
typedef class rv_plic_reg_prio40;
typedef class rv_plic_reg_prio41;
typedef class rv_plic_reg_prio42;
typedef class rv_plic_reg_prio43;
typedef class rv_plic_reg_prio44;
typedef class rv_plic_reg_prio45;
typedef class rv_plic_reg_prio46;
typedef class rv_plic_reg_prio47;
typedef class rv_plic_reg_prio48;
typedef class rv_plic_reg_prio49;
typedef class rv_plic_reg_prio50;
typedef class rv_plic_reg_prio51;
typedef class rv_plic_reg_prio52;
typedef class rv_plic_reg_prio53;
typedef class rv_plic_reg_ie00;
typedef class rv_plic_reg_ie01;
typedef class rv_plic_reg_threshold0;
typedef class rv_plic_reg_cc0;
typedef class rv_plic_reg_msip0;
typedef class rv_plic_reg_block;

typedef class chip_mem_rom;
typedef class chip_mem_ram_main;
typedef class chip_mem_eflash;
typedef class chip_reg_block;


// Block: spi_device
// Class: spi_device_reg_intr_state
class spi_device_reg_intr_state extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxf;
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txlvl;
  rand dv_base_reg_field rxerr;
  rand dv_base_reg_field rxoverflow;
  rand dv_base_reg_field txunderflow;

  `uvm_object_utils(spi_device_reg_intr_state)

  function new(string       name = "spi_device_reg_intr_state",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxf = dv_base_reg_field::type_id::create("rxf");
    rxf.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxerr = dv_base_reg_field::type_id::create("rxerr");
    rxerr.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxoverflow = dv_base_reg_field::type_id::create("rxoverflow");
    rxoverflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txunderflow = dv_base_reg_field::type_id::create("txunderflow");
    txunderflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_intr_state

// Class: spi_device_reg_intr_enable
class spi_device_reg_intr_enable extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxf;
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txlvl;
  rand dv_base_reg_field rxerr;
  rand dv_base_reg_field rxoverflow;
  rand dv_base_reg_field txunderflow;

  `uvm_object_utils(spi_device_reg_intr_enable)

  function new(string       name = "spi_device_reg_intr_enable",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxf = dv_base_reg_field::type_id::create("rxf");
    rxf.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxerr = dv_base_reg_field::type_id::create("rxerr");
    rxerr.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxoverflow = dv_base_reg_field::type_id::create("rxoverflow");
    rxoverflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txunderflow = dv_base_reg_field::type_id::create("txunderflow");
    txunderflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_intr_enable

// Class: spi_device_reg_intr_test
class spi_device_reg_intr_test extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxf;
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txlvl;
  rand dv_base_reg_field rxerr;
  rand dv_base_reg_field rxoverflow;
  rand dv_base_reg_field txunderflow;

  `uvm_object_utils(spi_device_reg_intr_test)

  function new(string       name = "spi_device_reg_intr_test",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxf = dv_base_reg_field::type_id::create("rxf");
    rxf.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxerr = dv_base_reg_field::type_id::create("rxerr");
    rxerr.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxoverflow = dv_base_reg_field::type_id::create("rxoverflow");
    rxoverflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txunderflow = dv_base_reg_field::type_id::create("txunderflow");
    txunderflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_intr_test

// Class: spi_device_reg_control
class spi_device_reg_control extends dv_base_reg;
  // fields
  rand dv_base_reg_field abort;
  rand dv_base_reg_field mode;
  rand dv_base_reg_field rst_txfifo;
  rand dv_base_reg_field rst_rxfifo;

  `uvm_object_utils(spi_device_reg_control)

  function new(string       name = "spi_device_reg_control",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    abort = dv_base_reg_field::type_id::create("abort");
    abort.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    mode = dv_base_reg_field::type_id::create("mode");
    mode.configure(
      .parent(this),
      .size(2),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rst_txfifo = dv_base_reg_field::type_id::create("rst_txfifo");
    rst_txfifo.configure(
      .parent(this),
      .size(1),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rst_rxfifo = dv_base_reg_field::type_id::create("rst_rxfifo");
    rst_rxfifo.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_control

// Class: spi_device_reg_cfg
class spi_device_reg_cfg extends dv_base_reg;
  // fields
  rand dv_base_reg_field cpol;
  rand dv_base_reg_field cpha;
  rand dv_base_reg_field tx_order;
  rand dv_base_reg_field rx_order;
  rand dv_base_reg_field timer_v;

  `uvm_object_utils(spi_device_reg_cfg)

  function new(string       name = "spi_device_reg_cfg",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    cpol = dv_base_reg_field::type_id::create("cpol");
    cpol.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    cpha = dv_base_reg_field::type_id::create("cpha");
    cpha.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    tx_order = dv_base_reg_field::type_id::create("tx_order");
    tx_order.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_order = dv_base_reg_field::type_id::create("rx_order");
    rx_order.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    timer_v = dv_base_reg_field::type_id::create("timer_v");
    timer_v.configure(
      .parent(this),
      .size(8),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(127),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_cfg

// Class: spi_device_reg_fifo_level
class spi_device_reg_fifo_level extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txlvl;

  `uvm_object_utils(spi_device_reg_fifo_level)

  function new(string       name = "spi_device_reg_fifo_level",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(128),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_fifo_level

// Class: spi_device_reg_async_fifo_level
class spi_device_reg_async_fifo_level extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxlvl;
  rand dv_base_reg_field txlvl;

  `uvm_object_utils(spi_device_reg_async_fifo_level)

  function new(string       name = "spi_device_reg_async_fifo_level",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(8),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(8),
      .lsb_pos(16),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_async_fifo_level

// Class: spi_device_reg_status
class spi_device_reg_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxf_full;
  rand dv_base_reg_field rxf_empty;
  rand dv_base_reg_field txf_full;
  rand dv_base_reg_field txf_empty;
  rand dv_base_reg_field abort_done;
  rand dv_base_reg_field csb;

  `uvm_object_utils(spi_device_reg_status)

  function new(string       name = "spi_device_reg_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxf_full = dv_base_reg_field::type_id::create("rxf_full");
    rxf_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxf_empty = dv_base_reg_field::type_id::create("rxf_empty");
    rxf_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txf_full = dv_base_reg_field::type_id::create("txf_full");
    txf_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txf_empty = dv_base_reg_field::type_id::create("txf_empty");
    txf_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    abort_done = dv_base_reg_field::type_id::create("abort_done");
    abort_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    csb = dv_base_reg_field::type_id::create("csb");
    csb.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_status

// Class: spi_device_reg_rxf_ptr
class spi_device_reg_rxf_ptr extends dv_base_reg;
  // fields
  rand dv_base_reg_field rptr;
  rand dv_base_reg_field wptr;

  `uvm_object_utils(spi_device_reg_rxf_ptr)

  function new(string       name = "spi_device_reg_rxf_ptr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rptr = dv_base_reg_field::type_id::create("rptr");
    rptr.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    wptr = dv_base_reg_field::type_id::create("wptr");
    wptr.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_rxf_ptr

// Class: spi_device_reg_txf_ptr
class spi_device_reg_txf_ptr extends dv_base_reg;
  // fields
  rand dv_base_reg_field rptr;
  rand dv_base_reg_field wptr;

  `uvm_object_utils(spi_device_reg_txf_ptr)

  function new(string       name = "spi_device_reg_txf_ptr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rptr = dv_base_reg_field::type_id::create("rptr");
    rptr.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    wptr = dv_base_reg_field::type_id::create("wptr");
    wptr.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_txf_ptr

// Class: spi_device_reg_rxf_addr
class spi_device_reg_rxf_addr extends dv_base_reg;
  // fields
  rand dv_base_reg_field base;
  rand dv_base_reg_field limit;

  `uvm_object_utils(spi_device_reg_rxf_addr)

  function new(string       name = "spi_device_reg_rxf_addr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    base = dv_base_reg_field::type_id::create("base");
    base.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    limit = dv_base_reg_field::type_id::create("limit");
    limit.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(508),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_rxf_addr

// Class: spi_device_reg_txf_addr
class spi_device_reg_txf_addr extends dv_base_reg;
  // fields
  rand dv_base_reg_field base;
  rand dv_base_reg_field limit;

  `uvm_object_utils(spi_device_reg_txf_addr)

  function new(string       name = "spi_device_reg_txf_addr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    base = dv_base_reg_field::type_id::create("base");
    base.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(512),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    limit = dv_base_reg_field::type_id::create("limit");
    limit.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(1020),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : spi_device_reg_txf_addr

// Class: spi_device_mem_buffer
class spi_device_mem_buffer extends dv_base_mem;

  `uvm_object_utils(spi_device_mem_buffer)

  function new(string           name = "spi_device_mem_buffer",
               longint unsigned size = 512,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"RW"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : spi_device_mem_buffer

// Class: spi_device_reg_block
class spi_device_reg_block extends dv_base_reg_block;
  // registers
  rand spi_device_reg_intr_state intr_state;
  rand spi_device_reg_intr_enable intr_enable;
  rand spi_device_reg_intr_test intr_test;
  rand spi_device_reg_control control;
  rand spi_device_reg_cfg cfg;
  rand spi_device_reg_fifo_level fifo_level;
  rand spi_device_reg_async_fifo_level async_fifo_level;
  rand spi_device_reg_status status;
  rand spi_device_reg_rxf_ptr rxf_ptr;
  rand spi_device_reg_txf_ptr txf_ptr;
  rand spi_device_reg_rxf_addr rxf_addr;
  rand spi_device_reg_txf_addr txf_addr;
  // memories
  rand spi_device_mem_buffer buffer;

  `uvm_object_utils(spi_device_reg_block)

  function new(string name = "spi_device_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    intr_state = spi_device_reg_intr_state::type_id::create("intr_state");
    intr_state.configure(.blk_parent(this));
    intr_state.build();
    default_map.add_reg(.rg(intr_state),
                        .offset(32'h0),
                        .rights("RW"));
    intr_enable = spi_device_reg_intr_enable::type_id::create("intr_enable");
    intr_enable.configure(.blk_parent(this));
    intr_enable.build();
    default_map.add_reg(.rg(intr_enable),
                        .offset(32'h4),
                        .rights("RW"));
    intr_test = spi_device_reg_intr_test::type_id::create("intr_test");
    intr_test.configure(.blk_parent(this));
    intr_test.build();
    default_map.add_reg(.rg(intr_test),
                        .offset(32'h8),
                        .rights("WO"));
    control = spi_device_reg_control::type_id::create("control");
    control.configure(.blk_parent(this));
    control.build();
    default_map.add_reg(.rg(control),
                        .offset(32'hc),
                        .rights("RW"));
    cfg = spi_device_reg_cfg::type_id::create("cfg");
    cfg.configure(.blk_parent(this));
    cfg.build();
    default_map.add_reg(.rg(cfg),
                        .offset(32'h10),
                        .rights("RW"));
    fifo_level = spi_device_reg_fifo_level::type_id::create("fifo_level");
    fifo_level.configure(.blk_parent(this));
    fifo_level.build();
    default_map.add_reg(.rg(fifo_level),
                        .offset(32'h14),
                        .rights("RW"));
    async_fifo_level = spi_device_reg_async_fifo_level::type_id::create("async_fifo_level");
    async_fifo_level.configure(.blk_parent(this));
    async_fifo_level.build();
    default_map.add_reg(.rg(async_fifo_level),
                        .offset(32'h18),
                        .rights("RO"));
    status = spi_device_reg_status::type_id::create("status");
    status.configure(.blk_parent(this));
    status.build();
    default_map.add_reg(.rg(status),
                        .offset(32'h1c),
                        .rights("RO"));
    rxf_ptr = spi_device_reg_rxf_ptr::type_id::create("rxf_ptr");
    rxf_ptr.configure(.blk_parent(this));
    rxf_ptr.build();
    default_map.add_reg(.rg(rxf_ptr),
                        .offset(32'h20),
                        .rights("RW"));
    txf_ptr = spi_device_reg_txf_ptr::type_id::create("txf_ptr");
    txf_ptr.configure(.blk_parent(this));
    txf_ptr.build();
    default_map.add_reg(.rg(txf_ptr),
                        .offset(32'h24),
                        .rights("RW"));
    rxf_addr = spi_device_reg_rxf_addr::type_id::create("rxf_addr");
    rxf_addr.configure(.blk_parent(this));
    rxf_addr.build();
    default_map.add_reg(.rg(rxf_addr),
                        .offset(32'h28),
                        .rights("RW"));
    txf_addr = spi_device_reg_txf_addr::type_id::create("txf_addr");
    txf_addr.configure(.blk_parent(this));
    txf_addr.build();
    default_map.add_reg(.rg(txf_addr),
                        .offset(32'h2c),
                        .rights("RW"));

    // create memories
    buffer = spi_device_mem_buffer::type_id::create("buffer");
    buffer.configure(.parent(this));
    default_map.add_mem(.mem(buffer),
                        .offset(32'h800),
                        .rights("RW"));
  endfunction : build

endclass : spi_device_reg_block

// Block: flash_ctrl
// Class: flash_ctrl_reg_intr_state
class flash_ctrl_reg_intr_state extends dv_base_reg;
  // fields
  rand dv_base_reg_field prog_empty;
  rand dv_base_reg_field prog_lvl;
  rand dv_base_reg_field rd_full;
  rand dv_base_reg_field rd_lvl;
  rand dv_base_reg_field op_done;
  rand dv_base_reg_field op_error;

  `uvm_object_utils(flash_ctrl_reg_intr_state)

  function new(string       name = "flash_ctrl_reg_intr_state",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prog_empty = dv_base_reg_field::type_id::create("prog_empty");
    prog_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_lvl = dv_base_reg_field::type_id::create("prog_lvl");
    prog_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_full = dv_base_reg_field::type_id::create("rd_full");
    rd_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_lvl = dv_base_reg_field::type_id::create("rd_lvl");
    rd_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_done = dv_base_reg_field::type_id::create("op_done");
    op_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_error = dv_base_reg_field::type_id::create("op_error");
    op_error.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_intr_state

// Class: flash_ctrl_reg_intr_enable
class flash_ctrl_reg_intr_enable extends dv_base_reg;
  // fields
  rand dv_base_reg_field prog_empty;
  rand dv_base_reg_field prog_lvl;
  rand dv_base_reg_field rd_full;
  rand dv_base_reg_field rd_lvl;
  rand dv_base_reg_field op_done;
  rand dv_base_reg_field op_error;

  `uvm_object_utils(flash_ctrl_reg_intr_enable)

  function new(string       name = "flash_ctrl_reg_intr_enable",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prog_empty = dv_base_reg_field::type_id::create("prog_empty");
    prog_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_lvl = dv_base_reg_field::type_id::create("prog_lvl");
    prog_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_full = dv_base_reg_field::type_id::create("rd_full");
    rd_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_lvl = dv_base_reg_field::type_id::create("rd_lvl");
    rd_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_done = dv_base_reg_field::type_id::create("op_done");
    op_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_error = dv_base_reg_field::type_id::create("op_error");
    op_error.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_intr_enable

// Class: flash_ctrl_reg_intr_test
class flash_ctrl_reg_intr_test extends dv_base_reg;
  // fields
  rand dv_base_reg_field prog_empty;
  rand dv_base_reg_field prog_lvl;
  rand dv_base_reg_field rd_full;
  rand dv_base_reg_field rd_lvl;
  rand dv_base_reg_field op_done;
  rand dv_base_reg_field op_error;

  `uvm_object_utils(flash_ctrl_reg_intr_test)

  function new(string       name = "flash_ctrl_reg_intr_test",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prog_empty = dv_base_reg_field::type_id::create("prog_empty");
    prog_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_lvl = dv_base_reg_field::type_id::create("prog_lvl");
    prog_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_full = dv_base_reg_field::type_id::create("rd_full");
    rd_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_lvl = dv_base_reg_field::type_id::create("rd_lvl");
    rd_lvl.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_done = dv_base_reg_field::type_id::create("op_done");
    op_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op_error = dv_base_reg_field::type_id::create("op_error");
    op_error.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_intr_test

// Class: flash_ctrl_reg_control
class flash_ctrl_reg_control extends dv_base_reg;
  // fields
  rand dv_base_reg_field start;
  rand dv_base_reg_field op;
  rand dv_base_reg_field erase_sel;
  rand dv_base_reg_field fifo_rst;
  rand dv_base_reg_field num;

  `uvm_object_utils(flash_ctrl_reg_control)

  function new(string       name = "flash_ctrl_reg_control",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    start = dv_base_reg_field::type_id::create("start");
    start.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    op = dv_base_reg_field::type_id::create("op");
    op.configure(
      .parent(this),
      .size(2),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_sel = dv_base_reg_field::type_id::create("erase_sel");
    erase_sel.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    fifo_rst = dv_base_reg_field::type_id::create("fifo_rst");
    fifo_rst.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    num = dv_base_reg_field::type_id::create("num");
    num.configure(
      .parent(this),
      .size(12),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_control

// Class: flash_ctrl_reg_addr
class flash_ctrl_reg_addr extends dv_base_reg;
  // fields
  rand dv_base_reg_field start;

  `uvm_object_utils(flash_ctrl_reg_addr)

  function new(string       name = "flash_ctrl_reg_addr",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    start = dv_base_reg_field::type_id::create("start");
    start.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_addr

// Class: flash_ctrl_reg_region_cfg_regwen
class flash_ctrl_reg_region_cfg_regwen extends dv_base_reg;
  // fields
  rand dv_base_reg_field region0;
  rand dv_base_reg_field region1;
  rand dv_base_reg_field region2;
  rand dv_base_reg_field region3;
  rand dv_base_reg_field region4;
  rand dv_base_reg_field region5;
  rand dv_base_reg_field region6;
  rand dv_base_reg_field region7;

  `uvm_object_utils(flash_ctrl_reg_region_cfg_regwen)

  function new(string       name = "flash_ctrl_reg_region_cfg_regwen",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    region0 = dv_base_reg_field::type_id::create("region0");
    region0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region1 = dv_base_reg_field::type_id::create("region1");
    region1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region2 = dv_base_reg_field::type_id::create("region2");
    region2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region3 = dv_base_reg_field::type_id::create("region3");
    region3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region4 = dv_base_reg_field::type_id::create("region4");
    region4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region5 = dv_base_reg_field::type_id::create("region5");
    region5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region6 = dv_base_reg_field::type_id::create("region6");
    region6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    region7 = dv_base_reg_field::type_id::create("region7");
    region7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_region_cfg_regwen

// Class: flash_ctrl_reg_mp_region_cfg0
class flash_ctrl_reg_mp_region_cfg0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en0;
  rand dv_base_reg_field rd_en0;
  rand dv_base_reg_field prog_en0;
  rand dv_base_reg_field erase_en0;
  rand dv_base_reg_field base0;
  rand dv_base_reg_field size0;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg0)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en0 = dv_base_reg_field::type_id::create("en0");
    en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en0 = dv_base_reg_field::type_id::create("rd_en0");
    rd_en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en0 = dv_base_reg_field::type_id::create("prog_en0");
    prog_en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en0 = dv_base_reg_field::type_id::create("erase_en0");
    erase_en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base0 = dv_base_reg_field::type_id::create("base0");
    base0.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size0 = dv_base_reg_field::type_id::create("size0");
    size0.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg0

// Class: flash_ctrl_reg_mp_region_cfg1
class flash_ctrl_reg_mp_region_cfg1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en1;
  rand dv_base_reg_field rd_en1;
  rand dv_base_reg_field prog_en1;
  rand dv_base_reg_field erase_en1;
  rand dv_base_reg_field base1;
  rand dv_base_reg_field size1;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg1)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en1 = dv_base_reg_field::type_id::create("en1");
    en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en1 = dv_base_reg_field::type_id::create("rd_en1");
    rd_en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en1 = dv_base_reg_field::type_id::create("prog_en1");
    prog_en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en1 = dv_base_reg_field::type_id::create("erase_en1");
    erase_en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base1 = dv_base_reg_field::type_id::create("base1");
    base1.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size1 = dv_base_reg_field::type_id::create("size1");
    size1.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg1

// Class: flash_ctrl_reg_mp_region_cfg2
class flash_ctrl_reg_mp_region_cfg2 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en2;
  rand dv_base_reg_field rd_en2;
  rand dv_base_reg_field prog_en2;
  rand dv_base_reg_field erase_en2;
  rand dv_base_reg_field base2;
  rand dv_base_reg_field size2;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg2)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg2",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en2 = dv_base_reg_field::type_id::create("en2");
    en2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en2 = dv_base_reg_field::type_id::create("rd_en2");
    rd_en2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en2 = dv_base_reg_field::type_id::create("prog_en2");
    prog_en2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en2 = dv_base_reg_field::type_id::create("erase_en2");
    erase_en2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base2 = dv_base_reg_field::type_id::create("base2");
    base2.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size2 = dv_base_reg_field::type_id::create("size2");
    size2.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg2

// Class: flash_ctrl_reg_mp_region_cfg3
class flash_ctrl_reg_mp_region_cfg3 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en3;
  rand dv_base_reg_field rd_en3;
  rand dv_base_reg_field prog_en3;
  rand dv_base_reg_field erase_en3;
  rand dv_base_reg_field base3;
  rand dv_base_reg_field size3;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg3)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg3",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en3 = dv_base_reg_field::type_id::create("en3");
    en3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en3 = dv_base_reg_field::type_id::create("rd_en3");
    rd_en3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en3 = dv_base_reg_field::type_id::create("prog_en3");
    prog_en3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en3 = dv_base_reg_field::type_id::create("erase_en3");
    erase_en3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base3 = dv_base_reg_field::type_id::create("base3");
    base3.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size3 = dv_base_reg_field::type_id::create("size3");
    size3.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg3

// Class: flash_ctrl_reg_mp_region_cfg4
class flash_ctrl_reg_mp_region_cfg4 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en4;
  rand dv_base_reg_field rd_en4;
  rand dv_base_reg_field prog_en4;
  rand dv_base_reg_field erase_en4;
  rand dv_base_reg_field base4;
  rand dv_base_reg_field size4;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg4)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg4",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en4 = dv_base_reg_field::type_id::create("en4");
    en4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en4 = dv_base_reg_field::type_id::create("rd_en4");
    rd_en4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en4 = dv_base_reg_field::type_id::create("prog_en4");
    prog_en4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en4 = dv_base_reg_field::type_id::create("erase_en4");
    erase_en4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base4 = dv_base_reg_field::type_id::create("base4");
    base4.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size4 = dv_base_reg_field::type_id::create("size4");
    size4.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg4

// Class: flash_ctrl_reg_mp_region_cfg5
class flash_ctrl_reg_mp_region_cfg5 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en5;
  rand dv_base_reg_field rd_en5;
  rand dv_base_reg_field prog_en5;
  rand dv_base_reg_field erase_en5;
  rand dv_base_reg_field base5;
  rand dv_base_reg_field size5;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg5)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg5",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en5 = dv_base_reg_field::type_id::create("en5");
    en5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en5 = dv_base_reg_field::type_id::create("rd_en5");
    rd_en5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en5 = dv_base_reg_field::type_id::create("prog_en5");
    prog_en5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en5 = dv_base_reg_field::type_id::create("erase_en5");
    erase_en5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base5 = dv_base_reg_field::type_id::create("base5");
    base5.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size5 = dv_base_reg_field::type_id::create("size5");
    size5.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg5

// Class: flash_ctrl_reg_mp_region_cfg6
class flash_ctrl_reg_mp_region_cfg6 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en6;
  rand dv_base_reg_field rd_en6;
  rand dv_base_reg_field prog_en6;
  rand dv_base_reg_field erase_en6;
  rand dv_base_reg_field base6;
  rand dv_base_reg_field size6;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg6)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg6",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en6 = dv_base_reg_field::type_id::create("en6");
    en6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en6 = dv_base_reg_field::type_id::create("rd_en6");
    rd_en6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en6 = dv_base_reg_field::type_id::create("prog_en6");
    prog_en6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en6 = dv_base_reg_field::type_id::create("erase_en6");
    erase_en6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base6 = dv_base_reg_field::type_id::create("base6");
    base6.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size6 = dv_base_reg_field::type_id::create("size6");
    size6.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg6

// Class: flash_ctrl_reg_mp_region_cfg7
class flash_ctrl_reg_mp_region_cfg7 extends dv_base_reg;
  // fields
  rand dv_base_reg_field en7;
  rand dv_base_reg_field rd_en7;
  rand dv_base_reg_field prog_en7;
  rand dv_base_reg_field erase_en7;
  rand dv_base_reg_field base7;
  rand dv_base_reg_field size7;

  `uvm_object_utils(flash_ctrl_reg_mp_region_cfg7)

  function new(string       name = "flash_ctrl_reg_mp_region_cfg7",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    en7 = dv_base_reg_field::type_id::create("en7");
    en7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_en7 = dv_base_reg_field::type_id::create("rd_en7");
    rd_en7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en7 = dv_base_reg_field::type_id::create("prog_en7");
    prog_en7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en7 = dv_base_reg_field::type_id::create("erase_en7");
    erase_en7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    base7 = dv_base_reg_field::type_id::create("base7");
    base7.configure(
      .parent(this),
      .size(9),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    size7 = dv_base_reg_field::type_id::create("size7");
    size7.configure(
      .parent(this),
      .size(9),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_region_cfg7

// Class: flash_ctrl_reg_default_region
class flash_ctrl_reg_default_region extends dv_base_reg;
  // fields
  rand dv_base_reg_field rd_en;
  rand dv_base_reg_field prog_en;
  rand dv_base_reg_field erase_en;

  `uvm_object_utils(flash_ctrl_reg_default_region)

  function new(string       name = "flash_ctrl_reg_default_region",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rd_en = dv_base_reg_field::type_id::create("rd_en");
    rd_en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_en = dv_base_reg_field::type_id::create("prog_en");
    prog_en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en = dv_base_reg_field::type_id::create("erase_en");
    erase_en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_default_region

// Class: flash_ctrl_reg_bank_cfg_regwen
class flash_ctrl_reg_bank_cfg_regwen extends dv_base_reg;
  // fields
  rand dv_base_reg_field bank;

  `uvm_object_utils(flash_ctrl_reg_bank_cfg_regwen)

  function new(string       name = "flash_ctrl_reg_bank_cfg_regwen",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    bank = dv_base_reg_field::type_id::create("bank");
    bank.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W0C"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_bank_cfg_regwen

// Class: flash_ctrl_reg_mp_bank_cfg
class flash_ctrl_reg_mp_bank_cfg extends dv_base_reg;
  // fields
  rand dv_base_reg_field erase_en0;
  rand dv_base_reg_field erase_en1;

  `uvm_object_utils(flash_ctrl_reg_mp_bank_cfg)

  function new(string       name = "flash_ctrl_reg_mp_bank_cfg",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    erase_en0 = dv_base_reg_field::type_id::create("erase_en0");
    erase_en0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    erase_en1 = dv_base_reg_field::type_id::create("erase_en1");
    erase_en1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_mp_bank_cfg

// Class: flash_ctrl_reg_op_status
class flash_ctrl_reg_op_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field done;
  rand dv_base_reg_field err;

  `uvm_object_utils(flash_ctrl_reg_op_status)

  function new(string       name = "flash_ctrl_reg_op_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    done = dv_base_reg_field::type_id::create("done");
    done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    err = dv_base_reg_field::type_id::create("err");
    err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_op_status

// Class: flash_ctrl_reg_status
class flash_ctrl_reg_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field rd_full;
  rand dv_base_reg_field rd_empty;
  rand dv_base_reg_field prog_full;
  rand dv_base_reg_field prog_empty;
  rand dv_base_reg_field init_wip;
  rand dv_base_reg_field error_page;
  rand dv_base_reg_field error_bank;

  `uvm_object_utils(flash_ctrl_reg_status)

  function new(string       name = "flash_ctrl_reg_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rd_full = dv_base_reg_field::type_id::create("rd_full");
    rd_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd_empty = dv_base_reg_field::type_id::create("rd_empty");
    rd_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_full = dv_base_reg_field::type_id::create("prog_full");
    prog_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    prog_empty = dv_base_reg_field::type_id::create("prog_empty");
    prog_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    init_wip = dv_base_reg_field::type_id::create("init_wip");
    init_wip.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    error_page = dv_base_reg_field::type_id::create("error_page");
    error_page.configure(
      .parent(this),
      .size(9),
      .lsb_pos(8),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    error_bank = dv_base_reg_field::type_id::create("error_bank");
    error_bank.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_status

// Class: flash_ctrl_reg_scratch
class flash_ctrl_reg_scratch extends dv_base_reg;
  // fields
  rand dv_base_reg_field data;

  `uvm_object_utils(flash_ctrl_reg_scratch)

  function new(string       name = "flash_ctrl_reg_scratch",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data = dv_base_reg_field::type_id::create("data");
    data.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_scratch

// Class: flash_ctrl_reg_fifo_lvl
class flash_ctrl_reg_fifo_lvl extends dv_base_reg;
  // fields
  rand dv_base_reg_field prog;
  rand dv_base_reg_field rd;

  `uvm_object_utils(flash_ctrl_reg_fifo_lvl)

  function new(string       name = "flash_ctrl_reg_fifo_lvl",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prog = dv_base_reg_field::type_id::create("prog");
    prog.configure(
      .parent(this),
      .size(5),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(15),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rd = dv_base_reg_field::type_id::create("rd");
    rd.configure(
      .parent(this),
      .size(5),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(15),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : flash_ctrl_reg_fifo_lvl

// Class: flash_ctrl_mem_prog_fifo
class flash_ctrl_mem_prog_fifo extends dv_base_mem;

  `uvm_object_utils(flash_ctrl_mem_prog_fifo)

  function new(string           name = "flash_ctrl_mem_prog_fifo",
               longint unsigned size = 1,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"WO"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : flash_ctrl_mem_prog_fifo

// Class: flash_ctrl_mem_rd_fifo
class flash_ctrl_mem_rd_fifo extends dv_base_mem;

  `uvm_object_utils(flash_ctrl_mem_rd_fifo)

  function new(string           name = "flash_ctrl_mem_rd_fifo",
               longint unsigned size = 1,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"RO"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : flash_ctrl_mem_rd_fifo

// Class: flash_ctrl_reg_block
class flash_ctrl_reg_block extends dv_base_reg_block;
  // registers
  rand flash_ctrl_reg_intr_state intr_state;
  rand flash_ctrl_reg_intr_enable intr_enable;
  rand flash_ctrl_reg_intr_test intr_test;
  rand flash_ctrl_reg_control control;
  rand flash_ctrl_reg_addr addr;
  rand flash_ctrl_reg_region_cfg_regwen region_cfg_regwen;
  rand flash_ctrl_reg_mp_region_cfg0 mp_region_cfg0;
  rand flash_ctrl_reg_mp_region_cfg1 mp_region_cfg1;
  rand flash_ctrl_reg_mp_region_cfg2 mp_region_cfg2;
  rand flash_ctrl_reg_mp_region_cfg3 mp_region_cfg3;
  rand flash_ctrl_reg_mp_region_cfg4 mp_region_cfg4;
  rand flash_ctrl_reg_mp_region_cfg5 mp_region_cfg5;
  rand flash_ctrl_reg_mp_region_cfg6 mp_region_cfg6;
  rand flash_ctrl_reg_mp_region_cfg7 mp_region_cfg7;
  rand flash_ctrl_reg_default_region default_region;
  rand flash_ctrl_reg_bank_cfg_regwen bank_cfg_regwen;
  rand flash_ctrl_reg_mp_bank_cfg mp_bank_cfg;
  rand flash_ctrl_reg_op_status op_status;
  rand flash_ctrl_reg_status status;
  rand flash_ctrl_reg_scratch scratch;
  rand flash_ctrl_reg_fifo_lvl fifo_lvl;
  // memories
  rand flash_ctrl_mem_prog_fifo prog_fifo;
  rand flash_ctrl_mem_rd_fifo rd_fifo;

  `uvm_object_utils(flash_ctrl_reg_block)

  function new(string name = "flash_ctrl_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    intr_state = flash_ctrl_reg_intr_state::type_id::create("intr_state");
    intr_state.configure(.blk_parent(this));
    intr_state.build();
    default_map.add_reg(.rg(intr_state),
                        .offset(32'h0),
                        .rights("RW"));
    intr_enable = flash_ctrl_reg_intr_enable::type_id::create("intr_enable");
    intr_enable.configure(.blk_parent(this));
    intr_enable.build();
    default_map.add_reg(.rg(intr_enable),
                        .offset(32'h4),
                        .rights("RW"));
    intr_test = flash_ctrl_reg_intr_test::type_id::create("intr_test");
    intr_test.configure(.blk_parent(this));
    intr_test.build();
    default_map.add_reg(.rg(intr_test),
                        .offset(32'h8),
                        .rights("WO"));
    control = flash_ctrl_reg_control::type_id::create("control");
    control.configure(.blk_parent(this));
    control.build();
    default_map.add_reg(.rg(control),
                        .offset(32'hc),
                        .rights("RW"));
    addr = flash_ctrl_reg_addr::type_id::create("addr");
    addr.configure(.blk_parent(this));
    addr.build();
    default_map.add_reg(.rg(addr),
                        .offset(32'h10),
                        .rights("RW"));
    region_cfg_regwen = flash_ctrl_reg_region_cfg_regwen::type_id::create("region_cfg_regwen");
    region_cfg_regwen.configure(.blk_parent(this));
    region_cfg_regwen.build();
    default_map.add_reg(.rg(region_cfg_regwen),
                        .offset(32'h14),
                        .rights("RW"));
    mp_region_cfg0 = flash_ctrl_reg_mp_region_cfg0::type_id::create("mp_region_cfg0");
    mp_region_cfg0.configure(.blk_parent(this));
    mp_region_cfg0.build();
    default_map.add_reg(.rg(mp_region_cfg0),
                        .offset(32'h18),
                        .rights("RW"));
    mp_region_cfg1 = flash_ctrl_reg_mp_region_cfg1::type_id::create("mp_region_cfg1");
    mp_region_cfg1.configure(.blk_parent(this));
    mp_region_cfg1.build();
    default_map.add_reg(.rg(mp_region_cfg1),
                        .offset(32'h1c),
                        .rights("RW"));
    mp_region_cfg2 = flash_ctrl_reg_mp_region_cfg2::type_id::create("mp_region_cfg2");
    mp_region_cfg2.configure(.blk_parent(this));
    mp_region_cfg2.build();
    default_map.add_reg(.rg(mp_region_cfg2),
                        .offset(32'h20),
                        .rights("RW"));
    mp_region_cfg3 = flash_ctrl_reg_mp_region_cfg3::type_id::create("mp_region_cfg3");
    mp_region_cfg3.configure(.blk_parent(this));
    mp_region_cfg3.build();
    default_map.add_reg(.rg(mp_region_cfg3),
                        .offset(32'h24),
                        .rights("RW"));
    mp_region_cfg4 = flash_ctrl_reg_mp_region_cfg4::type_id::create("mp_region_cfg4");
    mp_region_cfg4.configure(.blk_parent(this));
    mp_region_cfg4.build();
    default_map.add_reg(.rg(mp_region_cfg4),
                        .offset(32'h28),
                        .rights("RW"));
    mp_region_cfg5 = flash_ctrl_reg_mp_region_cfg5::type_id::create("mp_region_cfg5");
    mp_region_cfg5.configure(.blk_parent(this));
    mp_region_cfg5.build();
    default_map.add_reg(.rg(mp_region_cfg5),
                        .offset(32'h2c),
                        .rights("RW"));
    mp_region_cfg6 = flash_ctrl_reg_mp_region_cfg6::type_id::create("mp_region_cfg6");
    mp_region_cfg6.configure(.blk_parent(this));
    mp_region_cfg6.build();
    default_map.add_reg(.rg(mp_region_cfg6),
                        .offset(32'h30),
                        .rights("RW"));
    mp_region_cfg7 = flash_ctrl_reg_mp_region_cfg7::type_id::create("mp_region_cfg7");
    mp_region_cfg7.configure(.blk_parent(this));
    mp_region_cfg7.build();
    default_map.add_reg(.rg(mp_region_cfg7),
                        .offset(32'h34),
                        .rights("RW"));
    default_region = flash_ctrl_reg_default_region::type_id::create("default_region");
    default_region.configure(.blk_parent(this));
    default_region.build();
    default_map.add_reg(.rg(default_region),
                        .offset(32'h38),
                        .rights("RW"));
    bank_cfg_regwen = flash_ctrl_reg_bank_cfg_regwen::type_id::create("bank_cfg_regwen");
    bank_cfg_regwen.configure(.blk_parent(this));
    bank_cfg_regwen.build();
    default_map.add_reg(.rg(bank_cfg_regwen),
                        .offset(32'h3c),
                        .rights("RW"));
    mp_bank_cfg = flash_ctrl_reg_mp_bank_cfg::type_id::create("mp_bank_cfg");
    mp_bank_cfg.configure(.blk_parent(this));
    mp_bank_cfg.build();
    default_map.add_reg(.rg(mp_bank_cfg),
                        .offset(32'h40),
                        .rights("RW"));
    op_status = flash_ctrl_reg_op_status::type_id::create("op_status");
    op_status.configure(.blk_parent(this));
    op_status.build();
    default_map.add_reg(.rg(op_status),
                        .offset(32'h44),
                        .rights("RW"));
    status = flash_ctrl_reg_status::type_id::create("status");
    status.configure(.blk_parent(this));
    status.build();
    default_map.add_reg(.rg(status),
                        .offset(32'h48),
                        .rights("RO"));
    scratch = flash_ctrl_reg_scratch::type_id::create("scratch");
    scratch.configure(.blk_parent(this));
    scratch.build();
    default_map.add_reg(.rg(scratch),
                        .offset(32'h4c),
                        .rights("RW"));
    fifo_lvl = flash_ctrl_reg_fifo_lvl::type_id::create("fifo_lvl");
    fifo_lvl.configure(.blk_parent(this));
    fifo_lvl.build();
    default_map.add_reg(.rg(fifo_lvl),
                        .offset(32'h50),
                        .rights("RW"));

    // create memories
    prog_fifo = flash_ctrl_mem_prog_fifo::type_id::create("prog_fifo");
    prog_fifo.configure(.parent(this));
    default_map.add_mem(.mem(prog_fifo),
                        .offset(32'h54),
                        .rights("WO"));
    rd_fifo = flash_ctrl_mem_rd_fifo::type_id::create("rd_fifo");
    rd_fifo.configure(.parent(this));
    default_map.add_mem(.mem(rd_fifo),
                        .offset(32'h58),
                        .rights("RO"));
  endfunction : build

endclass : flash_ctrl_reg_block

// Block: rv_timer
// Class: rv_timer_reg_ctrl
class rv_timer_reg_ctrl extends dv_base_reg;
  // fields
  rand dv_base_reg_field active0;

  `uvm_object_utils(rv_timer_reg_ctrl)

  function new(string       name = "rv_timer_reg_ctrl",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    active0 = dv_base_reg_field::type_id::create("active0");
    active0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_timer_reg_ctrl

// Class: rv_timer_reg_cfg0
class rv_timer_reg_cfg0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prescale;
  rand dv_base_reg_field step;

  `uvm_object_utils(rv_timer_reg_cfg0)

  function new(string       name = "rv_timer_reg_cfg0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prescale = dv_base_reg_field::type_id::create("prescale");
    prescale.configure(
      .parent(this),
      .size(12),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    step = dv_base_reg_field::type_id::create("step");
    step.configure(
      .parent(this),
      .size(8),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_timer_reg_cfg0

// Class: rv_timer_reg_timer_v_lower0
class rv_timer_reg_timer_v_lower0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field v;

  `uvm_object_utils(rv_timer_reg_timer_v_lower0)

  function new(string       name = "rv_timer_reg_timer_v_lower0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    v = dv_base_reg_field::type_id::create("v");
    v.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_timer_reg_timer_v_lower0

// Class: rv_timer_reg_timer_v_upper0
class rv_timer_reg_timer_v_upper0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field v;

  `uvm_object_utils(rv_timer_reg_timer_v_upper0)

  function new(string       name = "rv_timer_reg_timer_v_upper0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    v = dv_base_reg_field::type_id::create("v");
    v.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_timer_reg_timer_v_upper0

// Class: rv_timer_reg_compare_lower0_0
class rv_timer_reg_compare_lower0_0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field v;

  `uvm_object_utils(rv_timer_reg_compare_lower0_0)

  function new(string       name = "rv_timer_reg_compare_lower0_0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    v = dv_base_reg_field::type_id::create("v");
    v.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(4294967295),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_timer_reg_compare_lower0_0

// Class: rv_timer_reg_compare_upper0_0
class rv_timer_reg_compare_upper0_0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field v;

  `uvm_object_utils(rv_timer_reg_compare_upper0_0)

  function new(string       name = "rv_timer_reg_compare_upper0_0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    v = dv_base_reg_field::type_id::create("v");
    v.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(4294967295),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_timer_reg_compare_upper0_0

// Class: rv_timer_reg_intr_enable0
class rv_timer_reg_intr_enable0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field ie0;

  `uvm_object_utils(rv_timer_reg_intr_enable0)

  function new(string       name = "rv_timer_reg_intr_enable0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    ie0 = dv_base_reg_field::type_id::create("ie0");
    ie0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_timer_reg_intr_enable0

// Class: rv_timer_reg_intr_state0
class rv_timer_reg_intr_state0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field is0;

  `uvm_object_utils(rv_timer_reg_intr_state0)

  function new(string       name = "rv_timer_reg_intr_state0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    is0 = dv_base_reg_field::type_id::create("is0");
    is0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_timer_reg_intr_state0

// Class: rv_timer_reg_intr_test0
class rv_timer_reg_intr_test0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field t0;

  `uvm_object_utils(rv_timer_reg_intr_test0)

  function new(string       name = "rv_timer_reg_intr_test0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    t0 = dv_base_reg_field::type_id::create("t0");
    t0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_timer_reg_intr_test0

// Class: rv_timer_reg_block
class rv_timer_reg_block extends dv_base_reg_block;
  // registers
  rand rv_timer_reg_ctrl ctrl;
  rand rv_timer_reg_cfg0 cfg0;
  rand rv_timer_reg_timer_v_lower0 timer_v_lower0;
  rand rv_timer_reg_timer_v_upper0 timer_v_upper0;
  rand rv_timer_reg_compare_lower0_0 compare_lower0_0;
  rand rv_timer_reg_compare_upper0_0 compare_upper0_0;
  rand rv_timer_reg_intr_enable0 intr_enable0;
  rand rv_timer_reg_intr_state0 intr_state0;
  rand rv_timer_reg_intr_test0 intr_test0;

  `uvm_object_utils(rv_timer_reg_block)

  function new(string name = "rv_timer_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    ctrl = rv_timer_reg_ctrl::type_id::create("ctrl");
    ctrl.configure(.blk_parent(this));
    ctrl.build();
    default_map.add_reg(.rg(ctrl),
                        .offset(32'h0),
                        .rights("RW"));
    cfg0 = rv_timer_reg_cfg0::type_id::create("cfg0");
    cfg0.configure(.blk_parent(this));
    cfg0.build();
    default_map.add_reg(.rg(cfg0),
                        .offset(32'h100),
                        .rights("RW"));
    timer_v_lower0 = rv_timer_reg_timer_v_lower0::type_id::create("timer_v_lower0");
    timer_v_lower0.configure(.blk_parent(this));
    timer_v_lower0.build();
    default_map.add_reg(.rg(timer_v_lower0),
                        .offset(32'h104),
                        .rights("RW"));
    timer_v_upper0 = rv_timer_reg_timer_v_upper0::type_id::create("timer_v_upper0");
    timer_v_upper0.configure(.blk_parent(this));
    timer_v_upper0.build();
    default_map.add_reg(.rg(timer_v_upper0),
                        .offset(32'h108),
                        .rights("RW"));
    compare_lower0_0 = rv_timer_reg_compare_lower0_0::type_id::create("compare_lower0_0");
    compare_lower0_0.configure(.blk_parent(this));
    compare_lower0_0.build();
    default_map.add_reg(.rg(compare_lower0_0),
                        .offset(32'h10c),
                        .rights("RW"));
    compare_upper0_0 = rv_timer_reg_compare_upper0_0::type_id::create("compare_upper0_0");
    compare_upper0_0.configure(.blk_parent(this));
    compare_upper0_0.build();
    default_map.add_reg(.rg(compare_upper0_0),
                        .offset(32'h110),
                        .rights("RW"));
    intr_enable0 = rv_timer_reg_intr_enable0::type_id::create("intr_enable0");
    intr_enable0.configure(.blk_parent(this));
    intr_enable0.build();
    default_map.add_reg(.rg(intr_enable0),
                        .offset(32'h114),
                        .rights("RW"));
    intr_state0 = rv_timer_reg_intr_state0::type_id::create("intr_state0");
    intr_state0.configure(.blk_parent(this));
    intr_state0.build();
    default_map.add_reg(.rg(intr_state0),
                        .offset(32'h118),
                        .rights("RW"));
    intr_test0 = rv_timer_reg_intr_test0::type_id::create("intr_test0");
    intr_test0.configure(.blk_parent(this));
    intr_test0.build();
    default_map.add_reg(.rg(intr_test0),
                        .offset(32'h11c),
                        .rights("WO"));
  endfunction : build

endclass : rv_timer_reg_block

// Block: gpio
// Class: gpio_reg_intr_state
class gpio_reg_intr_state extends dv_base_reg;
  // fields
  rand dv_base_reg_field gpio;

  `uvm_object_utils(gpio_reg_intr_state)

  function new(string       name = "gpio_reg_intr_state",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    gpio = dv_base_reg_field::type_id::create("gpio");
    gpio.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_intr_state

// Class: gpio_reg_intr_enable
class gpio_reg_intr_enable extends dv_base_reg;
  // fields
  rand dv_base_reg_field gpio;

  `uvm_object_utils(gpio_reg_intr_enable)

  function new(string       name = "gpio_reg_intr_enable",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    gpio = dv_base_reg_field::type_id::create("gpio");
    gpio.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_intr_enable

// Class: gpio_reg_intr_test
class gpio_reg_intr_test extends dv_base_reg;
  // fields
  rand dv_base_reg_field gpio;

  `uvm_object_utils(gpio_reg_intr_test)

  function new(string       name = "gpio_reg_intr_test",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    gpio = dv_base_reg_field::type_id::create("gpio");
    gpio.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_intr_test

// Class: gpio_reg_data_in
class gpio_reg_data_in extends dv_base_reg;
  // fields
  rand dv_base_reg_field data_in;

  `uvm_object_utils(gpio_reg_data_in)

  function new(string       name = "gpio_reg_data_in",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data_in = dv_base_reg_field::type_id::create("data_in");
    data_in.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_data_in

// Class: gpio_reg_direct_out
class gpio_reg_direct_out extends dv_base_reg;
  // fields
  rand dv_base_reg_field direct_out;

  `uvm_object_utils(gpio_reg_direct_out)

  function new(string       name = "gpio_reg_direct_out",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    direct_out = dv_base_reg_field::type_id::create("direct_out");
    direct_out.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_direct_out

// Class: gpio_reg_masked_out_lower
class gpio_reg_masked_out_lower extends dv_base_reg;
  // fields
  rand dv_base_reg_field data;
  rand dv_base_reg_field mask;

  `uvm_object_utils(gpio_reg_masked_out_lower)

  function new(string       name = "gpio_reg_masked_out_lower",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data = dv_base_reg_field::type_id::create("data");
    data.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    mask = dv_base_reg_field::type_id::create("mask");
    mask.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_masked_out_lower

// Class: gpio_reg_masked_out_upper
class gpio_reg_masked_out_upper extends dv_base_reg;
  // fields
  rand dv_base_reg_field data;
  rand dv_base_reg_field mask;

  `uvm_object_utils(gpio_reg_masked_out_upper)

  function new(string       name = "gpio_reg_masked_out_upper",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data = dv_base_reg_field::type_id::create("data");
    data.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    mask = dv_base_reg_field::type_id::create("mask");
    mask.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_masked_out_upper

// Class: gpio_reg_direct_oe
class gpio_reg_direct_oe extends dv_base_reg;
  // fields
  rand dv_base_reg_field direct_oe;

  `uvm_object_utils(gpio_reg_direct_oe)

  function new(string       name = "gpio_reg_direct_oe",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    direct_oe = dv_base_reg_field::type_id::create("direct_oe");
    direct_oe.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_direct_oe

// Class: gpio_reg_masked_oe_lower
class gpio_reg_masked_oe_lower extends dv_base_reg;
  // fields
  rand dv_base_reg_field data;
  rand dv_base_reg_field mask;

  `uvm_object_utils(gpio_reg_masked_oe_lower)

  function new(string       name = "gpio_reg_masked_oe_lower",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data = dv_base_reg_field::type_id::create("data");
    data.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    mask = dv_base_reg_field::type_id::create("mask");
    mask.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_masked_oe_lower

// Class: gpio_reg_masked_oe_upper
class gpio_reg_masked_oe_upper extends dv_base_reg;
  // fields
  rand dv_base_reg_field data;
  rand dv_base_reg_field mask;

  `uvm_object_utils(gpio_reg_masked_oe_upper)

  function new(string       name = "gpio_reg_masked_oe_upper",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    data = dv_base_reg_field::type_id::create("data");
    data.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    mask = dv_base_reg_field::type_id::create("mask");
    mask.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_masked_oe_upper

// Class: gpio_reg_intr_ctrl_en_rising
class gpio_reg_intr_ctrl_en_rising extends dv_base_reg;
  // fields
  rand dv_base_reg_field intr_ctrl_en_rising;

  `uvm_object_utils(gpio_reg_intr_ctrl_en_rising)

  function new(string       name = "gpio_reg_intr_ctrl_en_rising",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    intr_ctrl_en_rising = dv_base_reg_field::type_id::create("intr_ctrl_en_rising");
    intr_ctrl_en_rising.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_intr_ctrl_en_rising

// Class: gpio_reg_intr_ctrl_en_falling
class gpio_reg_intr_ctrl_en_falling extends dv_base_reg;
  // fields
  rand dv_base_reg_field intr_ctrl_en_falling;

  `uvm_object_utils(gpio_reg_intr_ctrl_en_falling)

  function new(string       name = "gpio_reg_intr_ctrl_en_falling",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    intr_ctrl_en_falling = dv_base_reg_field::type_id::create("intr_ctrl_en_falling");
    intr_ctrl_en_falling.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_intr_ctrl_en_falling

// Class: gpio_reg_intr_ctrl_en_lvlhigh
class gpio_reg_intr_ctrl_en_lvlhigh extends dv_base_reg;
  // fields
  rand dv_base_reg_field intr_ctrl_en_lvlhigh;

  `uvm_object_utils(gpio_reg_intr_ctrl_en_lvlhigh)

  function new(string       name = "gpio_reg_intr_ctrl_en_lvlhigh",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    intr_ctrl_en_lvlhigh = dv_base_reg_field::type_id::create("intr_ctrl_en_lvlhigh");
    intr_ctrl_en_lvlhigh.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_intr_ctrl_en_lvlhigh

// Class: gpio_reg_intr_ctrl_en_lvllow
class gpio_reg_intr_ctrl_en_lvllow extends dv_base_reg;
  // fields
  rand dv_base_reg_field intr_ctrl_en_lvllow;

  `uvm_object_utils(gpio_reg_intr_ctrl_en_lvllow)

  function new(string       name = "gpio_reg_intr_ctrl_en_lvllow",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    intr_ctrl_en_lvllow = dv_base_reg_field::type_id::create("intr_ctrl_en_lvllow");
    intr_ctrl_en_lvllow.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_intr_ctrl_en_lvllow

// Class: gpio_reg_ctrl_en_input_filter
class gpio_reg_ctrl_en_input_filter extends dv_base_reg;
  // fields
  rand dv_base_reg_field ctrl_en_input_filter;

  `uvm_object_utils(gpio_reg_ctrl_en_input_filter)

  function new(string       name = "gpio_reg_ctrl_en_input_filter",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    ctrl_en_input_filter = dv_base_reg_field::type_id::create("ctrl_en_input_filter");
    ctrl_en_input_filter.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : gpio_reg_ctrl_en_input_filter

// Class: gpio_reg_block
class gpio_reg_block extends dv_base_reg_block;
  // registers
  rand gpio_reg_intr_state intr_state;
  rand gpio_reg_intr_enable intr_enable;
  rand gpio_reg_intr_test intr_test;
  rand gpio_reg_data_in data_in;
  rand gpio_reg_direct_out direct_out;
  rand gpio_reg_masked_out_lower masked_out_lower;
  rand gpio_reg_masked_out_upper masked_out_upper;
  rand gpio_reg_direct_oe direct_oe;
  rand gpio_reg_masked_oe_lower masked_oe_lower;
  rand gpio_reg_masked_oe_upper masked_oe_upper;
  rand gpio_reg_intr_ctrl_en_rising intr_ctrl_en_rising;
  rand gpio_reg_intr_ctrl_en_falling intr_ctrl_en_falling;
  rand gpio_reg_intr_ctrl_en_lvlhigh intr_ctrl_en_lvlhigh;
  rand gpio_reg_intr_ctrl_en_lvllow intr_ctrl_en_lvllow;
  rand gpio_reg_ctrl_en_input_filter ctrl_en_input_filter;

  `uvm_object_utils(gpio_reg_block)

  function new(string name = "gpio_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    intr_state = gpio_reg_intr_state::type_id::create("intr_state");
    intr_state.configure(.blk_parent(this));
    intr_state.build();
    default_map.add_reg(.rg(intr_state),
                        .offset(32'h0),
                        .rights("RW"));
    intr_enable = gpio_reg_intr_enable::type_id::create("intr_enable");
    intr_enable.configure(.blk_parent(this));
    intr_enable.build();
    default_map.add_reg(.rg(intr_enable),
                        .offset(32'h4),
                        .rights("RW"));
    intr_test = gpio_reg_intr_test::type_id::create("intr_test");
    intr_test.configure(.blk_parent(this));
    intr_test.build();
    default_map.add_reg(.rg(intr_test),
                        .offset(32'h8),
                        .rights("WO"));
    data_in = gpio_reg_data_in::type_id::create("data_in");
    data_in.configure(.blk_parent(this));
    data_in.build();
    default_map.add_reg(.rg(data_in),
                        .offset(32'hc),
                        .rights("RO"));
    direct_out = gpio_reg_direct_out::type_id::create("direct_out");
    direct_out.configure(.blk_parent(this));
    direct_out.build();
    default_map.add_reg(.rg(direct_out),
                        .offset(32'h10),
                        .rights("RW"));
    masked_out_lower = gpio_reg_masked_out_lower::type_id::create("masked_out_lower");
    masked_out_lower.configure(.blk_parent(this));
    masked_out_lower.build();
    default_map.add_reg(.rg(masked_out_lower),
                        .offset(32'h14),
                        .rights("RW"));
    masked_out_upper = gpio_reg_masked_out_upper::type_id::create("masked_out_upper");
    masked_out_upper.configure(.blk_parent(this));
    masked_out_upper.build();
    default_map.add_reg(.rg(masked_out_upper),
                        .offset(32'h18),
                        .rights("RW"));
    direct_oe = gpio_reg_direct_oe::type_id::create("direct_oe");
    direct_oe.configure(.blk_parent(this));
    direct_oe.build();
    default_map.add_reg(.rg(direct_oe),
                        .offset(32'h1c),
                        .rights("RW"));
    masked_oe_lower = gpio_reg_masked_oe_lower::type_id::create("masked_oe_lower");
    masked_oe_lower.configure(.blk_parent(this));
    masked_oe_lower.build();
    default_map.add_reg(.rg(masked_oe_lower),
                        .offset(32'h20),
                        .rights("RW"));
    masked_oe_upper = gpio_reg_masked_oe_upper::type_id::create("masked_oe_upper");
    masked_oe_upper.configure(.blk_parent(this));
    masked_oe_upper.build();
    default_map.add_reg(.rg(masked_oe_upper),
                        .offset(32'h24),
                        .rights("RW"));
    intr_ctrl_en_rising = gpio_reg_intr_ctrl_en_rising::type_id::create("intr_ctrl_en_rising");
    intr_ctrl_en_rising.configure(.blk_parent(this));
    intr_ctrl_en_rising.build();
    default_map.add_reg(.rg(intr_ctrl_en_rising),
                        .offset(32'h28),
                        .rights("RW"));
    intr_ctrl_en_falling = gpio_reg_intr_ctrl_en_falling::type_id::create("intr_ctrl_en_falling");
    intr_ctrl_en_falling.configure(.blk_parent(this));
    intr_ctrl_en_falling.build();
    default_map.add_reg(.rg(intr_ctrl_en_falling),
                        .offset(32'h2c),
                        .rights("RW"));
    intr_ctrl_en_lvlhigh = gpio_reg_intr_ctrl_en_lvlhigh::type_id::create("intr_ctrl_en_lvlhigh");
    intr_ctrl_en_lvlhigh.configure(.blk_parent(this));
    intr_ctrl_en_lvlhigh.build();
    default_map.add_reg(.rg(intr_ctrl_en_lvlhigh),
                        .offset(32'h30),
                        .rights("RW"));
    intr_ctrl_en_lvllow = gpio_reg_intr_ctrl_en_lvllow::type_id::create("intr_ctrl_en_lvllow");
    intr_ctrl_en_lvllow.configure(.blk_parent(this));
    intr_ctrl_en_lvllow.build();
    default_map.add_reg(.rg(intr_ctrl_en_lvllow),
                        .offset(32'h34),
                        .rights("RW"));
    ctrl_en_input_filter = gpio_reg_ctrl_en_input_filter::type_id::create("ctrl_en_input_filter");
    ctrl_en_input_filter.configure(.blk_parent(this));
    ctrl_en_input_filter.build();
    default_map.add_reg(.rg(ctrl_en_input_filter),
                        .offset(32'h38),
                        .rights("RW"));
  endfunction : build

endclass : gpio_reg_block

// Block: hmac
// Class: hmac_reg_intr_state
class hmac_reg_intr_state extends dv_base_reg;
  // fields
  rand dv_base_reg_field hmac_done;
  rand dv_base_reg_field fifo_full;

  `uvm_object_utils(hmac_reg_intr_state)

  function new(string       name = "hmac_reg_intr_state",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    hmac_done = dv_base_reg_field::type_id::create("hmac_done");
    hmac_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    fifo_full = dv_base_reg_field::type_id::create("fifo_full");
    fifo_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_intr_state

// Class: hmac_reg_intr_enable
class hmac_reg_intr_enable extends dv_base_reg;
  // fields
  rand dv_base_reg_field hmac_done;
  rand dv_base_reg_field fifo_full;

  `uvm_object_utils(hmac_reg_intr_enable)

  function new(string       name = "hmac_reg_intr_enable",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    hmac_done = dv_base_reg_field::type_id::create("hmac_done");
    hmac_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    fifo_full = dv_base_reg_field::type_id::create("fifo_full");
    fifo_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_intr_enable

// Class: hmac_reg_intr_test
class hmac_reg_intr_test extends dv_base_reg;
  // fields
  rand dv_base_reg_field hmac_done;
  rand dv_base_reg_field fifo_full;

  `uvm_object_utils(hmac_reg_intr_test)

  function new(string       name = "hmac_reg_intr_test",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    hmac_done = dv_base_reg_field::type_id::create("hmac_done");
    hmac_done.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    fifo_full = dv_base_reg_field::type_id::create("fifo_full");
    fifo_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_intr_test

// Class: hmac_reg_cfg
class hmac_reg_cfg extends dv_base_reg;
  // fields
  rand dv_base_reg_field hmac_en;
  rand dv_base_reg_field sha_en;
  rand dv_base_reg_field endian_swap;
  rand dv_base_reg_field digest_swap;

  `uvm_object_utils(hmac_reg_cfg)

  function new(string       name = "hmac_reg_cfg",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    hmac_en = dv_base_reg_field::type_id::create("hmac_en");
    hmac_en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    sha_en = dv_base_reg_field::type_id::create("sha_en");
    sha_en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    endian_swap = dv_base_reg_field::type_id::create("endian_swap");
    endian_swap.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    digest_swap = dv_base_reg_field::type_id::create("digest_swap");
    digest_swap.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_cfg

// Class: hmac_reg_cmd
class hmac_reg_cmd extends dv_base_reg;
  // fields
  rand dv_base_reg_field hash_start;
  rand dv_base_reg_field hash_process;

  `uvm_object_utils(hmac_reg_cmd)

  function new(string       name = "hmac_reg_cmd",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    hash_start = dv_base_reg_field::type_id::create("hash_start");
    hash_start.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W1C"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    hash_process = dv_base_reg_field::type_id::create("hash_process");
    hash_process.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("W1C"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_cmd

// Class: hmac_reg_status
class hmac_reg_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field fifo_empty;
  rand dv_base_reg_field fifo_full;
  rand dv_base_reg_field fifo_depth;

  `uvm_object_utils(hmac_reg_status)

  function new(string       name = "hmac_reg_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    fifo_empty = dv_base_reg_field::type_id::create("fifo_empty");
    fifo_empty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    fifo_full = dv_base_reg_field::type_id::create("fifo_full");
    fifo_full.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    fifo_depth = dv_base_reg_field::type_id::create("fifo_depth");
    fifo_depth.configure(
      .parent(this),
      .size(5),
      .lsb_pos(4),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_status

// Class: hmac_reg_wipe_secret
class hmac_reg_wipe_secret extends dv_base_reg;
  // fields
  rand dv_base_reg_field secret;

  `uvm_object_utils(hmac_reg_wipe_secret)

  function new(string       name = "hmac_reg_wipe_secret",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    secret = dv_base_reg_field::type_id::create("secret");
    secret.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_wipe_secret

// Class: hmac_reg_key0
class hmac_reg_key0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key0;

  `uvm_object_utils(hmac_reg_key0)

  function new(string       name = "hmac_reg_key0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key0 = dv_base_reg_field::type_id::create("key0");
    key0.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_key0

// Class: hmac_reg_key1
class hmac_reg_key1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key1;

  `uvm_object_utils(hmac_reg_key1)

  function new(string       name = "hmac_reg_key1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key1 = dv_base_reg_field::type_id::create("key1");
    key1.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_key1

// Class: hmac_reg_key2
class hmac_reg_key2 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key2;

  `uvm_object_utils(hmac_reg_key2)

  function new(string       name = "hmac_reg_key2",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key2 = dv_base_reg_field::type_id::create("key2");
    key2.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_key2

// Class: hmac_reg_key3
class hmac_reg_key3 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key3;

  `uvm_object_utils(hmac_reg_key3)

  function new(string       name = "hmac_reg_key3",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key3 = dv_base_reg_field::type_id::create("key3");
    key3.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_key3

// Class: hmac_reg_key4
class hmac_reg_key4 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key4;

  `uvm_object_utils(hmac_reg_key4)

  function new(string       name = "hmac_reg_key4",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key4 = dv_base_reg_field::type_id::create("key4");
    key4.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_key4

// Class: hmac_reg_key5
class hmac_reg_key5 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key5;

  `uvm_object_utils(hmac_reg_key5)

  function new(string       name = "hmac_reg_key5",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key5 = dv_base_reg_field::type_id::create("key5");
    key5.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_key5

// Class: hmac_reg_key6
class hmac_reg_key6 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key6;

  `uvm_object_utils(hmac_reg_key6)

  function new(string       name = "hmac_reg_key6",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key6 = dv_base_reg_field::type_id::create("key6");
    key6.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_key6

// Class: hmac_reg_key7
class hmac_reg_key7 extends dv_base_reg;
  // fields
  rand dv_base_reg_field key7;

  `uvm_object_utils(hmac_reg_key7)

  function new(string       name = "hmac_reg_key7",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    key7 = dv_base_reg_field::type_id::create("key7");
    key7.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("WO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_key7

// Class: hmac_reg_digest0
class hmac_reg_digest0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field digest0;

  `uvm_object_utils(hmac_reg_digest0)

  function new(string       name = "hmac_reg_digest0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    digest0 = dv_base_reg_field::type_id::create("digest0");
    digest0.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_digest0

// Class: hmac_reg_digest1
class hmac_reg_digest1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field digest1;

  `uvm_object_utils(hmac_reg_digest1)

  function new(string       name = "hmac_reg_digest1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    digest1 = dv_base_reg_field::type_id::create("digest1");
    digest1.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_digest1

// Class: hmac_reg_digest2
class hmac_reg_digest2 extends dv_base_reg;
  // fields
  rand dv_base_reg_field digest2;

  `uvm_object_utils(hmac_reg_digest2)

  function new(string       name = "hmac_reg_digest2",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    digest2 = dv_base_reg_field::type_id::create("digest2");
    digest2.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_digest2

// Class: hmac_reg_digest3
class hmac_reg_digest3 extends dv_base_reg;
  // fields
  rand dv_base_reg_field digest3;

  `uvm_object_utils(hmac_reg_digest3)

  function new(string       name = "hmac_reg_digest3",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    digest3 = dv_base_reg_field::type_id::create("digest3");
    digest3.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_digest3

// Class: hmac_reg_digest4
class hmac_reg_digest4 extends dv_base_reg;
  // fields
  rand dv_base_reg_field digest4;

  `uvm_object_utils(hmac_reg_digest4)

  function new(string       name = "hmac_reg_digest4",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    digest4 = dv_base_reg_field::type_id::create("digest4");
    digest4.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_digest4

// Class: hmac_reg_digest5
class hmac_reg_digest5 extends dv_base_reg;
  // fields
  rand dv_base_reg_field digest5;

  `uvm_object_utils(hmac_reg_digest5)

  function new(string       name = "hmac_reg_digest5",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    digest5 = dv_base_reg_field::type_id::create("digest5");
    digest5.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_digest5

// Class: hmac_reg_digest6
class hmac_reg_digest6 extends dv_base_reg;
  // fields
  rand dv_base_reg_field digest6;

  `uvm_object_utils(hmac_reg_digest6)

  function new(string       name = "hmac_reg_digest6",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    digest6 = dv_base_reg_field::type_id::create("digest6");
    digest6.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_digest6

// Class: hmac_reg_digest7
class hmac_reg_digest7 extends dv_base_reg;
  // fields
  rand dv_base_reg_field digest7;

  `uvm_object_utils(hmac_reg_digest7)

  function new(string       name = "hmac_reg_digest7",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    digest7 = dv_base_reg_field::type_id::create("digest7");
    digest7.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_digest7

// Class: hmac_reg_msg_length_lower
class hmac_reg_msg_length_lower extends dv_base_reg;
  // fields
  rand dv_base_reg_field v;

  `uvm_object_utils(hmac_reg_msg_length_lower)

  function new(string       name = "hmac_reg_msg_length_lower",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    v = dv_base_reg_field::type_id::create("v");
    v.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_msg_length_lower

// Class: hmac_reg_msg_length_upper
class hmac_reg_msg_length_upper extends dv_base_reg;
  // fields
  rand dv_base_reg_field v;

  `uvm_object_utils(hmac_reg_msg_length_upper)

  function new(string       name = "hmac_reg_msg_length_upper",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    v = dv_base_reg_field::type_id::create("v");
    v.configure(
      .parent(this),
      .size(32),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : hmac_reg_msg_length_upper

// Class: hmac_mem_msg_fifo
class hmac_mem_msg_fifo extends dv_base_mem;

  `uvm_object_utils(hmac_mem_msg_fifo)

  function new(string           name = "hmac_mem_msg_fifo",
               longint unsigned size = 512,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"WO"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : hmac_mem_msg_fifo

// Class: hmac_reg_block
class hmac_reg_block extends dv_base_reg_block;
  // registers
  rand hmac_reg_intr_state intr_state;
  rand hmac_reg_intr_enable intr_enable;
  rand hmac_reg_intr_test intr_test;
  rand hmac_reg_cfg cfg;
  rand hmac_reg_cmd cmd;
  rand hmac_reg_status status;
  rand hmac_reg_wipe_secret wipe_secret;
  rand hmac_reg_key0 key0;
  rand hmac_reg_key1 key1;
  rand hmac_reg_key2 key2;
  rand hmac_reg_key3 key3;
  rand hmac_reg_key4 key4;
  rand hmac_reg_key5 key5;
  rand hmac_reg_key6 key6;
  rand hmac_reg_key7 key7;
  rand hmac_reg_digest0 digest0;
  rand hmac_reg_digest1 digest1;
  rand hmac_reg_digest2 digest2;
  rand hmac_reg_digest3 digest3;
  rand hmac_reg_digest4 digest4;
  rand hmac_reg_digest5 digest5;
  rand hmac_reg_digest6 digest6;
  rand hmac_reg_digest7 digest7;
  rand hmac_reg_msg_length_lower msg_length_lower;
  rand hmac_reg_msg_length_upper msg_length_upper;
  // memories
  rand hmac_mem_msg_fifo msg_fifo;

  `uvm_object_utils(hmac_reg_block)

  function new(string name = "hmac_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    intr_state = hmac_reg_intr_state::type_id::create("intr_state");
    intr_state.configure(.blk_parent(this));
    intr_state.build();
    default_map.add_reg(.rg(intr_state),
                        .offset(32'h0),
                        .rights("RW"));
    intr_enable = hmac_reg_intr_enable::type_id::create("intr_enable");
    intr_enable.configure(.blk_parent(this));
    intr_enable.build();
    default_map.add_reg(.rg(intr_enable),
                        .offset(32'h4),
                        .rights("RW"));
    intr_test = hmac_reg_intr_test::type_id::create("intr_test");
    intr_test.configure(.blk_parent(this));
    intr_test.build();
    default_map.add_reg(.rg(intr_test),
                        .offset(32'h8),
                        .rights("WO"));
    cfg = hmac_reg_cfg::type_id::create("cfg");
    cfg.configure(.blk_parent(this));
    cfg.build();
    default_map.add_reg(.rg(cfg),
                        .offset(32'hc),
                        .rights("RW"));
    cmd = hmac_reg_cmd::type_id::create("cmd");
    cmd.configure(.blk_parent(this));
    cmd.build();
    default_map.add_reg(.rg(cmd),
                        .offset(32'h10),
                        .rights("RW"));
    status = hmac_reg_status::type_id::create("status");
    status.configure(.blk_parent(this));
    status.build();
    default_map.add_reg(.rg(status),
                        .offset(32'h14),
                        .rights("RO"));
    wipe_secret = hmac_reg_wipe_secret::type_id::create("wipe_secret");
    wipe_secret.configure(.blk_parent(this));
    wipe_secret.build();
    default_map.add_reg(.rg(wipe_secret),
                        .offset(32'h18),
                        .rights("WO"));
    key0 = hmac_reg_key0::type_id::create("key0");
    key0.configure(.blk_parent(this));
    key0.build();
    default_map.add_reg(.rg(key0),
                        .offset(32'h1c),
                        .rights("WO"));
    key1 = hmac_reg_key1::type_id::create("key1");
    key1.configure(.blk_parent(this));
    key1.build();
    default_map.add_reg(.rg(key1),
                        .offset(32'h20),
                        .rights("WO"));
    key2 = hmac_reg_key2::type_id::create("key2");
    key2.configure(.blk_parent(this));
    key2.build();
    default_map.add_reg(.rg(key2),
                        .offset(32'h24),
                        .rights("WO"));
    key3 = hmac_reg_key3::type_id::create("key3");
    key3.configure(.blk_parent(this));
    key3.build();
    default_map.add_reg(.rg(key3),
                        .offset(32'h28),
                        .rights("WO"));
    key4 = hmac_reg_key4::type_id::create("key4");
    key4.configure(.blk_parent(this));
    key4.build();
    default_map.add_reg(.rg(key4),
                        .offset(32'h2c),
                        .rights("WO"));
    key5 = hmac_reg_key5::type_id::create("key5");
    key5.configure(.blk_parent(this));
    key5.build();
    default_map.add_reg(.rg(key5),
                        .offset(32'h30),
                        .rights("WO"));
    key6 = hmac_reg_key6::type_id::create("key6");
    key6.configure(.blk_parent(this));
    key6.build();
    default_map.add_reg(.rg(key6),
                        .offset(32'h34),
                        .rights("WO"));
    key7 = hmac_reg_key7::type_id::create("key7");
    key7.configure(.blk_parent(this));
    key7.build();
    default_map.add_reg(.rg(key7),
                        .offset(32'h38),
                        .rights("WO"));
    digest0 = hmac_reg_digest0::type_id::create("digest0");
    digest0.configure(.blk_parent(this));
    digest0.build();
    default_map.add_reg(.rg(digest0),
                        .offset(32'h3c),
                        .rights("RO"));
    digest1 = hmac_reg_digest1::type_id::create("digest1");
    digest1.configure(.blk_parent(this));
    digest1.build();
    default_map.add_reg(.rg(digest1),
                        .offset(32'h40),
                        .rights("RO"));
    digest2 = hmac_reg_digest2::type_id::create("digest2");
    digest2.configure(.blk_parent(this));
    digest2.build();
    default_map.add_reg(.rg(digest2),
                        .offset(32'h44),
                        .rights("RO"));
    digest3 = hmac_reg_digest3::type_id::create("digest3");
    digest3.configure(.blk_parent(this));
    digest3.build();
    default_map.add_reg(.rg(digest3),
                        .offset(32'h48),
                        .rights("RO"));
    digest4 = hmac_reg_digest4::type_id::create("digest4");
    digest4.configure(.blk_parent(this));
    digest4.build();
    default_map.add_reg(.rg(digest4),
                        .offset(32'h4c),
                        .rights("RO"));
    digest5 = hmac_reg_digest5::type_id::create("digest5");
    digest5.configure(.blk_parent(this));
    digest5.build();
    default_map.add_reg(.rg(digest5),
                        .offset(32'h50),
                        .rights("RO"));
    digest6 = hmac_reg_digest6::type_id::create("digest6");
    digest6.configure(.blk_parent(this));
    digest6.build();
    default_map.add_reg(.rg(digest6),
                        .offset(32'h54),
                        .rights("RO"));
    digest7 = hmac_reg_digest7::type_id::create("digest7");
    digest7.configure(.blk_parent(this));
    digest7.build();
    default_map.add_reg(.rg(digest7),
                        .offset(32'h58),
                        .rights("RO"));
    msg_length_lower = hmac_reg_msg_length_lower::type_id::create("msg_length_lower");
    msg_length_lower.configure(.blk_parent(this));
    msg_length_lower.build();
    default_map.add_reg(.rg(msg_length_lower),
                        .offset(32'h5c),
                        .rights("RO"));
    msg_length_upper = hmac_reg_msg_length_upper::type_id::create("msg_length_upper");
    msg_length_upper.configure(.blk_parent(this));
    msg_length_upper.build();
    default_map.add_reg(.rg(msg_length_upper),
                        .offset(32'h60),
                        .rights("RO"));

    // create memories
    msg_fifo = hmac_mem_msg_fifo::type_id::create("msg_fifo");
    msg_fifo.configure(.parent(this));
    default_map.add_mem(.mem(msg_fifo),
                        .offset(32'h800),
                        .rights("WO"));
  endfunction : build

endclass : hmac_reg_block

// Block: uart
// Class: uart_reg_intr_state
class uart_reg_intr_state extends dv_base_reg;
  // fields
  rand dv_base_reg_field tx_watermark;
  rand dv_base_reg_field rx_watermark;
  rand dv_base_reg_field tx_overflow;
  rand dv_base_reg_field rx_overflow;
  rand dv_base_reg_field rx_frame_err;
  rand dv_base_reg_field rx_break_err;
  rand dv_base_reg_field rx_timeout;
  rand dv_base_reg_field rx_parity_err;

  `uvm_object_utils(uart_reg_intr_state)

  function new(string       name = "uart_reg_intr_state",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    tx_watermark = dv_base_reg_field::type_id::create("tx_watermark");
    tx_watermark.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_watermark = dv_base_reg_field::type_id::create("rx_watermark");
    rx_watermark.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    tx_overflow = dv_base_reg_field::type_id::create("tx_overflow");
    tx_overflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_overflow = dv_base_reg_field::type_id::create("rx_overflow");
    rx_overflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_frame_err = dv_base_reg_field::type_id::create("rx_frame_err");
    rx_frame_err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_break_err = dv_base_reg_field::type_id::create("rx_break_err");
    rx_break_err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_timeout = dv_base_reg_field::type_id::create("rx_timeout");
    rx_timeout.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_parity_err = dv_base_reg_field::type_id::create("rx_parity_err");
    rx_parity_err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("W1C"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_intr_state

// Class: uart_reg_intr_enable
class uart_reg_intr_enable extends dv_base_reg;
  // fields
  rand dv_base_reg_field tx_watermark;
  rand dv_base_reg_field rx_watermark;
  rand dv_base_reg_field tx_overflow;
  rand dv_base_reg_field rx_overflow;
  rand dv_base_reg_field rx_frame_err;
  rand dv_base_reg_field rx_break_err;
  rand dv_base_reg_field rx_timeout;
  rand dv_base_reg_field rx_parity_err;

  `uvm_object_utils(uart_reg_intr_enable)

  function new(string       name = "uart_reg_intr_enable",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    tx_watermark = dv_base_reg_field::type_id::create("tx_watermark");
    tx_watermark.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_watermark = dv_base_reg_field::type_id::create("rx_watermark");
    rx_watermark.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    tx_overflow = dv_base_reg_field::type_id::create("tx_overflow");
    tx_overflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_overflow = dv_base_reg_field::type_id::create("rx_overflow");
    rx_overflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_frame_err = dv_base_reg_field::type_id::create("rx_frame_err");
    rx_frame_err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_break_err = dv_base_reg_field::type_id::create("rx_break_err");
    rx_break_err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_timeout = dv_base_reg_field::type_id::create("rx_timeout");
    rx_timeout.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_parity_err = dv_base_reg_field::type_id::create("rx_parity_err");
    rx_parity_err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_intr_enable

// Class: uart_reg_intr_test
class uart_reg_intr_test extends dv_base_reg;
  // fields
  rand dv_base_reg_field tx_watermark;
  rand dv_base_reg_field rx_watermark;
  rand dv_base_reg_field tx_overflow;
  rand dv_base_reg_field rx_overflow;
  rand dv_base_reg_field rx_frame_err;
  rand dv_base_reg_field rx_break_err;
  rand dv_base_reg_field rx_timeout;
  rand dv_base_reg_field rx_parity_err;

  `uvm_object_utils(uart_reg_intr_test)

  function new(string       name = "uart_reg_intr_test",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    tx_watermark = dv_base_reg_field::type_id::create("tx_watermark");
    tx_watermark.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_watermark = dv_base_reg_field::type_id::create("rx_watermark");
    rx_watermark.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    tx_overflow = dv_base_reg_field::type_id::create("tx_overflow");
    tx_overflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_overflow = dv_base_reg_field::type_id::create("rx_overflow");
    rx_overflow.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_frame_err = dv_base_reg_field::type_id::create("rx_frame_err");
    rx_frame_err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_break_err = dv_base_reg_field::type_id::create("rx_break_err");
    rx_break_err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_timeout = dv_base_reg_field::type_id::create("rx_timeout");
    rx_timeout.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx_parity_err = dv_base_reg_field::type_id::create("rx_parity_err");
    rx_parity_err.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_intr_test

// Class: uart_reg_ctrl
class uart_reg_ctrl extends dv_base_reg;
  // fields
  rand dv_base_reg_field tx;
  rand dv_base_reg_field rx;
  rand dv_base_reg_field nf;
  rand dv_base_reg_field slpbk;
  rand dv_base_reg_field llpbk;
  rand dv_base_reg_field parity_en;
  rand dv_base_reg_field parity_odd;
  rand dv_base_reg_field rxblvl;
  rand dv_base_reg_field nco;

  `uvm_object_utils(uart_reg_ctrl)

  function new(string       name = "uart_reg_ctrl",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    tx = dv_base_reg_field::type_id::create("tx");
    tx.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rx = dv_base_reg_field::type_id::create("rx");
    rx.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    nf = dv_base_reg_field::type_id::create("nf");
    nf.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    slpbk = dv_base_reg_field::type_id::create("slpbk");
    slpbk.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    llpbk = dv_base_reg_field::type_id::create("llpbk");
    llpbk.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    parity_en = dv_base_reg_field::type_id::create("parity_en");
    parity_en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    parity_odd = dv_base_reg_field::type_id::create("parity_odd");
    parity_odd.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxblvl = dv_base_reg_field::type_id::create("rxblvl");
    rxblvl.configure(
      .parent(this),
      .size(2),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    nco = dv_base_reg_field::type_id::create("nco");
    nco.configure(
      .parent(this),
      .size(16),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_ctrl

// Class: uart_reg_status
class uart_reg_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field txfull;
  rand dv_base_reg_field rxfull;
  rand dv_base_reg_field txempty;
  rand dv_base_reg_field txidle;
  rand dv_base_reg_field rxidle;
  rand dv_base_reg_field rxempty;

  `uvm_object_utils(uart_reg_status)

  function new(string       name = "uart_reg_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    txfull = dv_base_reg_field::type_id::create("txfull");
    txfull.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxfull = dv_base_reg_field::type_id::create("rxfull");
    rxfull.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txempty = dv_base_reg_field::type_id::create("txempty");
    txempty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txidle = dv_base_reg_field::type_id::create("txidle");
    txidle.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxidle = dv_base_reg_field::type_id::create("rxidle");
    rxidle.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxempty = dv_base_reg_field::type_id::create("rxempty");
    rxempty.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RO"),
      .volatile(1),
      .reset(1),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_status

// Class: uart_reg_rdata
class uart_reg_rdata extends dv_base_reg;
  // fields
  rand dv_base_reg_field rdata;

  `uvm_object_utils(uart_reg_rdata)

  function new(string       name = "uart_reg_rdata",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rdata = dv_base_reg_field::type_id::create("rdata");
    rdata.configure(
      .parent(this),
      .size(8),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_rdata

// Class: uart_reg_wdata
class uart_reg_wdata extends dv_base_reg;
  // fields
  rand dv_base_reg_field wdata;

  `uvm_object_utils(uart_reg_wdata)

  function new(string       name = "uart_reg_wdata",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    wdata = dv_base_reg_field::type_id::create("wdata");
    wdata.configure(
      .parent(this),
      .size(8),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_wdata

// Class: uart_reg_fifo_ctrl
class uart_reg_fifo_ctrl extends dv_base_reg;
  // fields
  rand dv_base_reg_field rxrst;
  rand dv_base_reg_field txrst;
  rand dv_base_reg_field rxilvl;
  rand dv_base_reg_field txilvl;

  `uvm_object_utils(uart_reg_fifo_ctrl)

  function new(string       name = "uart_reg_fifo_ctrl",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rxrst = dv_base_reg_field::type_id::create("rxrst");
    rxrst.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txrst = dv_base_reg_field::type_id::create("txrst");
    txrst.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("WO"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxilvl = dv_base_reg_field::type_id::create("rxilvl");
    rxilvl.configure(
      .parent(this),
      .size(3),
      .lsb_pos(2),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txilvl = dv_base_reg_field::type_id::create("txilvl");
    txilvl.configure(
      .parent(this),
      .size(2),
      .lsb_pos(5),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_fifo_ctrl

// Class: uart_reg_fifo_status
class uart_reg_fifo_status extends dv_base_reg;
  // fields
  rand dv_base_reg_field txlvl;
  rand dv_base_reg_field rxlvl;

  `uvm_object_utils(uart_reg_fifo_status)

  function new(string       name = "uart_reg_fifo_status",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    txlvl = dv_base_reg_field::type_id::create("txlvl");
    txlvl.configure(
      .parent(this),
      .size(6),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    rxlvl = dv_base_reg_field::type_id::create("rxlvl");
    rxlvl.configure(
      .parent(this),
      .size(6),
      .lsb_pos(16),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_fifo_status

// Class: uart_reg_ovrd
class uart_reg_ovrd extends dv_base_reg;
  // fields
  rand dv_base_reg_field txen;
  rand dv_base_reg_field txval;

  `uvm_object_utils(uart_reg_ovrd)

  function new(string       name = "uart_reg_ovrd",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    txen = dv_base_reg_field::type_id::create("txen");
    txen.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    txval = dv_base_reg_field::type_id::create("txval");
    txval.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_ovrd

// Class: uart_reg_val
class uart_reg_val extends dv_base_reg;
  // fields
  rand dv_base_reg_field rx;

  `uvm_object_utils(uart_reg_val)

  function new(string       name = "uart_reg_val",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    rx = dv_base_reg_field::type_id::create("rx");
    rx.configure(
      .parent(this),
      .size(16),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_val

// Class: uart_reg_timeout_ctrl
class uart_reg_timeout_ctrl extends dv_base_reg;
  // fields
  rand dv_base_reg_field val;
  rand dv_base_reg_field en;

  `uvm_object_utils(uart_reg_timeout_ctrl)

  function new(string       name = "uart_reg_timeout_ctrl",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    val = dv_base_reg_field::type_id::create("val");
    val.configure(
      .parent(this),
      .size(24),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    en = dv_base_reg_field::type_id::create("en");
    en.configure(
      .parent(this),
      .size(1),
      .lsb_pos(31),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : uart_reg_timeout_ctrl

// Class: uart_reg_block
class uart_reg_block extends dv_base_reg_block;
  // registers
  rand uart_reg_intr_state intr_state;
  rand uart_reg_intr_enable intr_enable;
  rand uart_reg_intr_test intr_test;
  rand uart_reg_ctrl ctrl;
  rand uart_reg_status status;
  rand uart_reg_rdata rdata;
  rand uart_reg_wdata wdata;
  rand uart_reg_fifo_ctrl fifo_ctrl;
  rand uart_reg_fifo_status fifo_status;
  rand uart_reg_ovrd ovrd;
  rand uart_reg_val val;
  rand uart_reg_timeout_ctrl timeout_ctrl;

  `uvm_object_utils(uart_reg_block)

  function new(string name = "uart_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    intr_state = uart_reg_intr_state::type_id::create("intr_state");
    intr_state.configure(.blk_parent(this));
    intr_state.build();
    default_map.add_reg(.rg(intr_state),
                        .offset(32'h0),
                        .rights("RW"));
    intr_enable = uart_reg_intr_enable::type_id::create("intr_enable");
    intr_enable.configure(.blk_parent(this));
    intr_enable.build();
    default_map.add_reg(.rg(intr_enable),
                        .offset(32'h4),
                        .rights("RW"));
    intr_test = uart_reg_intr_test::type_id::create("intr_test");
    intr_test.configure(.blk_parent(this));
    intr_test.build();
    default_map.add_reg(.rg(intr_test),
                        .offset(32'h8),
                        .rights("WO"));
    ctrl = uart_reg_ctrl::type_id::create("ctrl");
    ctrl.configure(.blk_parent(this));
    ctrl.build();
    default_map.add_reg(.rg(ctrl),
                        .offset(32'hc),
                        .rights("RW"));
    status = uart_reg_status::type_id::create("status");
    status.configure(.blk_parent(this));
    status.build();
    default_map.add_reg(.rg(status),
                        .offset(32'h10),
                        .rights("RO"));
    rdata = uart_reg_rdata::type_id::create("rdata");
    rdata.configure(.blk_parent(this));
    rdata.build();
    default_map.add_reg(.rg(rdata),
                        .offset(32'h14),
                        .rights("RO"));
    wdata = uart_reg_wdata::type_id::create("wdata");
    wdata.configure(.blk_parent(this));
    wdata.build();
    default_map.add_reg(.rg(wdata),
                        .offset(32'h18),
                        .rights("WO"));
    fifo_ctrl = uart_reg_fifo_ctrl::type_id::create("fifo_ctrl");
    fifo_ctrl.configure(.blk_parent(this));
    fifo_ctrl.build();
    default_map.add_reg(.rg(fifo_ctrl),
                        .offset(32'h1c),
                        .rights("RW"));
    fifo_status = uart_reg_fifo_status::type_id::create("fifo_status");
    fifo_status.configure(.blk_parent(this));
    fifo_status.build();
    default_map.add_reg(.rg(fifo_status),
                        .offset(32'h20),
                        .rights("RO"));
    ovrd = uart_reg_ovrd::type_id::create("ovrd");
    ovrd.configure(.blk_parent(this));
    ovrd.build();
    default_map.add_reg(.rg(ovrd),
                        .offset(32'h24),
                        .rights("RW"));
    val = uart_reg_val::type_id::create("val");
    val.configure(.blk_parent(this));
    val.build();
    default_map.add_reg(.rg(val),
                        .offset(32'h28),
                        .rights("RO"));
    timeout_ctrl = uart_reg_timeout_ctrl::type_id::create("timeout_ctrl");
    timeout_ctrl.configure(.blk_parent(this));
    timeout_ctrl.build();
    default_map.add_reg(.rg(timeout_ctrl),
                        .offset(32'h2c),
                        .rights("RW"));
  endfunction : build

endclass : uart_reg_block

// Block: rv_plic
// Class: rv_plic_reg_ip0
class rv_plic_reg_ip0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field p0;
  rand dv_base_reg_field p1;
  rand dv_base_reg_field p2;
  rand dv_base_reg_field p3;
  rand dv_base_reg_field p4;
  rand dv_base_reg_field p5;
  rand dv_base_reg_field p6;
  rand dv_base_reg_field p7;
  rand dv_base_reg_field p8;
  rand dv_base_reg_field p9;
  rand dv_base_reg_field p10;
  rand dv_base_reg_field p11;
  rand dv_base_reg_field p12;
  rand dv_base_reg_field p13;
  rand dv_base_reg_field p14;
  rand dv_base_reg_field p15;
  rand dv_base_reg_field p16;
  rand dv_base_reg_field p17;
  rand dv_base_reg_field p18;
  rand dv_base_reg_field p19;
  rand dv_base_reg_field p20;
  rand dv_base_reg_field p21;
  rand dv_base_reg_field p22;
  rand dv_base_reg_field p23;
  rand dv_base_reg_field p24;
  rand dv_base_reg_field p25;
  rand dv_base_reg_field p26;
  rand dv_base_reg_field p27;
  rand dv_base_reg_field p28;
  rand dv_base_reg_field p29;
  rand dv_base_reg_field p30;
  rand dv_base_reg_field p31;

  `uvm_object_utils(rv_plic_reg_ip0)

  function new(string       name = "rv_plic_reg_ip0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    p0 = dv_base_reg_field::type_id::create("p0");
    p0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p1 = dv_base_reg_field::type_id::create("p1");
    p1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p2 = dv_base_reg_field::type_id::create("p2");
    p2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p3 = dv_base_reg_field::type_id::create("p3");
    p3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p4 = dv_base_reg_field::type_id::create("p4");
    p4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p5 = dv_base_reg_field::type_id::create("p5");
    p5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p6 = dv_base_reg_field::type_id::create("p6");
    p6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p7 = dv_base_reg_field::type_id::create("p7");
    p7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p8 = dv_base_reg_field::type_id::create("p8");
    p8.configure(
      .parent(this),
      .size(1),
      .lsb_pos(8),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p9 = dv_base_reg_field::type_id::create("p9");
    p9.configure(
      .parent(this),
      .size(1),
      .lsb_pos(9),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p10 = dv_base_reg_field::type_id::create("p10");
    p10.configure(
      .parent(this),
      .size(1),
      .lsb_pos(10),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p11 = dv_base_reg_field::type_id::create("p11");
    p11.configure(
      .parent(this),
      .size(1),
      .lsb_pos(11),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p12 = dv_base_reg_field::type_id::create("p12");
    p12.configure(
      .parent(this),
      .size(1),
      .lsb_pos(12),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p13 = dv_base_reg_field::type_id::create("p13");
    p13.configure(
      .parent(this),
      .size(1),
      .lsb_pos(13),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p14 = dv_base_reg_field::type_id::create("p14");
    p14.configure(
      .parent(this),
      .size(1),
      .lsb_pos(14),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p15 = dv_base_reg_field::type_id::create("p15");
    p15.configure(
      .parent(this),
      .size(1),
      .lsb_pos(15),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p16 = dv_base_reg_field::type_id::create("p16");
    p16.configure(
      .parent(this),
      .size(1),
      .lsb_pos(16),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p17 = dv_base_reg_field::type_id::create("p17");
    p17.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p18 = dv_base_reg_field::type_id::create("p18");
    p18.configure(
      .parent(this),
      .size(1),
      .lsb_pos(18),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p19 = dv_base_reg_field::type_id::create("p19");
    p19.configure(
      .parent(this),
      .size(1),
      .lsb_pos(19),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p20 = dv_base_reg_field::type_id::create("p20");
    p20.configure(
      .parent(this),
      .size(1),
      .lsb_pos(20),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p21 = dv_base_reg_field::type_id::create("p21");
    p21.configure(
      .parent(this),
      .size(1),
      .lsb_pos(21),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p22 = dv_base_reg_field::type_id::create("p22");
    p22.configure(
      .parent(this),
      .size(1),
      .lsb_pos(22),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p23 = dv_base_reg_field::type_id::create("p23");
    p23.configure(
      .parent(this),
      .size(1),
      .lsb_pos(23),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p24 = dv_base_reg_field::type_id::create("p24");
    p24.configure(
      .parent(this),
      .size(1),
      .lsb_pos(24),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p25 = dv_base_reg_field::type_id::create("p25");
    p25.configure(
      .parent(this),
      .size(1),
      .lsb_pos(25),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p26 = dv_base_reg_field::type_id::create("p26");
    p26.configure(
      .parent(this),
      .size(1),
      .lsb_pos(26),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p27 = dv_base_reg_field::type_id::create("p27");
    p27.configure(
      .parent(this),
      .size(1),
      .lsb_pos(27),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p28 = dv_base_reg_field::type_id::create("p28");
    p28.configure(
      .parent(this),
      .size(1),
      .lsb_pos(28),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p29 = dv_base_reg_field::type_id::create("p29");
    p29.configure(
      .parent(this),
      .size(1),
      .lsb_pos(29),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p30 = dv_base_reg_field::type_id::create("p30");
    p30.configure(
      .parent(this),
      .size(1),
      .lsb_pos(30),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p31 = dv_base_reg_field::type_id::create("p31");
    p31.configure(
      .parent(this),
      .size(1),
      .lsb_pos(31),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_ip0

// Class: rv_plic_reg_ip1
class rv_plic_reg_ip1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field p32;
  rand dv_base_reg_field p33;
  rand dv_base_reg_field p34;
  rand dv_base_reg_field p35;
  rand dv_base_reg_field p36;
  rand dv_base_reg_field p37;
  rand dv_base_reg_field p38;
  rand dv_base_reg_field p39;
  rand dv_base_reg_field p40;
  rand dv_base_reg_field p41;
  rand dv_base_reg_field p42;
  rand dv_base_reg_field p43;
  rand dv_base_reg_field p44;
  rand dv_base_reg_field p45;
  rand dv_base_reg_field p46;
  rand dv_base_reg_field p47;
  rand dv_base_reg_field p48;
  rand dv_base_reg_field p49;
  rand dv_base_reg_field p50;
  rand dv_base_reg_field p51;
  rand dv_base_reg_field p52;
  rand dv_base_reg_field p53;

  `uvm_object_utils(rv_plic_reg_ip1)

  function new(string       name = "rv_plic_reg_ip1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    p32 = dv_base_reg_field::type_id::create("p32");
    p32.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p33 = dv_base_reg_field::type_id::create("p33");
    p33.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p34 = dv_base_reg_field::type_id::create("p34");
    p34.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p35 = dv_base_reg_field::type_id::create("p35");
    p35.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p36 = dv_base_reg_field::type_id::create("p36");
    p36.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p37 = dv_base_reg_field::type_id::create("p37");
    p37.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p38 = dv_base_reg_field::type_id::create("p38");
    p38.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p39 = dv_base_reg_field::type_id::create("p39");
    p39.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p40 = dv_base_reg_field::type_id::create("p40");
    p40.configure(
      .parent(this),
      .size(1),
      .lsb_pos(8),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p41 = dv_base_reg_field::type_id::create("p41");
    p41.configure(
      .parent(this),
      .size(1),
      .lsb_pos(9),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p42 = dv_base_reg_field::type_id::create("p42");
    p42.configure(
      .parent(this),
      .size(1),
      .lsb_pos(10),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p43 = dv_base_reg_field::type_id::create("p43");
    p43.configure(
      .parent(this),
      .size(1),
      .lsb_pos(11),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p44 = dv_base_reg_field::type_id::create("p44");
    p44.configure(
      .parent(this),
      .size(1),
      .lsb_pos(12),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p45 = dv_base_reg_field::type_id::create("p45");
    p45.configure(
      .parent(this),
      .size(1),
      .lsb_pos(13),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p46 = dv_base_reg_field::type_id::create("p46");
    p46.configure(
      .parent(this),
      .size(1),
      .lsb_pos(14),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p47 = dv_base_reg_field::type_id::create("p47");
    p47.configure(
      .parent(this),
      .size(1),
      .lsb_pos(15),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p48 = dv_base_reg_field::type_id::create("p48");
    p48.configure(
      .parent(this),
      .size(1),
      .lsb_pos(16),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p49 = dv_base_reg_field::type_id::create("p49");
    p49.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p50 = dv_base_reg_field::type_id::create("p50");
    p50.configure(
      .parent(this),
      .size(1),
      .lsb_pos(18),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p51 = dv_base_reg_field::type_id::create("p51");
    p51.configure(
      .parent(this),
      .size(1),
      .lsb_pos(19),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p52 = dv_base_reg_field::type_id::create("p52");
    p52.configure(
      .parent(this),
      .size(1),
      .lsb_pos(20),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    p53 = dv_base_reg_field::type_id::create("p53");
    p53.configure(
      .parent(this),
      .size(1),
      .lsb_pos(21),
      .access("RO"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_ip1

// Class: rv_plic_reg_le0
class rv_plic_reg_le0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field le0;
  rand dv_base_reg_field le1;
  rand dv_base_reg_field le2;
  rand dv_base_reg_field le3;
  rand dv_base_reg_field le4;
  rand dv_base_reg_field le5;
  rand dv_base_reg_field le6;
  rand dv_base_reg_field le7;
  rand dv_base_reg_field le8;
  rand dv_base_reg_field le9;
  rand dv_base_reg_field le10;
  rand dv_base_reg_field le11;
  rand dv_base_reg_field le12;
  rand dv_base_reg_field le13;
  rand dv_base_reg_field le14;
  rand dv_base_reg_field le15;
  rand dv_base_reg_field le16;
  rand dv_base_reg_field le17;
  rand dv_base_reg_field le18;
  rand dv_base_reg_field le19;
  rand dv_base_reg_field le20;
  rand dv_base_reg_field le21;
  rand dv_base_reg_field le22;
  rand dv_base_reg_field le23;
  rand dv_base_reg_field le24;
  rand dv_base_reg_field le25;
  rand dv_base_reg_field le26;
  rand dv_base_reg_field le27;
  rand dv_base_reg_field le28;
  rand dv_base_reg_field le29;
  rand dv_base_reg_field le30;
  rand dv_base_reg_field le31;

  `uvm_object_utils(rv_plic_reg_le0)

  function new(string       name = "rv_plic_reg_le0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    le0 = dv_base_reg_field::type_id::create("le0");
    le0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le1 = dv_base_reg_field::type_id::create("le1");
    le1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le2 = dv_base_reg_field::type_id::create("le2");
    le2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le3 = dv_base_reg_field::type_id::create("le3");
    le3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le4 = dv_base_reg_field::type_id::create("le4");
    le4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le5 = dv_base_reg_field::type_id::create("le5");
    le5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le6 = dv_base_reg_field::type_id::create("le6");
    le6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le7 = dv_base_reg_field::type_id::create("le7");
    le7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le8 = dv_base_reg_field::type_id::create("le8");
    le8.configure(
      .parent(this),
      .size(1),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le9 = dv_base_reg_field::type_id::create("le9");
    le9.configure(
      .parent(this),
      .size(1),
      .lsb_pos(9),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le10 = dv_base_reg_field::type_id::create("le10");
    le10.configure(
      .parent(this),
      .size(1),
      .lsb_pos(10),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le11 = dv_base_reg_field::type_id::create("le11");
    le11.configure(
      .parent(this),
      .size(1),
      .lsb_pos(11),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le12 = dv_base_reg_field::type_id::create("le12");
    le12.configure(
      .parent(this),
      .size(1),
      .lsb_pos(12),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le13 = dv_base_reg_field::type_id::create("le13");
    le13.configure(
      .parent(this),
      .size(1),
      .lsb_pos(13),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le14 = dv_base_reg_field::type_id::create("le14");
    le14.configure(
      .parent(this),
      .size(1),
      .lsb_pos(14),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le15 = dv_base_reg_field::type_id::create("le15");
    le15.configure(
      .parent(this),
      .size(1),
      .lsb_pos(15),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le16 = dv_base_reg_field::type_id::create("le16");
    le16.configure(
      .parent(this),
      .size(1),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le17 = dv_base_reg_field::type_id::create("le17");
    le17.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le18 = dv_base_reg_field::type_id::create("le18");
    le18.configure(
      .parent(this),
      .size(1),
      .lsb_pos(18),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le19 = dv_base_reg_field::type_id::create("le19");
    le19.configure(
      .parent(this),
      .size(1),
      .lsb_pos(19),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le20 = dv_base_reg_field::type_id::create("le20");
    le20.configure(
      .parent(this),
      .size(1),
      .lsb_pos(20),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le21 = dv_base_reg_field::type_id::create("le21");
    le21.configure(
      .parent(this),
      .size(1),
      .lsb_pos(21),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le22 = dv_base_reg_field::type_id::create("le22");
    le22.configure(
      .parent(this),
      .size(1),
      .lsb_pos(22),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le23 = dv_base_reg_field::type_id::create("le23");
    le23.configure(
      .parent(this),
      .size(1),
      .lsb_pos(23),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le24 = dv_base_reg_field::type_id::create("le24");
    le24.configure(
      .parent(this),
      .size(1),
      .lsb_pos(24),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le25 = dv_base_reg_field::type_id::create("le25");
    le25.configure(
      .parent(this),
      .size(1),
      .lsb_pos(25),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le26 = dv_base_reg_field::type_id::create("le26");
    le26.configure(
      .parent(this),
      .size(1),
      .lsb_pos(26),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le27 = dv_base_reg_field::type_id::create("le27");
    le27.configure(
      .parent(this),
      .size(1),
      .lsb_pos(27),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le28 = dv_base_reg_field::type_id::create("le28");
    le28.configure(
      .parent(this),
      .size(1),
      .lsb_pos(28),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le29 = dv_base_reg_field::type_id::create("le29");
    le29.configure(
      .parent(this),
      .size(1),
      .lsb_pos(29),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le30 = dv_base_reg_field::type_id::create("le30");
    le30.configure(
      .parent(this),
      .size(1),
      .lsb_pos(30),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le31 = dv_base_reg_field::type_id::create("le31");
    le31.configure(
      .parent(this),
      .size(1),
      .lsb_pos(31),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_le0

// Class: rv_plic_reg_le1
class rv_plic_reg_le1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field le32;
  rand dv_base_reg_field le33;
  rand dv_base_reg_field le34;
  rand dv_base_reg_field le35;
  rand dv_base_reg_field le36;
  rand dv_base_reg_field le37;
  rand dv_base_reg_field le38;
  rand dv_base_reg_field le39;
  rand dv_base_reg_field le40;
  rand dv_base_reg_field le41;
  rand dv_base_reg_field le42;
  rand dv_base_reg_field le43;
  rand dv_base_reg_field le44;
  rand dv_base_reg_field le45;
  rand dv_base_reg_field le46;
  rand dv_base_reg_field le47;
  rand dv_base_reg_field le48;
  rand dv_base_reg_field le49;
  rand dv_base_reg_field le50;
  rand dv_base_reg_field le51;
  rand dv_base_reg_field le52;
  rand dv_base_reg_field le53;

  `uvm_object_utils(rv_plic_reg_le1)

  function new(string       name = "rv_plic_reg_le1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    le32 = dv_base_reg_field::type_id::create("le32");
    le32.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le33 = dv_base_reg_field::type_id::create("le33");
    le33.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le34 = dv_base_reg_field::type_id::create("le34");
    le34.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le35 = dv_base_reg_field::type_id::create("le35");
    le35.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le36 = dv_base_reg_field::type_id::create("le36");
    le36.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le37 = dv_base_reg_field::type_id::create("le37");
    le37.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le38 = dv_base_reg_field::type_id::create("le38");
    le38.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le39 = dv_base_reg_field::type_id::create("le39");
    le39.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le40 = dv_base_reg_field::type_id::create("le40");
    le40.configure(
      .parent(this),
      .size(1),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le41 = dv_base_reg_field::type_id::create("le41");
    le41.configure(
      .parent(this),
      .size(1),
      .lsb_pos(9),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le42 = dv_base_reg_field::type_id::create("le42");
    le42.configure(
      .parent(this),
      .size(1),
      .lsb_pos(10),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le43 = dv_base_reg_field::type_id::create("le43");
    le43.configure(
      .parent(this),
      .size(1),
      .lsb_pos(11),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le44 = dv_base_reg_field::type_id::create("le44");
    le44.configure(
      .parent(this),
      .size(1),
      .lsb_pos(12),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le45 = dv_base_reg_field::type_id::create("le45");
    le45.configure(
      .parent(this),
      .size(1),
      .lsb_pos(13),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le46 = dv_base_reg_field::type_id::create("le46");
    le46.configure(
      .parent(this),
      .size(1),
      .lsb_pos(14),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le47 = dv_base_reg_field::type_id::create("le47");
    le47.configure(
      .parent(this),
      .size(1),
      .lsb_pos(15),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le48 = dv_base_reg_field::type_id::create("le48");
    le48.configure(
      .parent(this),
      .size(1),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le49 = dv_base_reg_field::type_id::create("le49");
    le49.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le50 = dv_base_reg_field::type_id::create("le50");
    le50.configure(
      .parent(this),
      .size(1),
      .lsb_pos(18),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le51 = dv_base_reg_field::type_id::create("le51");
    le51.configure(
      .parent(this),
      .size(1),
      .lsb_pos(19),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le52 = dv_base_reg_field::type_id::create("le52");
    le52.configure(
      .parent(this),
      .size(1),
      .lsb_pos(20),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    le53 = dv_base_reg_field::type_id::create("le53");
    le53.configure(
      .parent(this),
      .size(1),
      .lsb_pos(21),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_le1

// Class: rv_plic_reg_prio0
class rv_plic_reg_prio0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio0;

  `uvm_object_utils(rv_plic_reg_prio0)

  function new(string       name = "rv_plic_reg_prio0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio0 = dv_base_reg_field::type_id::create("prio0");
    prio0.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio0

// Class: rv_plic_reg_prio1
class rv_plic_reg_prio1 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio1;

  `uvm_object_utils(rv_plic_reg_prio1)

  function new(string       name = "rv_plic_reg_prio1",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio1 = dv_base_reg_field::type_id::create("prio1");
    prio1.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio1

// Class: rv_plic_reg_prio2
class rv_plic_reg_prio2 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio2;

  `uvm_object_utils(rv_plic_reg_prio2)

  function new(string       name = "rv_plic_reg_prio2",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio2 = dv_base_reg_field::type_id::create("prio2");
    prio2.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio2

// Class: rv_plic_reg_prio3
class rv_plic_reg_prio3 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio3;

  `uvm_object_utils(rv_plic_reg_prio3)

  function new(string       name = "rv_plic_reg_prio3",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio3 = dv_base_reg_field::type_id::create("prio3");
    prio3.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio3

// Class: rv_plic_reg_prio4
class rv_plic_reg_prio4 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio4;

  `uvm_object_utils(rv_plic_reg_prio4)

  function new(string       name = "rv_plic_reg_prio4",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio4 = dv_base_reg_field::type_id::create("prio4");
    prio4.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio4

// Class: rv_plic_reg_prio5
class rv_plic_reg_prio5 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio5;

  `uvm_object_utils(rv_plic_reg_prio5)

  function new(string       name = "rv_plic_reg_prio5",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio5 = dv_base_reg_field::type_id::create("prio5");
    prio5.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio5

// Class: rv_plic_reg_prio6
class rv_plic_reg_prio6 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio6;

  `uvm_object_utils(rv_plic_reg_prio6)

  function new(string       name = "rv_plic_reg_prio6",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio6 = dv_base_reg_field::type_id::create("prio6");
    prio6.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio6

// Class: rv_plic_reg_prio7
class rv_plic_reg_prio7 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio7;

  `uvm_object_utils(rv_plic_reg_prio7)

  function new(string       name = "rv_plic_reg_prio7",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio7 = dv_base_reg_field::type_id::create("prio7");
    prio7.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio7

// Class: rv_plic_reg_prio8
class rv_plic_reg_prio8 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio8;

  `uvm_object_utils(rv_plic_reg_prio8)

  function new(string       name = "rv_plic_reg_prio8",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio8 = dv_base_reg_field::type_id::create("prio8");
    prio8.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio8

// Class: rv_plic_reg_prio9
class rv_plic_reg_prio9 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio9;

  `uvm_object_utils(rv_plic_reg_prio9)

  function new(string       name = "rv_plic_reg_prio9",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio9 = dv_base_reg_field::type_id::create("prio9");
    prio9.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio9

// Class: rv_plic_reg_prio10
class rv_plic_reg_prio10 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio10;

  `uvm_object_utils(rv_plic_reg_prio10)

  function new(string       name = "rv_plic_reg_prio10",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio10 = dv_base_reg_field::type_id::create("prio10");
    prio10.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio10

// Class: rv_plic_reg_prio11
class rv_plic_reg_prio11 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio11;

  `uvm_object_utils(rv_plic_reg_prio11)

  function new(string       name = "rv_plic_reg_prio11",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio11 = dv_base_reg_field::type_id::create("prio11");
    prio11.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio11

// Class: rv_plic_reg_prio12
class rv_plic_reg_prio12 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio12;

  `uvm_object_utils(rv_plic_reg_prio12)

  function new(string       name = "rv_plic_reg_prio12",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio12 = dv_base_reg_field::type_id::create("prio12");
    prio12.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio12

// Class: rv_plic_reg_prio13
class rv_plic_reg_prio13 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio13;

  `uvm_object_utils(rv_plic_reg_prio13)

  function new(string       name = "rv_plic_reg_prio13",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio13 = dv_base_reg_field::type_id::create("prio13");
    prio13.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio13

// Class: rv_plic_reg_prio14
class rv_plic_reg_prio14 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio14;

  `uvm_object_utils(rv_plic_reg_prio14)

  function new(string       name = "rv_plic_reg_prio14",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio14 = dv_base_reg_field::type_id::create("prio14");
    prio14.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio14

// Class: rv_plic_reg_prio15
class rv_plic_reg_prio15 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio15;

  `uvm_object_utils(rv_plic_reg_prio15)

  function new(string       name = "rv_plic_reg_prio15",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio15 = dv_base_reg_field::type_id::create("prio15");
    prio15.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio15

// Class: rv_plic_reg_prio16
class rv_plic_reg_prio16 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio16;

  `uvm_object_utils(rv_plic_reg_prio16)

  function new(string       name = "rv_plic_reg_prio16",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio16 = dv_base_reg_field::type_id::create("prio16");
    prio16.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio16

// Class: rv_plic_reg_prio17
class rv_plic_reg_prio17 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio17;

  `uvm_object_utils(rv_plic_reg_prio17)

  function new(string       name = "rv_plic_reg_prio17",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio17 = dv_base_reg_field::type_id::create("prio17");
    prio17.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio17

// Class: rv_plic_reg_prio18
class rv_plic_reg_prio18 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio18;

  `uvm_object_utils(rv_plic_reg_prio18)

  function new(string       name = "rv_plic_reg_prio18",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio18 = dv_base_reg_field::type_id::create("prio18");
    prio18.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio18

// Class: rv_plic_reg_prio19
class rv_plic_reg_prio19 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio19;

  `uvm_object_utils(rv_plic_reg_prio19)

  function new(string       name = "rv_plic_reg_prio19",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio19 = dv_base_reg_field::type_id::create("prio19");
    prio19.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio19

// Class: rv_plic_reg_prio20
class rv_plic_reg_prio20 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio20;

  `uvm_object_utils(rv_plic_reg_prio20)

  function new(string       name = "rv_plic_reg_prio20",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio20 = dv_base_reg_field::type_id::create("prio20");
    prio20.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio20

// Class: rv_plic_reg_prio21
class rv_plic_reg_prio21 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio21;

  `uvm_object_utils(rv_plic_reg_prio21)

  function new(string       name = "rv_plic_reg_prio21",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio21 = dv_base_reg_field::type_id::create("prio21");
    prio21.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio21

// Class: rv_plic_reg_prio22
class rv_plic_reg_prio22 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio22;

  `uvm_object_utils(rv_plic_reg_prio22)

  function new(string       name = "rv_plic_reg_prio22",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio22 = dv_base_reg_field::type_id::create("prio22");
    prio22.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio22

// Class: rv_plic_reg_prio23
class rv_plic_reg_prio23 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio23;

  `uvm_object_utils(rv_plic_reg_prio23)

  function new(string       name = "rv_plic_reg_prio23",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio23 = dv_base_reg_field::type_id::create("prio23");
    prio23.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio23

// Class: rv_plic_reg_prio24
class rv_plic_reg_prio24 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio24;

  `uvm_object_utils(rv_plic_reg_prio24)

  function new(string       name = "rv_plic_reg_prio24",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio24 = dv_base_reg_field::type_id::create("prio24");
    prio24.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio24

// Class: rv_plic_reg_prio25
class rv_plic_reg_prio25 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio25;

  `uvm_object_utils(rv_plic_reg_prio25)

  function new(string       name = "rv_plic_reg_prio25",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio25 = dv_base_reg_field::type_id::create("prio25");
    prio25.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio25

// Class: rv_plic_reg_prio26
class rv_plic_reg_prio26 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio26;

  `uvm_object_utils(rv_plic_reg_prio26)

  function new(string       name = "rv_plic_reg_prio26",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio26 = dv_base_reg_field::type_id::create("prio26");
    prio26.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio26

// Class: rv_plic_reg_prio27
class rv_plic_reg_prio27 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio27;

  `uvm_object_utils(rv_plic_reg_prio27)

  function new(string       name = "rv_plic_reg_prio27",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio27 = dv_base_reg_field::type_id::create("prio27");
    prio27.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio27

// Class: rv_plic_reg_prio28
class rv_plic_reg_prio28 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio28;

  `uvm_object_utils(rv_plic_reg_prio28)

  function new(string       name = "rv_plic_reg_prio28",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio28 = dv_base_reg_field::type_id::create("prio28");
    prio28.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio28

// Class: rv_plic_reg_prio29
class rv_plic_reg_prio29 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio29;

  `uvm_object_utils(rv_plic_reg_prio29)

  function new(string       name = "rv_plic_reg_prio29",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio29 = dv_base_reg_field::type_id::create("prio29");
    prio29.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio29

// Class: rv_plic_reg_prio30
class rv_plic_reg_prio30 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio30;

  `uvm_object_utils(rv_plic_reg_prio30)

  function new(string       name = "rv_plic_reg_prio30",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio30 = dv_base_reg_field::type_id::create("prio30");
    prio30.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio30

// Class: rv_plic_reg_prio31
class rv_plic_reg_prio31 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio31;

  `uvm_object_utils(rv_plic_reg_prio31)

  function new(string       name = "rv_plic_reg_prio31",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio31 = dv_base_reg_field::type_id::create("prio31");
    prio31.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio31

// Class: rv_plic_reg_prio32
class rv_plic_reg_prio32 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio32;

  `uvm_object_utils(rv_plic_reg_prio32)

  function new(string       name = "rv_plic_reg_prio32",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio32 = dv_base_reg_field::type_id::create("prio32");
    prio32.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio32

// Class: rv_plic_reg_prio33
class rv_plic_reg_prio33 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio33;

  `uvm_object_utils(rv_plic_reg_prio33)

  function new(string       name = "rv_plic_reg_prio33",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio33 = dv_base_reg_field::type_id::create("prio33");
    prio33.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio33

// Class: rv_plic_reg_prio34
class rv_plic_reg_prio34 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio34;

  `uvm_object_utils(rv_plic_reg_prio34)

  function new(string       name = "rv_plic_reg_prio34",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio34 = dv_base_reg_field::type_id::create("prio34");
    prio34.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio34

// Class: rv_plic_reg_prio35
class rv_plic_reg_prio35 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio35;

  `uvm_object_utils(rv_plic_reg_prio35)

  function new(string       name = "rv_plic_reg_prio35",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio35 = dv_base_reg_field::type_id::create("prio35");
    prio35.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio35

// Class: rv_plic_reg_prio36
class rv_plic_reg_prio36 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio36;

  `uvm_object_utils(rv_plic_reg_prio36)

  function new(string       name = "rv_plic_reg_prio36",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio36 = dv_base_reg_field::type_id::create("prio36");
    prio36.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio36

// Class: rv_plic_reg_prio37
class rv_plic_reg_prio37 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio37;

  `uvm_object_utils(rv_plic_reg_prio37)

  function new(string       name = "rv_plic_reg_prio37",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio37 = dv_base_reg_field::type_id::create("prio37");
    prio37.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio37

// Class: rv_plic_reg_prio38
class rv_plic_reg_prio38 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio38;

  `uvm_object_utils(rv_plic_reg_prio38)

  function new(string       name = "rv_plic_reg_prio38",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio38 = dv_base_reg_field::type_id::create("prio38");
    prio38.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio38

// Class: rv_plic_reg_prio39
class rv_plic_reg_prio39 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio39;

  `uvm_object_utils(rv_plic_reg_prio39)

  function new(string       name = "rv_plic_reg_prio39",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio39 = dv_base_reg_field::type_id::create("prio39");
    prio39.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio39

// Class: rv_plic_reg_prio40
class rv_plic_reg_prio40 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio40;

  `uvm_object_utils(rv_plic_reg_prio40)

  function new(string       name = "rv_plic_reg_prio40",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio40 = dv_base_reg_field::type_id::create("prio40");
    prio40.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio40

// Class: rv_plic_reg_prio41
class rv_plic_reg_prio41 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio41;

  `uvm_object_utils(rv_plic_reg_prio41)

  function new(string       name = "rv_plic_reg_prio41",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio41 = dv_base_reg_field::type_id::create("prio41");
    prio41.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio41

// Class: rv_plic_reg_prio42
class rv_plic_reg_prio42 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio42;

  `uvm_object_utils(rv_plic_reg_prio42)

  function new(string       name = "rv_plic_reg_prio42",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio42 = dv_base_reg_field::type_id::create("prio42");
    prio42.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio42

// Class: rv_plic_reg_prio43
class rv_plic_reg_prio43 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio43;

  `uvm_object_utils(rv_plic_reg_prio43)

  function new(string       name = "rv_plic_reg_prio43",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio43 = dv_base_reg_field::type_id::create("prio43");
    prio43.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio43

// Class: rv_plic_reg_prio44
class rv_plic_reg_prio44 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio44;

  `uvm_object_utils(rv_plic_reg_prio44)

  function new(string       name = "rv_plic_reg_prio44",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio44 = dv_base_reg_field::type_id::create("prio44");
    prio44.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio44

// Class: rv_plic_reg_prio45
class rv_plic_reg_prio45 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio45;

  `uvm_object_utils(rv_plic_reg_prio45)

  function new(string       name = "rv_plic_reg_prio45",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio45 = dv_base_reg_field::type_id::create("prio45");
    prio45.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio45

// Class: rv_plic_reg_prio46
class rv_plic_reg_prio46 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio46;

  `uvm_object_utils(rv_plic_reg_prio46)

  function new(string       name = "rv_plic_reg_prio46",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio46 = dv_base_reg_field::type_id::create("prio46");
    prio46.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio46

// Class: rv_plic_reg_prio47
class rv_plic_reg_prio47 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio47;

  `uvm_object_utils(rv_plic_reg_prio47)

  function new(string       name = "rv_plic_reg_prio47",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio47 = dv_base_reg_field::type_id::create("prio47");
    prio47.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio47

// Class: rv_plic_reg_prio48
class rv_plic_reg_prio48 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio48;

  `uvm_object_utils(rv_plic_reg_prio48)

  function new(string       name = "rv_plic_reg_prio48",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio48 = dv_base_reg_field::type_id::create("prio48");
    prio48.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio48

// Class: rv_plic_reg_prio49
class rv_plic_reg_prio49 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio49;

  `uvm_object_utils(rv_plic_reg_prio49)

  function new(string       name = "rv_plic_reg_prio49",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio49 = dv_base_reg_field::type_id::create("prio49");
    prio49.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio49

// Class: rv_plic_reg_prio50
class rv_plic_reg_prio50 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio50;

  `uvm_object_utils(rv_plic_reg_prio50)

  function new(string       name = "rv_plic_reg_prio50",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio50 = dv_base_reg_field::type_id::create("prio50");
    prio50.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio50

// Class: rv_plic_reg_prio51
class rv_plic_reg_prio51 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio51;

  `uvm_object_utils(rv_plic_reg_prio51)

  function new(string       name = "rv_plic_reg_prio51",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio51 = dv_base_reg_field::type_id::create("prio51");
    prio51.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio51

// Class: rv_plic_reg_prio52
class rv_plic_reg_prio52 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio52;

  `uvm_object_utils(rv_plic_reg_prio52)

  function new(string       name = "rv_plic_reg_prio52",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio52 = dv_base_reg_field::type_id::create("prio52");
    prio52.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio52

// Class: rv_plic_reg_prio53
class rv_plic_reg_prio53 extends dv_base_reg;
  // fields
  rand dv_base_reg_field prio53;

  `uvm_object_utils(rv_plic_reg_prio53)

  function new(string       name = "rv_plic_reg_prio53",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    prio53 = dv_base_reg_field::type_id::create("prio53");
    prio53.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_prio53

// Class: rv_plic_reg_ie00
class rv_plic_reg_ie00 extends dv_base_reg;
  // fields
  rand dv_base_reg_field e0;
  rand dv_base_reg_field e1;
  rand dv_base_reg_field e2;
  rand dv_base_reg_field e3;
  rand dv_base_reg_field e4;
  rand dv_base_reg_field e5;
  rand dv_base_reg_field e6;
  rand dv_base_reg_field e7;
  rand dv_base_reg_field e8;
  rand dv_base_reg_field e9;
  rand dv_base_reg_field e10;
  rand dv_base_reg_field e11;
  rand dv_base_reg_field e12;
  rand dv_base_reg_field e13;
  rand dv_base_reg_field e14;
  rand dv_base_reg_field e15;
  rand dv_base_reg_field e16;
  rand dv_base_reg_field e17;
  rand dv_base_reg_field e18;
  rand dv_base_reg_field e19;
  rand dv_base_reg_field e20;
  rand dv_base_reg_field e21;
  rand dv_base_reg_field e22;
  rand dv_base_reg_field e23;
  rand dv_base_reg_field e24;
  rand dv_base_reg_field e25;
  rand dv_base_reg_field e26;
  rand dv_base_reg_field e27;
  rand dv_base_reg_field e28;
  rand dv_base_reg_field e29;
  rand dv_base_reg_field e30;
  rand dv_base_reg_field e31;

  `uvm_object_utils(rv_plic_reg_ie00)

  function new(string       name = "rv_plic_reg_ie00",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    e0 = dv_base_reg_field::type_id::create("e0");
    e0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e1 = dv_base_reg_field::type_id::create("e1");
    e1.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e2 = dv_base_reg_field::type_id::create("e2");
    e2.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e3 = dv_base_reg_field::type_id::create("e3");
    e3.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e4 = dv_base_reg_field::type_id::create("e4");
    e4.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e5 = dv_base_reg_field::type_id::create("e5");
    e5.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e6 = dv_base_reg_field::type_id::create("e6");
    e6.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e7 = dv_base_reg_field::type_id::create("e7");
    e7.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e8 = dv_base_reg_field::type_id::create("e8");
    e8.configure(
      .parent(this),
      .size(1),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e9 = dv_base_reg_field::type_id::create("e9");
    e9.configure(
      .parent(this),
      .size(1),
      .lsb_pos(9),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e10 = dv_base_reg_field::type_id::create("e10");
    e10.configure(
      .parent(this),
      .size(1),
      .lsb_pos(10),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e11 = dv_base_reg_field::type_id::create("e11");
    e11.configure(
      .parent(this),
      .size(1),
      .lsb_pos(11),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e12 = dv_base_reg_field::type_id::create("e12");
    e12.configure(
      .parent(this),
      .size(1),
      .lsb_pos(12),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e13 = dv_base_reg_field::type_id::create("e13");
    e13.configure(
      .parent(this),
      .size(1),
      .lsb_pos(13),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e14 = dv_base_reg_field::type_id::create("e14");
    e14.configure(
      .parent(this),
      .size(1),
      .lsb_pos(14),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e15 = dv_base_reg_field::type_id::create("e15");
    e15.configure(
      .parent(this),
      .size(1),
      .lsb_pos(15),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e16 = dv_base_reg_field::type_id::create("e16");
    e16.configure(
      .parent(this),
      .size(1),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e17 = dv_base_reg_field::type_id::create("e17");
    e17.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e18 = dv_base_reg_field::type_id::create("e18");
    e18.configure(
      .parent(this),
      .size(1),
      .lsb_pos(18),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e19 = dv_base_reg_field::type_id::create("e19");
    e19.configure(
      .parent(this),
      .size(1),
      .lsb_pos(19),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e20 = dv_base_reg_field::type_id::create("e20");
    e20.configure(
      .parent(this),
      .size(1),
      .lsb_pos(20),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e21 = dv_base_reg_field::type_id::create("e21");
    e21.configure(
      .parent(this),
      .size(1),
      .lsb_pos(21),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e22 = dv_base_reg_field::type_id::create("e22");
    e22.configure(
      .parent(this),
      .size(1),
      .lsb_pos(22),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e23 = dv_base_reg_field::type_id::create("e23");
    e23.configure(
      .parent(this),
      .size(1),
      .lsb_pos(23),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e24 = dv_base_reg_field::type_id::create("e24");
    e24.configure(
      .parent(this),
      .size(1),
      .lsb_pos(24),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e25 = dv_base_reg_field::type_id::create("e25");
    e25.configure(
      .parent(this),
      .size(1),
      .lsb_pos(25),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e26 = dv_base_reg_field::type_id::create("e26");
    e26.configure(
      .parent(this),
      .size(1),
      .lsb_pos(26),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e27 = dv_base_reg_field::type_id::create("e27");
    e27.configure(
      .parent(this),
      .size(1),
      .lsb_pos(27),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e28 = dv_base_reg_field::type_id::create("e28");
    e28.configure(
      .parent(this),
      .size(1),
      .lsb_pos(28),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e29 = dv_base_reg_field::type_id::create("e29");
    e29.configure(
      .parent(this),
      .size(1),
      .lsb_pos(29),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e30 = dv_base_reg_field::type_id::create("e30");
    e30.configure(
      .parent(this),
      .size(1),
      .lsb_pos(30),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e31 = dv_base_reg_field::type_id::create("e31");
    e31.configure(
      .parent(this),
      .size(1),
      .lsb_pos(31),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_ie00

// Class: rv_plic_reg_ie01
class rv_plic_reg_ie01 extends dv_base_reg;
  // fields
  rand dv_base_reg_field e32;
  rand dv_base_reg_field e33;
  rand dv_base_reg_field e34;
  rand dv_base_reg_field e35;
  rand dv_base_reg_field e36;
  rand dv_base_reg_field e37;
  rand dv_base_reg_field e38;
  rand dv_base_reg_field e39;
  rand dv_base_reg_field e40;
  rand dv_base_reg_field e41;
  rand dv_base_reg_field e42;
  rand dv_base_reg_field e43;
  rand dv_base_reg_field e44;
  rand dv_base_reg_field e45;
  rand dv_base_reg_field e46;
  rand dv_base_reg_field e47;
  rand dv_base_reg_field e48;
  rand dv_base_reg_field e49;
  rand dv_base_reg_field e50;
  rand dv_base_reg_field e51;
  rand dv_base_reg_field e52;
  rand dv_base_reg_field e53;

  `uvm_object_utils(rv_plic_reg_ie01)

  function new(string       name = "rv_plic_reg_ie01",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    e32 = dv_base_reg_field::type_id::create("e32");
    e32.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e33 = dv_base_reg_field::type_id::create("e33");
    e33.configure(
      .parent(this),
      .size(1),
      .lsb_pos(1),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e34 = dv_base_reg_field::type_id::create("e34");
    e34.configure(
      .parent(this),
      .size(1),
      .lsb_pos(2),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e35 = dv_base_reg_field::type_id::create("e35");
    e35.configure(
      .parent(this),
      .size(1),
      .lsb_pos(3),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e36 = dv_base_reg_field::type_id::create("e36");
    e36.configure(
      .parent(this),
      .size(1),
      .lsb_pos(4),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e37 = dv_base_reg_field::type_id::create("e37");
    e37.configure(
      .parent(this),
      .size(1),
      .lsb_pos(5),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e38 = dv_base_reg_field::type_id::create("e38");
    e38.configure(
      .parent(this),
      .size(1),
      .lsb_pos(6),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e39 = dv_base_reg_field::type_id::create("e39");
    e39.configure(
      .parent(this),
      .size(1),
      .lsb_pos(7),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e40 = dv_base_reg_field::type_id::create("e40");
    e40.configure(
      .parent(this),
      .size(1),
      .lsb_pos(8),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e41 = dv_base_reg_field::type_id::create("e41");
    e41.configure(
      .parent(this),
      .size(1),
      .lsb_pos(9),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e42 = dv_base_reg_field::type_id::create("e42");
    e42.configure(
      .parent(this),
      .size(1),
      .lsb_pos(10),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e43 = dv_base_reg_field::type_id::create("e43");
    e43.configure(
      .parent(this),
      .size(1),
      .lsb_pos(11),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e44 = dv_base_reg_field::type_id::create("e44");
    e44.configure(
      .parent(this),
      .size(1),
      .lsb_pos(12),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e45 = dv_base_reg_field::type_id::create("e45");
    e45.configure(
      .parent(this),
      .size(1),
      .lsb_pos(13),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e46 = dv_base_reg_field::type_id::create("e46");
    e46.configure(
      .parent(this),
      .size(1),
      .lsb_pos(14),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e47 = dv_base_reg_field::type_id::create("e47");
    e47.configure(
      .parent(this),
      .size(1),
      .lsb_pos(15),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e48 = dv_base_reg_field::type_id::create("e48");
    e48.configure(
      .parent(this),
      .size(1),
      .lsb_pos(16),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e49 = dv_base_reg_field::type_id::create("e49");
    e49.configure(
      .parent(this),
      .size(1),
      .lsb_pos(17),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e50 = dv_base_reg_field::type_id::create("e50");
    e50.configure(
      .parent(this),
      .size(1),
      .lsb_pos(18),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e51 = dv_base_reg_field::type_id::create("e51");
    e51.configure(
      .parent(this),
      .size(1),
      .lsb_pos(19),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e52 = dv_base_reg_field::type_id::create("e52");
    e52.configure(
      .parent(this),
      .size(1),
      .lsb_pos(20),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
    e53 = dv_base_reg_field::type_id::create("e53");
    e53.configure(
      .parent(this),
      .size(1),
      .lsb_pos(21),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_ie01

// Class: rv_plic_reg_threshold0
class rv_plic_reg_threshold0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field threshold0;

  `uvm_object_utils(rv_plic_reg_threshold0)

  function new(string       name = "rv_plic_reg_threshold0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    threshold0 = dv_base_reg_field::type_id::create("threshold0");
    threshold0.configure(
      .parent(this),
      .size(2),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_threshold0

// Class: rv_plic_reg_cc0
class rv_plic_reg_cc0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field cc0;

  `uvm_object_utils(rv_plic_reg_cc0)

  function new(string       name = "rv_plic_reg_cc0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    cc0 = dv_base_reg_field::type_id::create("cc0");
    cc0.configure(
      .parent(this),
      .size(6),
      .lsb_pos(0),
      .access("RW"),
      .volatile(1),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_cc0

// Class: rv_plic_reg_msip0
class rv_plic_reg_msip0 extends dv_base_reg;
  // fields
  rand dv_base_reg_field msip0;

  `uvm_object_utils(rv_plic_reg_msip0)

  function new(string       name = "rv_plic_reg_msip0",
               int unsigned n_bits = 32,
               int          has_coverage = UVM_NO_COVERAGE);
    super.new(name, n_bits, has_coverage);
  endfunction : new

  virtual function void build();
    // create fields
    msip0 = dv_base_reg_field::type_id::create("msip0");
    msip0.configure(
      .parent(this),
      .size(1),
      .lsb_pos(0),
      .access("RW"),
      .volatile(0),
      .reset(0),
      .has_reset(1),
      .is_rand(1),
      .individually_accessible(1));
  endfunction : build

endclass : rv_plic_reg_msip0

// Class: rv_plic_reg_block
class rv_plic_reg_block extends dv_base_reg_block;
  // registers
  rand rv_plic_reg_ip0 ip0;
  rand rv_plic_reg_ip1 ip1;
  rand rv_plic_reg_le0 le0;
  rand rv_plic_reg_le1 le1;
  rand rv_plic_reg_prio0 prio0;
  rand rv_plic_reg_prio1 prio1;
  rand rv_plic_reg_prio2 prio2;
  rand rv_plic_reg_prio3 prio3;
  rand rv_plic_reg_prio4 prio4;
  rand rv_plic_reg_prio5 prio5;
  rand rv_plic_reg_prio6 prio6;
  rand rv_plic_reg_prio7 prio7;
  rand rv_plic_reg_prio8 prio8;
  rand rv_plic_reg_prio9 prio9;
  rand rv_plic_reg_prio10 prio10;
  rand rv_plic_reg_prio11 prio11;
  rand rv_plic_reg_prio12 prio12;
  rand rv_plic_reg_prio13 prio13;
  rand rv_plic_reg_prio14 prio14;
  rand rv_plic_reg_prio15 prio15;
  rand rv_plic_reg_prio16 prio16;
  rand rv_plic_reg_prio17 prio17;
  rand rv_plic_reg_prio18 prio18;
  rand rv_plic_reg_prio19 prio19;
  rand rv_plic_reg_prio20 prio20;
  rand rv_plic_reg_prio21 prio21;
  rand rv_plic_reg_prio22 prio22;
  rand rv_plic_reg_prio23 prio23;
  rand rv_plic_reg_prio24 prio24;
  rand rv_plic_reg_prio25 prio25;
  rand rv_plic_reg_prio26 prio26;
  rand rv_plic_reg_prio27 prio27;
  rand rv_plic_reg_prio28 prio28;
  rand rv_plic_reg_prio29 prio29;
  rand rv_plic_reg_prio30 prio30;
  rand rv_plic_reg_prio31 prio31;
  rand rv_plic_reg_prio32 prio32;
  rand rv_plic_reg_prio33 prio33;
  rand rv_plic_reg_prio34 prio34;
  rand rv_plic_reg_prio35 prio35;
  rand rv_plic_reg_prio36 prio36;
  rand rv_plic_reg_prio37 prio37;
  rand rv_plic_reg_prio38 prio38;
  rand rv_plic_reg_prio39 prio39;
  rand rv_plic_reg_prio40 prio40;
  rand rv_plic_reg_prio41 prio41;
  rand rv_plic_reg_prio42 prio42;
  rand rv_plic_reg_prio43 prio43;
  rand rv_plic_reg_prio44 prio44;
  rand rv_plic_reg_prio45 prio45;
  rand rv_plic_reg_prio46 prio46;
  rand rv_plic_reg_prio47 prio47;
  rand rv_plic_reg_prio48 prio48;
  rand rv_plic_reg_prio49 prio49;
  rand rv_plic_reg_prio50 prio50;
  rand rv_plic_reg_prio51 prio51;
  rand rv_plic_reg_prio52 prio52;
  rand rv_plic_reg_prio53 prio53;
  rand rv_plic_reg_ie00 ie00;
  rand rv_plic_reg_ie01 ie01;
  rand rv_plic_reg_threshold0 threshold0;
  rand rv_plic_reg_cc0 cc0;
  rand rv_plic_reg_msip0 msip0;

  `uvm_object_utils(rv_plic_reg_block)

  function new(string name = "rv_plic_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create registers
    ip0 = rv_plic_reg_ip0::type_id::create("ip0");
    ip0.configure(.blk_parent(this));
    ip0.build();
    default_map.add_reg(.rg(ip0),
                        .offset(32'h0),
                        .rights("RO"));
    ip1 = rv_plic_reg_ip1::type_id::create("ip1");
    ip1.configure(.blk_parent(this));
    ip1.build();
    default_map.add_reg(.rg(ip1),
                        .offset(32'h4),
                        .rights("RO"));
    le0 = rv_plic_reg_le0::type_id::create("le0");
    le0.configure(.blk_parent(this));
    le0.build();
    default_map.add_reg(.rg(le0),
                        .offset(32'h8),
                        .rights("RW"));
    le1 = rv_plic_reg_le1::type_id::create("le1");
    le1.configure(.blk_parent(this));
    le1.build();
    default_map.add_reg(.rg(le1),
                        .offset(32'hc),
                        .rights("RW"));
    prio0 = rv_plic_reg_prio0::type_id::create("prio0");
    prio0.configure(.blk_parent(this));
    prio0.build();
    default_map.add_reg(.rg(prio0),
                        .offset(32'h10),
                        .rights("RW"));
    prio1 = rv_plic_reg_prio1::type_id::create("prio1");
    prio1.configure(.blk_parent(this));
    prio1.build();
    default_map.add_reg(.rg(prio1),
                        .offset(32'h14),
                        .rights("RW"));
    prio2 = rv_plic_reg_prio2::type_id::create("prio2");
    prio2.configure(.blk_parent(this));
    prio2.build();
    default_map.add_reg(.rg(prio2),
                        .offset(32'h18),
                        .rights("RW"));
    prio3 = rv_plic_reg_prio3::type_id::create("prio3");
    prio3.configure(.blk_parent(this));
    prio3.build();
    default_map.add_reg(.rg(prio3),
                        .offset(32'h1c),
                        .rights("RW"));
    prio4 = rv_plic_reg_prio4::type_id::create("prio4");
    prio4.configure(.blk_parent(this));
    prio4.build();
    default_map.add_reg(.rg(prio4),
                        .offset(32'h20),
                        .rights("RW"));
    prio5 = rv_plic_reg_prio5::type_id::create("prio5");
    prio5.configure(.blk_parent(this));
    prio5.build();
    default_map.add_reg(.rg(prio5),
                        .offset(32'h24),
                        .rights("RW"));
    prio6 = rv_plic_reg_prio6::type_id::create("prio6");
    prio6.configure(.blk_parent(this));
    prio6.build();
    default_map.add_reg(.rg(prio6),
                        .offset(32'h28),
                        .rights("RW"));
    prio7 = rv_plic_reg_prio7::type_id::create("prio7");
    prio7.configure(.blk_parent(this));
    prio7.build();
    default_map.add_reg(.rg(prio7),
                        .offset(32'h2c),
                        .rights("RW"));
    prio8 = rv_plic_reg_prio8::type_id::create("prio8");
    prio8.configure(.blk_parent(this));
    prio8.build();
    default_map.add_reg(.rg(prio8),
                        .offset(32'h30),
                        .rights("RW"));
    prio9 = rv_plic_reg_prio9::type_id::create("prio9");
    prio9.configure(.blk_parent(this));
    prio9.build();
    default_map.add_reg(.rg(prio9),
                        .offset(32'h34),
                        .rights("RW"));
    prio10 = rv_plic_reg_prio10::type_id::create("prio10");
    prio10.configure(.blk_parent(this));
    prio10.build();
    default_map.add_reg(.rg(prio10),
                        .offset(32'h38),
                        .rights("RW"));
    prio11 = rv_plic_reg_prio11::type_id::create("prio11");
    prio11.configure(.blk_parent(this));
    prio11.build();
    default_map.add_reg(.rg(prio11),
                        .offset(32'h3c),
                        .rights("RW"));
    prio12 = rv_plic_reg_prio12::type_id::create("prio12");
    prio12.configure(.blk_parent(this));
    prio12.build();
    default_map.add_reg(.rg(prio12),
                        .offset(32'h40),
                        .rights("RW"));
    prio13 = rv_plic_reg_prio13::type_id::create("prio13");
    prio13.configure(.blk_parent(this));
    prio13.build();
    default_map.add_reg(.rg(prio13),
                        .offset(32'h44),
                        .rights("RW"));
    prio14 = rv_plic_reg_prio14::type_id::create("prio14");
    prio14.configure(.blk_parent(this));
    prio14.build();
    default_map.add_reg(.rg(prio14),
                        .offset(32'h48),
                        .rights("RW"));
    prio15 = rv_plic_reg_prio15::type_id::create("prio15");
    prio15.configure(.blk_parent(this));
    prio15.build();
    default_map.add_reg(.rg(prio15),
                        .offset(32'h4c),
                        .rights("RW"));
    prio16 = rv_plic_reg_prio16::type_id::create("prio16");
    prio16.configure(.blk_parent(this));
    prio16.build();
    default_map.add_reg(.rg(prio16),
                        .offset(32'h50),
                        .rights("RW"));
    prio17 = rv_plic_reg_prio17::type_id::create("prio17");
    prio17.configure(.blk_parent(this));
    prio17.build();
    default_map.add_reg(.rg(prio17),
                        .offset(32'h54),
                        .rights("RW"));
    prio18 = rv_plic_reg_prio18::type_id::create("prio18");
    prio18.configure(.blk_parent(this));
    prio18.build();
    default_map.add_reg(.rg(prio18),
                        .offset(32'h58),
                        .rights("RW"));
    prio19 = rv_plic_reg_prio19::type_id::create("prio19");
    prio19.configure(.blk_parent(this));
    prio19.build();
    default_map.add_reg(.rg(prio19),
                        .offset(32'h5c),
                        .rights("RW"));
    prio20 = rv_plic_reg_prio20::type_id::create("prio20");
    prio20.configure(.blk_parent(this));
    prio20.build();
    default_map.add_reg(.rg(prio20),
                        .offset(32'h60),
                        .rights("RW"));
    prio21 = rv_plic_reg_prio21::type_id::create("prio21");
    prio21.configure(.blk_parent(this));
    prio21.build();
    default_map.add_reg(.rg(prio21),
                        .offset(32'h64),
                        .rights("RW"));
    prio22 = rv_plic_reg_prio22::type_id::create("prio22");
    prio22.configure(.blk_parent(this));
    prio22.build();
    default_map.add_reg(.rg(prio22),
                        .offset(32'h68),
                        .rights("RW"));
    prio23 = rv_plic_reg_prio23::type_id::create("prio23");
    prio23.configure(.blk_parent(this));
    prio23.build();
    default_map.add_reg(.rg(prio23),
                        .offset(32'h6c),
                        .rights("RW"));
    prio24 = rv_plic_reg_prio24::type_id::create("prio24");
    prio24.configure(.blk_parent(this));
    prio24.build();
    default_map.add_reg(.rg(prio24),
                        .offset(32'h70),
                        .rights("RW"));
    prio25 = rv_plic_reg_prio25::type_id::create("prio25");
    prio25.configure(.blk_parent(this));
    prio25.build();
    default_map.add_reg(.rg(prio25),
                        .offset(32'h74),
                        .rights("RW"));
    prio26 = rv_plic_reg_prio26::type_id::create("prio26");
    prio26.configure(.blk_parent(this));
    prio26.build();
    default_map.add_reg(.rg(prio26),
                        .offset(32'h78),
                        .rights("RW"));
    prio27 = rv_plic_reg_prio27::type_id::create("prio27");
    prio27.configure(.blk_parent(this));
    prio27.build();
    default_map.add_reg(.rg(prio27),
                        .offset(32'h7c),
                        .rights("RW"));
    prio28 = rv_plic_reg_prio28::type_id::create("prio28");
    prio28.configure(.blk_parent(this));
    prio28.build();
    default_map.add_reg(.rg(prio28),
                        .offset(32'h80),
                        .rights("RW"));
    prio29 = rv_plic_reg_prio29::type_id::create("prio29");
    prio29.configure(.blk_parent(this));
    prio29.build();
    default_map.add_reg(.rg(prio29),
                        .offset(32'h84),
                        .rights("RW"));
    prio30 = rv_plic_reg_prio30::type_id::create("prio30");
    prio30.configure(.blk_parent(this));
    prio30.build();
    default_map.add_reg(.rg(prio30),
                        .offset(32'h88),
                        .rights("RW"));
    prio31 = rv_plic_reg_prio31::type_id::create("prio31");
    prio31.configure(.blk_parent(this));
    prio31.build();
    default_map.add_reg(.rg(prio31),
                        .offset(32'h8c),
                        .rights("RW"));
    prio32 = rv_plic_reg_prio32::type_id::create("prio32");
    prio32.configure(.blk_parent(this));
    prio32.build();
    default_map.add_reg(.rg(prio32),
                        .offset(32'h90),
                        .rights("RW"));
    prio33 = rv_plic_reg_prio33::type_id::create("prio33");
    prio33.configure(.blk_parent(this));
    prio33.build();
    default_map.add_reg(.rg(prio33),
                        .offset(32'h94),
                        .rights("RW"));
    prio34 = rv_plic_reg_prio34::type_id::create("prio34");
    prio34.configure(.blk_parent(this));
    prio34.build();
    default_map.add_reg(.rg(prio34),
                        .offset(32'h98),
                        .rights("RW"));
    prio35 = rv_plic_reg_prio35::type_id::create("prio35");
    prio35.configure(.blk_parent(this));
    prio35.build();
    default_map.add_reg(.rg(prio35),
                        .offset(32'h9c),
                        .rights("RW"));
    prio36 = rv_plic_reg_prio36::type_id::create("prio36");
    prio36.configure(.blk_parent(this));
    prio36.build();
    default_map.add_reg(.rg(prio36),
                        .offset(32'ha0),
                        .rights("RW"));
    prio37 = rv_plic_reg_prio37::type_id::create("prio37");
    prio37.configure(.blk_parent(this));
    prio37.build();
    default_map.add_reg(.rg(prio37),
                        .offset(32'ha4),
                        .rights("RW"));
    prio38 = rv_plic_reg_prio38::type_id::create("prio38");
    prio38.configure(.blk_parent(this));
    prio38.build();
    default_map.add_reg(.rg(prio38),
                        .offset(32'ha8),
                        .rights("RW"));
    prio39 = rv_plic_reg_prio39::type_id::create("prio39");
    prio39.configure(.blk_parent(this));
    prio39.build();
    default_map.add_reg(.rg(prio39),
                        .offset(32'hac),
                        .rights("RW"));
    prio40 = rv_plic_reg_prio40::type_id::create("prio40");
    prio40.configure(.blk_parent(this));
    prio40.build();
    default_map.add_reg(.rg(prio40),
                        .offset(32'hb0),
                        .rights("RW"));
    prio41 = rv_plic_reg_prio41::type_id::create("prio41");
    prio41.configure(.blk_parent(this));
    prio41.build();
    default_map.add_reg(.rg(prio41),
                        .offset(32'hb4),
                        .rights("RW"));
    prio42 = rv_plic_reg_prio42::type_id::create("prio42");
    prio42.configure(.blk_parent(this));
    prio42.build();
    default_map.add_reg(.rg(prio42),
                        .offset(32'hb8),
                        .rights("RW"));
    prio43 = rv_plic_reg_prio43::type_id::create("prio43");
    prio43.configure(.blk_parent(this));
    prio43.build();
    default_map.add_reg(.rg(prio43),
                        .offset(32'hbc),
                        .rights("RW"));
    prio44 = rv_plic_reg_prio44::type_id::create("prio44");
    prio44.configure(.blk_parent(this));
    prio44.build();
    default_map.add_reg(.rg(prio44),
                        .offset(32'hc0),
                        .rights("RW"));
    prio45 = rv_plic_reg_prio45::type_id::create("prio45");
    prio45.configure(.blk_parent(this));
    prio45.build();
    default_map.add_reg(.rg(prio45),
                        .offset(32'hc4),
                        .rights("RW"));
    prio46 = rv_plic_reg_prio46::type_id::create("prio46");
    prio46.configure(.blk_parent(this));
    prio46.build();
    default_map.add_reg(.rg(prio46),
                        .offset(32'hc8),
                        .rights("RW"));
    prio47 = rv_plic_reg_prio47::type_id::create("prio47");
    prio47.configure(.blk_parent(this));
    prio47.build();
    default_map.add_reg(.rg(prio47),
                        .offset(32'hcc),
                        .rights("RW"));
    prio48 = rv_plic_reg_prio48::type_id::create("prio48");
    prio48.configure(.blk_parent(this));
    prio48.build();
    default_map.add_reg(.rg(prio48),
                        .offset(32'hd0),
                        .rights("RW"));
    prio49 = rv_plic_reg_prio49::type_id::create("prio49");
    prio49.configure(.blk_parent(this));
    prio49.build();
    default_map.add_reg(.rg(prio49),
                        .offset(32'hd4),
                        .rights("RW"));
    prio50 = rv_plic_reg_prio50::type_id::create("prio50");
    prio50.configure(.blk_parent(this));
    prio50.build();
    default_map.add_reg(.rg(prio50),
                        .offset(32'hd8),
                        .rights("RW"));
    prio51 = rv_plic_reg_prio51::type_id::create("prio51");
    prio51.configure(.blk_parent(this));
    prio51.build();
    default_map.add_reg(.rg(prio51),
                        .offset(32'hdc),
                        .rights("RW"));
    prio52 = rv_plic_reg_prio52::type_id::create("prio52");
    prio52.configure(.blk_parent(this));
    prio52.build();
    default_map.add_reg(.rg(prio52),
                        .offset(32'he0),
                        .rights("RW"));
    prio53 = rv_plic_reg_prio53::type_id::create("prio53");
    prio53.configure(.blk_parent(this));
    prio53.build();
    default_map.add_reg(.rg(prio53),
                        .offset(32'he4),
                        .rights("RW"));
    ie00 = rv_plic_reg_ie00::type_id::create("ie00");
    ie00.configure(.blk_parent(this));
    ie00.build();
    default_map.add_reg(.rg(ie00),
                        .offset(32'h100),
                        .rights("RW"));
    ie01 = rv_plic_reg_ie01::type_id::create("ie01");
    ie01.configure(.blk_parent(this));
    ie01.build();
    default_map.add_reg(.rg(ie01),
                        .offset(32'h104),
                        .rights("RW"));
    threshold0 = rv_plic_reg_threshold0::type_id::create("threshold0");
    threshold0.configure(.blk_parent(this));
    threshold0.build();
    default_map.add_reg(.rg(threshold0),
                        .offset(32'h108),
                        .rights("RW"));
    cc0 = rv_plic_reg_cc0::type_id::create("cc0");
    cc0.configure(.blk_parent(this));
    cc0.build();
    default_map.add_reg(.rg(cc0),
                        .offset(32'h10c),
                        .rights("RW"));
    msip0 = rv_plic_reg_msip0::type_id::create("msip0");
    msip0.configure(.blk_parent(this));
    msip0.build();
    default_map.add_reg(.rg(msip0),
                        .offset(32'h110),
                        .rights("RW"));
  endfunction : build

endclass : rv_plic_reg_block

// Block: chip
// Class: chip_mem_rom
class chip_mem_rom extends dv_base_mem;

  `uvm_object_utils(chip_mem_rom)

  function new(string           name = "chip_mem_rom",
               longint unsigned size = 2048,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"RW"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : chip_mem_rom

// Class: chip_mem_ram_main
class chip_mem_ram_main extends dv_base_mem;

  `uvm_object_utils(chip_mem_ram_main)

  function new(string           name = "chip_mem_ram_main",
               longint unsigned size = 16384,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"RW"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : chip_mem_ram_main

// Class: chip_mem_eflash
class chip_mem_eflash extends dv_base_mem;

  `uvm_object_utils(chip_mem_eflash)

  function new(string           name = "chip_mem_eflash",
               longint unsigned size = 131072,
               int unsigned     n_bits = 32,
               string           access = "RW"/* TODO:"RW"*/,
               int              has_coverage = UVM_NO_COVERAGE);
    super.new(name, size, n_bits, access, has_coverage);
  endfunction : new

endclass : chip_mem_eflash

// Class: chip_reg_block
class chip_reg_block extends dv_base_reg_block;
  // sub blocks
  rand spi_device_reg_block spi_device;
  rand flash_ctrl_reg_block flash_ctrl;
  rand rv_timer_reg_block rv_timer;
  rand gpio_reg_block gpio;
  rand hmac_reg_block hmac;
  rand uart_reg_block uart;
  rand rv_plic_reg_block rv_plic;
  // memories
  rand chip_mem_rom rom;
  rand chip_mem_ram_main ram_main;
  rand chip_mem_eflash eflash;

  `uvm_object_utils(chip_reg_block)

  function new(string name = "chip_reg_block",
               int    has_coverage = UVM_NO_COVERAGE);
    super.new(name, has_coverage);
  endfunction : new

  virtual function void build(uvm_reg_addr_t base_addr);
    // create default map
    this.default_map = create_map(.name("default_map"),
                                  .base_addr(base_addr),
                                  .n_bytes(4),
                                  .endian(UVM_LITTLE_ENDIAN));

    // create sub blocks and add their maps
    spi_device = spi_device_reg_block::type_id::create("spi_device");
    spi_device.configure(.parent(this));
    spi_device.build(.base_addr(base_addr + 32'h40020000));
    default_map.add_submap(.child_map(spi_device.default_map),
                           .offset(base_addr + 32'h40020000));
    flash_ctrl = flash_ctrl_reg_block::type_id::create("flash_ctrl");
    flash_ctrl.configure(.parent(this));
    flash_ctrl.build(.base_addr(base_addr + 32'h40030000));
    default_map.add_submap(.child_map(flash_ctrl.default_map),
                           .offset(base_addr + 32'h40030000));
    rv_timer = rv_timer_reg_block::type_id::create("rv_timer");
    rv_timer.configure(.parent(this));
    rv_timer.build(.base_addr(base_addr + 32'h40080000));
    default_map.add_submap(.child_map(rv_timer.default_map),
                           .offset(base_addr + 32'h40080000));
    gpio = gpio_reg_block::type_id::create("gpio");
    gpio.configure(.parent(this));
    gpio.build(.base_addr(base_addr + 32'h40010000));
    default_map.add_submap(.child_map(gpio.default_map),
                           .offset(base_addr + 32'h40010000));
    hmac = hmac_reg_block::type_id::create("hmac");
    hmac.configure(.parent(this));
    hmac.build(.base_addr(base_addr + 32'h40120000));
    default_map.add_submap(.child_map(hmac.default_map),
                           .offset(base_addr + 32'h40120000));
    uart = uart_reg_block::type_id::create("uart");
    uart.configure(.parent(this));
    uart.build(.base_addr(base_addr + 32'h40000000));
    default_map.add_submap(.child_map(uart.default_map),
                           .offset(base_addr + 32'h40000000));
    rv_plic = rv_plic_reg_block::type_id::create("rv_plic");
    rv_plic.configure(.parent(this));
    rv_plic.build(.base_addr(base_addr + 32'h40090000));
    default_map.add_submap(.child_map(rv_plic.default_map),
                           .offset(base_addr + 32'h40090000));

    // create memories
    rom = chip_mem_rom::type_id::create("rom");
    rom.configure(.parent(this));
    default_map.add_mem(.mem(rom),
                        .offset(32'h8000),
                        .rights("RW"));
    ram_main = chip_mem_ram_main::type_id::create("ram_main");
    ram_main.configure(.parent(this));
    default_map.add_mem(.mem(ram_main),
                        .offset(32'h10000000),
                        .rights("RW"));
    eflash = chip_mem_eflash::type_id::create("eflash");
    eflash.configure(.parent(this));
    default_map.add_mem(.mem(eflash),
                        .offset(32'h20000000),
                        .rights("RW"));
  endfunction : build

endclass : chip_reg_block
