#!/bin/bash

# Copyright lowRISC contributors (OpenTitan project).
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0
#
# A script to initialize & daemonize a QEMU process that can then be connected
# to by e.g. the QEMU Monitor or GDB. Contains common logic for defining the
# arguments that need to be passed to QEMU to run an OT Earlgrey emulation.
#
# Takes arguments as set environment variables.
# Required:
#   - QEMU_BIN: the QEMU binary executable.
#   - QEMU_CONFIG: the OT QEMU config file generated by `cfggen.py`.
#   - QEMU_ROM: the ROM image for QEMU to execute.
#   - QEMU_OTP: the OT QEMU OTP image generated by `otpgen.py`.
# Optional:
#   - QEMU_FLASH: the OT QEMU Flash image generated by `flashgen.py`.
#   - QEMU_SPIFLASH: the Flash image to use for SPI Host0 / Device.
#   - QEMU_PIDFILE: The path to store the PID when QEMU daemonizes.
#   - QEMU_LOG: The location QEMU should log to, default /dev/fd/1.
#   - QEMU_ICOUNT: The "-icount shift N" value to use, defaults to 6.
#   - QEMU_MONITOR: The path to use for the QEMU Monitor PTY.
#   - QEMU_RV_DM_JTAG_SOCK: The path to use for the RV_DM JTAG TAP Ctrl PTY.
#   - QEMU_LC_JTAG_SOCK: The path to use for the LC_CTRL JTAG TAP Ctrl PTY.

set -e

fail() {
  echo "$1" >&2
  exit 1
}

# Mandatory environment variables:
if [ ! -f "$QEMU_BIN"      ]; then fail "expected QEMU_BIN to point to QEMU binary"; fi
if [ ! -f "$QEMU_CONFIG"   ]; then fail "expected QEMU_CONFIG to point to QEMU config file"; fi
if [ ! -f "$QEMU_ROM"      ]; then fail "expected QEMU_ROM to point to QEMU ROM image"; fi
if [ ! -f "$QEMU_OTP"      ]; then fail "expected QEMU_OTP to point to QEMU OTP image"; fi

# Optional environment variables:
QEMU_ICOUNT="${QEMU_ICOUNT:-6}"
QEMU_LOG="${QEMU_LOG:-/dev/fd/1}"
QEMU_MONITOR="${QEMU_MONITOR:-qemu-monitor}"
QEMU_RV_DM_JTAG_SOCK="${QEMU_RV_DM_JTAG_SOCK:-qemu-jtag.sock}"
QEMU_LC_JTAG_SOCK="${QEMU_LC_JTAG_SOCK:-qemu-jtag-lc-ctrl.sock}"

# Construct a list of arguments to provide to QEMU
qemu_args=(
  # Disable GUI features.
  "-display" "none"

  # Select Earlgrey 1.0.0 machine.
  "-M" "ot-earlgrey"

  # Load RTL constants from config file.
  "-readconfig" "$QEMU_CONFIG"

  # Fork to background once initialization has finished.
  "-daemonize"
)

# Optionally use a PID file to retrieve the daemon PID for cleanup
if [ -n "$QEMU_PIDFILE" ]; then
    qemu_args+=(
      "-pidfile" "$QEMU_PIDFILE"
    )
fi

qemu_args+=(
  # Hold CPU stopped until GDB or the QEMU monitor starts it.
  "-S"

  # Send logs to a file.
  "-D" "$QEMU_LOG"
  "-d" "guest_errors,unimp"

  # Configure the ROM & OTP data
  "-object" "ot-rom_img,id=rom,file=${QEMU_ROM}"
  "-drive" "if=pflash,file=${QEMU_OTP},format=raw"
)

# Configure flash data
if [ -n "$QEMU_FLASH" ]; then
    qemu_args+=(
      "-drive" "if=mtd,id=eflash,bus=2,file=${QEMU_FLASH},format=raw"
    )
fi

qemu_args+=(
  # Scale the CPU clock (1MHz >> `icount`).
  "-icount" "shift=${QEMU_ICOUNT}"

  # Do not exit QEMU on resets - some tests need these.
  "-global" "ot-rstmgr.fatal_reset=0"

  # Because flash info pages are not spliced and QEMU does not currently
  # support flash scrambling/ECCs, any uninitialized seeds read from the flash
  # creator/owner secret pages will be all `0xFF...`. This will cause the
  # keymgr to error when advancing to the OwnerIntermediate state, preventing
  # further use. Disable the relevant keymgr data validity check via an opt-in
  # QEMU property.
  # TODO: remove this property when either QEMU flash info page splicing
  # is available, or the QEMU `flash_ctrl` implements scrambling & ECC support.
  "-global" "ot-keymgr.disable-flash-seed-check=true"

  # By default QEMU will exit when the test status register is written.
  # OpenTitanTool expects to be able to do multiple resets, for example after
  # bootstrapping, and then execute the test. Resetting could cause the test
  # to run, finish, and exit, which we don't want to happen.
  "-global" "ot-ibex_wrapper.dv-sim-status-exit=off"

  # To enable limited support for UART rescue in the ROM_EXT, we need to
  # be able to toggle break signals on/off in QEMU's UART and mock this
  # in the oversampled `VAL` register.
  "-global" "ot-uart.oversample-break=true"
  "-global" "ot-uart.toggle-break=true"

  # QEMU will by default interpret quit commands over JTAG to the TAP Ctrls
  # as signals to exit VM execution. We want to be able to disconnect from
  # JTAG without stopping execution completely for tests.
  "-global" "tap-ctrl-rbb.quit=false"

  # Configure the monitor in QMP mode with a PTY.
  "-chardev" "pty,id=monitor,path=${QEMU_MONITOR}"
  "-mon" "chardev=monitor,mode=control"

  # Connect log device to a PTY (only used for optional pass/fail message).
  "-chardev" "pty,id=log"
  "-global" "ot-ibex_wrapper.logdev=log"

  # Connect UARTs to PTYs.
  "-chardev" "pty,id=uart0"
  "-chardev" "pty,id=uart1"
  "-chardev" "pty,id=uart2"
  "-chardev" "pty,id=uart3"
  "-serial" "chardev:uart0"
  "-serial" "chardev:uart1"
  "-serial" "chardev:uart2"
  "-serial" "chardev:uart3"

  # Connect SPI device to PTY.
  "-chardev" "pty,id=spidev"
)

# Attach SPI flash to SPI Host 0/SPI Device bus. Chosen model is W25Q256 (32MiB)
if [ -n "$QEMU_SPIFLASH" ]; then
    qemu_args+=(
      "-global" "ot-earlgrey-board.spiflash0=w25q256"
      "-drive" "if=mtd,file=${QEMU_SPIFLASH},format=raw,bus=0"
    )
fi

qemu_args+=(
  # Connect I2Cs to PTYs.
  "-chardev" "pty,id=i2c0"
  "-chardev" "pty,id=i2c1"
  "-chardev" "pty,id=i2c2"
  "-device" "ot-i2c_host_proxy,bus=ot-i2c0,chardev=i2c0"
  "-device" "ot-i2c_host_proxy,bus=ot-i2c1,chardev=i2c1"
  "-device" "ot-i2c_host_proxy,bus=ot-i2c2,chardev=i2c2"

  # Connect GPIO interface to a PTY.
  "-chardev" "pty,id=gpio"
  "-global" "ot-gpio-eg.chardev=gpio"

  # Connect USB command & protocol interfaces to PTYs.
  "-chardev" "pty,id=usbdev-cmd"
  "-chardev" "pty,id=usbdev-host"

  # Connect JTAG remote bit-bang for RV_DM & LC_CTRL TAPs to sockets.
  "-chardev" "socket,id=taprbb,path=${QEMU_RV_DM_JTAG_SOCK},server=on,wait=off"
  "-chardev" "socket,id=taprbb-lc-ctrl,path=${QEMU_LC_JTAG_SOCK},server=on,wait=off"
)

# Spawn QEMU
echo "Starting QEMU:" "$QEMU_BIN" "${qemu_args[*]}" "$@"
"$QEMU_BIN" "${qemu_args[@]}" "$@"
