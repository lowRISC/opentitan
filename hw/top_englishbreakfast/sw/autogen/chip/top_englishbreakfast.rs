// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// This file was generated automatically.
// Please do not modify content of this file directly.
// File generated by using template: "toplevel.rs.tpl"
// To regenerate this file follow OpenTitan topgen documentations.

#![allow(dead_code)]

//! This file contains enums and consts for use within the Rust codebase.
//!
//! These definitions are for information that depends on the top-specific chip
//! configuration, which includes:
//! - Device Memory Information (for Peripherals and Memory)
//! - PLIC Interrupt ID Names and Source Mappings
//! - Alert ID Names and Source Mappings
//! - Pinmux Pin/Select Names
//! - Power Manager Wakeups

use core::convert::TryFrom;

/// Peripheral base address for uart0 in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const UART0_BASE_ADDR: usize = 0x40000000;

/// Peripheral size for uart0 in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #UART0_BASE_ADDR and
/// `UART0_BASE_ADDR + UART0_SIZE_BYTES`.
pub const UART0_SIZE_BYTES: usize = 0x40;

/// Peripheral base address for uart1 in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const UART1_BASE_ADDR: usize = 0x40010000;

/// Peripheral size for uart1 in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #UART1_BASE_ADDR and
/// `UART1_BASE_ADDR + UART1_SIZE_BYTES`.
pub const UART1_SIZE_BYTES: usize = 0x40;

/// Peripheral base address for gpio in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const GPIO_BASE_ADDR: usize = 0x40040000;

/// Peripheral size for gpio in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #GPIO_BASE_ADDR and
/// `GPIO_BASE_ADDR + GPIO_SIZE_BYTES`.
pub const GPIO_SIZE_BYTES: usize = 0x40;

/// Peripheral base address for spi_device in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const SPI_DEVICE_BASE_ADDR: usize = 0x40050000;

/// Peripheral size for spi_device in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #SPI_DEVICE_BASE_ADDR and
/// `SPI_DEVICE_BASE_ADDR + SPI_DEVICE_SIZE_BYTES`.
pub const SPI_DEVICE_SIZE_BYTES: usize = 0x2000;

/// Peripheral base address for spi_host0 in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const SPI_HOST0_BASE_ADDR: usize = 0x40060000;

/// Peripheral size for spi_host0 in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #SPI_HOST0_BASE_ADDR and
/// `SPI_HOST0_BASE_ADDR + SPI_HOST0_SIZE_BYTES`.
pub const SPI_HOST0_SIZE_BYTES: usize = 0x40;

/// Peripheral base address for rv_timer in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const RV_TIMER_BASE_ADDR: usize = 0x40100000;

/// Peripheral size for rv_timer in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #RV_TIMER_BASE_ADDR and
/// `RV_TIMER_BASE_ADDR + RV_TIMER_SIZE_BYTES`.
pub const RV_TIMER_SIZE_BYTES: usize = 0x200;

/// Peripheral base address for usbdev in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const USBDEV_BASE_ADDR: usize = 0x40320000;

/// Peripheral size for usbdev in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #USBDEV_BASE_ADDR and
/// `USBDEV_BASE_ADDR + USBDEV_SIZE_BYTES`.
pub const USBDEV_SIZE_BYTES: usize = 0x1000;

/// Peripheral base address for pwrmgr_aon in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const PWRMGR_AON_BASE_ADDR: usize = 0x40400000;

/// Peripheral size for pwrmgr_aon in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #PWRMGR_AON_BASE_ADDR and
/// `PWRMGR_AON_BASE_ADDR + PWRMGR_AON_SIZE_BYTES`.
pub const PWRMGR_AON_SIZE_BYTES: usize = 0x80;

/// Peripheral base address for rstmgr_aon in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const RSTMGR_AON_BASE_ADDR: usize = 0x40410000;

/// Peripheral size for rstmgr_aon in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #RSTMGR_AON_BASE_ADDR and
/// `RSTMGR_AON_BASE_ADDR + RSTMGR_AON_SIZE_BYTES`.
pub const RSTMGR_AON_SIZE_BYTES: usize = 0x80;

/// Peripheral base address for clkmgr_aon in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const CLKMGR_AON_BASE_ADDR: usize = 0x40420000;

/// Peripheral size for clkmgr_aon in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #CLKMGR_AON_BASE_ADDR and
/// `CLKMGR_AON_BASE_ADDR + CLKMGR_AON_SIZE_BYTES`.
pub const CLKMGR_AON_SIZE_BYTES: usize = 0x80;

/// Peripheral base address for pinmux_aon in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const PINMUX_AON_BASE_ADDR: usize = 0x40460000;

/// Peripheral size for pinmux_aon in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #PINMUX_AON_BASE_ADDR and
/// `PINMUX_AON_BASE_ADDR + PINMUX_AON_SIZE_BYTES`.
pub const PINMUX_AON_SIZE_BYTES: usize = 0x1000;

/// Peripheral base address for aon_timer_aon in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const AON_TIMER_AON_BASE_ADDR: usize = 0x40470000;

/// Peripheral size for aon_timer_aon in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #AON_TIMER_AON_BASE_ADDR and
/// `AON_TIMER_AON_BASE_ADDR + AON_TIMER_AON_SIZE_BYTES`.
pub const AON_TIMER_AON_SIZE_BYTES: usize = 0x40;

/// Peripheral base address for ast in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const AST_BASE_ADDR: usize = 0x40480000;

/// Peripheral size for ast in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #AST_BASE_ADDR and
/// `AST_BASE_ADDR + AST_SIZE_BYTES`.
pub const AST_SIZE_BYTES: usize = 0x400;

/// Peripheral base address for core device on flash_ctrl in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const FLASH_CTRL_CORE_BASE_ADDR: usize = 0x41000000;

/// Peripheral size for core device on flash_ctrl in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #FLASH_CTRL_CORE_BASE_ADDR and
/// `FLASH_CTRL_CORE_BASE_ADDR + FLASH_CTRL_CORE_SIZE_BYTES`.
pub const FLASH_CTRL_CORE_SIZE_BYTES: usize = 0x200;

/// Peripheral base address for prim device on flash_ctrl in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const FLASH_CTRL_PRIM_BASE_ADDR: usize = 0x41008000;

/// Peripheral size for prim device on flash_ctrl in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #FLASH_CTRL_PRIM_BASE_ADDR and
/// `FLASH_CTRL_PRIM_BASE_ADDR + FLASH_CTRL_PRIM_SIZE_BYTES`.
pub const FLASH_CTRL_PRIM_SIZE_BYTES: usize = 0x80;

/// Peripheral base address for mem device on flash_ctrl in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const FLASH_CTRL_MEM_BASE_ADDR: usize = 0x20000000;

/// Peripheral size for mem device on flash_ctrl in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #FLASH_CTRL_MEM_BASE_ADDR and
/// `FLASH_CTRL_MEM_BASE_ADDR + FLASH_CTRL_MEM_SIZE_BYTES`.
pub const FLASH_CTRL_MEM_SIZE_BYTES: usize = 0x10000;

/// Peripheral base address for rv_plic in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const RV_PLIC_BASE_ADDR: usize = 0x48000000;

/// Peripheral size for rv_plic in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #RV_PLIC_BASE_ADDR and
/// `RV_PLIC_BASE_ADDR + RV_PLIC_SIZE_BYTES`.
pub const RV_PLIC_SIZE_BYTES: usize = 0x8000000;

/// Peripheral base address for aes in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const AES_BASE_ADDR: usize = 0x41100000;

/// Peripheral size for aes in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #AES_BASE_ADDR and
/// `AES_BASE_ADDR + AES_SIZE_BYTES`.
pub const AES_SIZE_BYTES: usize = 0x100;

/// Peripheral base address for regs device on sram_ctrl_main in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const SRAM_CTRL_MAIN_REGS_BASE_ADDR: usize = 0x411C0000;

/// Peripheral size for regs device on sram_ctrl_main in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #SRAM_CTRL_MAIN_REGS_BASE_ADDR and
/// `SRAM_CTRL_MAIN_REGS_BASE_ADDR + SRAM_CTRL_MAIN_REGS_SIZE_BYTES`.
pub const SRAM_CTRL_MAIN_REGS_SIZE_BYTES: usize = 0x40;

/// Peripheral base address for ram device on sram_ctrl_main in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const SRAM_CTRL_MAIN_RAM_BASE_ADDR: usize = 0x10000000;

/// Peripheral size for ram device on sram_ctrl_main in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #SRAM_CTRL_MAIN_RAM_BASE_ADDR and
/// `SRAM_CTRL_MAIN_RAM_BASE_ADDR + SRAM_CTRL_MAIN_RAM_SIZE_BYTES`.
pub const SRAM_CTRL_MAIN_RAM_SIZE_BYTES: usize = 0x20000;

/// Peripheral base address for regs device on rom_ctrl in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const ROM_CTRL_REGS_BASE_ADDR: usize = 0x411E0000;

/// Peripheral size for regs device on rom_ctrl in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #ROM_CTRL_REGS_BASE_ADDR and
/// `ROM_CTRL_REGS_BASE_ADDR + ROM_CTRL_REGS_SIZE_BYTES`.
pub const ROM_CTRL_REGS_SIZE_BYTES: usize = 0x80;

/// Peripheral base address for rom device on rom_ctrl in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const ROM_CTRL_ROM_BASE_ADDR: usize = 0x8000;

/// Peripheral size for rom device on rom_ctrl in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #ROM_CTRL_ROM_BASE_ADDR and
/// `ROM_CTRL_ROM_BASE_ADDR + ROM_CTRL_ROM_SIZE_BYTES`.
pub const ROM_CTRL_ROM_SIZE_BYTES: usize = 0x8000;

/// Peripheral base address for cfg device on rv_core_ibex in top englishbreakfast.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const RV_CORE_IBEX_CFG_BASE_ADDR: usize = 0x411F0000;

/// Peripheral size for cfg device on rv_core_ibex in top englishbreakfast.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #RV_CORE_IBEX_CFG_BASE_ADDR and
/// `RV_CORE_IBEX_CFG_BASE_ADDR + RV_CORE_IBEX_CFG_SIZE_BYTES`.
pub const RV_CORE_IBEX_CFG_SIZE_BYTES: usize = 0x100;

/// Memory base address for eflash in top englishbreakfast.
pub const EFLASH_BASE_ADDR: usize = 0x20000000;

/// Memory size for eflash in top englishbreakfast.
pub const EFLASH_SIZE_BYTES: usize = 0x10000;

/// Memory base address for ram_main in top englishbreakfast.
pub const RAM_MAIN_BASE_ADDR: usize = 0x10000000;

/// Memory size for ram_main in top englishbreakfast.
pub const RAM_MAIN_SIZE_BYTES: usize = 0x20000;

/// Memory base address for rom in top englishbreakfast.
pub const ROM_BASE_ADDR: usize = 0x8000;

/// Memory size for rom in top englishbreakfast.
pub const ROM_SIZE_BYTES: usize = 0x8000;

/// PLIC Interrupt Source Peripheral.
///
/// Enumeration used to determine which peripheral asserted the corresponding
/// interrupt.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum PlicPeripheral {
    /// Unknown Peripheral
    Unknown = 0,
    /// uart0
    Uart0 = 1,
    /// uart1
    Uart1 = 2,
    /// gpio
    Gpio = 3,
    /// spi_device
    SpiDevice = 4,
    /// spi_host0
    SpiHost0 = 5,
    /// usbdev
    Usbdev = 6,
    /// pwrmgr_aon
    PwrmgrAon = 7,
    /// aon_timer_aon
    AonTimerAon = 8,
    /// flash_ctrl
    FlashCtrl = 9,
}

impl TryFrom<u32> for PlicPeripheral {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::Unknown),
            1 => Ok(Self::Uart0),
            2 => Ok(Self::Uart1),
            3 => Ok(Self::Gpio),
            4 => Ok(Self::SpiDevice),
            5 => Ok(Self::SpiHost0),
            6 => Ok(Self::Usbdev),
            7 => Ok(Self::PwrmgrAon),
            8 => Ok(Self::AonTimerAon),
            9 => Ok(Self::FlashCtrl),
            _ => Err(val),
        }
    }
}

/// PLIC Interrupt Source.
///
/// Enumeration of all PLIC interrupt sources. The interrupt sources belonging to
/// the same peripheral are guaranteed to be consecutive.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum PlicIrqId {
    /// No Interrupt
    None = 0,
    /// uart0_tx_watermark
    Uart0TxWatermark = 1,
    /// uart0_rx_watermark
    Uart0RxWatermark = 2,
    /// uart0_tx_done
    Uart0TxDone = 3,
    /// uart0_rx_overflow
    Uart0RxOverflow = 4,
    /// uart0_rx_frame_err
    Uart0RxFrameErr = 5,
    /// uart0_rx_break_err
    Uart0RxBreakErr = 6,
    /// uart0_rx_timeout
    Uart0RxTimeout = 7,
    /// uart0_rx_parity_err
    Uart0RxParityErr = 8,
    /// uart0_tx_empty
    Uart0TxEmpty = 9,
    /// uart1_tx_watermark
    Uart1TxWatermark = 10,
    /// uart1_rx_watermark
    Uart1RxWatermark = 11,
    /// uart1_tx_done
    Uart1TxDone = 12,
    /// uart1_rx_overflow
    Uart1RxOverflow = 13,
    /// uart1_rx_frame_err
    Uart1RxFrameErr = 14,
    /// uart1_rx_break_err
    Uart1RxBreakErr = 15,
    /// uart1_rx_timeout
    Uart1RxTimeout = 16,
    /// uart1_rx_parity_err
    Uart1RxParityErr = 17,
    /// uart1_tx_empty
    Uart1TxEmpty = 18,
    /// gpio_gpio 0
    GpioGpio0 = 19,
    /// gpio_gpio 1
    GpioGpio1 = 20,
    /// gpio_gpio 2
    GpioGpio2 = 21,
    /// gpio_gpio 3
    GpioGpio3 = 22,
    /// gpio_gpio 4
    GpioGpio4 = 23,
    /// gpio_gpio 5
    GpioGpio5 = 24,
    /// gpio_gpio 6
    GpioGpio6 = 25,
    /// gpio_gpio 7
    GpioGpio7 = 26,
    /// gpio_gpio 8
    GpioGpio8 = 27,
    /// gpio_gpio 9
    GpioGpio9 = 28,
    /// gpio_gpio 10
    GpioGpio10 = 29,
    /// gpio_gpio 11
    GpioGpio11 = 30,
    /// gpio_gpio 12
    GpioGpio12 = 31,
    /// gpio_gpio 13
    GpioGpio13 = 32,
    /// gpio_gpio 14
    GpioGpio14 = 33,
    /// gpio_gpio 15
    GpioGpio15 = 34,
    /// gpio_gpio 16
    GpioGpio16 = 35,
    /// gpio_gpio 17
    GpioGpio17 = 36,
    /// gpio_gpio 18
    GpioGpio18 = 37,
    /// gpio_gpio 19
    GpioGpio19 = 38,
    /// gpio_gpio 20
    GpioGpio20 = 39,
    /// gpio_gpio 21
    GpioGpio21 = 40,
    /// gpio_gpio 22
    GpioGpio22 = 41,
    /// gpio_gpio 23
    GpioGpio23 = 42,
    /// gpio_gpio 24
    GpioGpio24 = 43,
    /// gpio_gpio 25
    GpioGpio25 = 44,
    /// gpio_gpio 26
    GpioGpio26 = 45,
    /// gpio_gpio 27
    GpioGpio27 = 46,
    /// gpio_gpio 28
    GpioGpio28 = 47,
    /// gpio_gpio 29
    GpioGpio29 = 48,
    /// gpio_gpio 30
    GpioGpio30 = 49,
    /// gpio_gpio 31
    GpioGpio31 = 50,
    /// spi_device_upload_cmdfifo_not_empty
    SpiDeviceUploadCmdfifoNotEmpty = 51,
    /// spi_device_upload_payload_not_empty
    SpiDeviceUploadPayloadNotEmpty = 52,
    /// spi_device_upload_payload_overflow
    SpiDeviceUploadPayloadOverflow = 53,
    /// spi_device_readbuf_watermark
    SpiDeviceReadbufWatermark = 54,
    /// spi_device_readbuf_flip
    SpiDeviceReadbufFlip = 55,
    /// spi_device_tpm_header_not_empty
    SpiDeviceTpmHeaderNotEmpty = 56,
    /// spi_device_tpm_rdfifo_cmd_end
    SpiDeviceTpmRdfifoCmdEnd = 57,
    /// spi_device_tpm_rdfifo_drop
    SpiDeviceTpmRdfifoDrop = 58,
    /// spi_host0_error
    SpiHost0Error = 59,
    /// spi_host0_spi_event
    SpiHost0SpiEvent = 60,
    /// usbdev_pkt_received
    UsbdevPktReceived = 61,
    /// usbdev_pkt_sent
    UsbdevPktSent = 62,
    /// usbdev_disconnected
    UsbdevDisconnected = 63,
    /// usbdev_host_lost
    UsbdevHostLost = 64,
    /// usbdev_link_reset
    UsbdevLinkReset = 65,
    /// usbdev_link_suspend
    UsbdevLinkSuspend = 66,
    /// usbdev_link_resume
    UsbdevLinkResume = 67,
    /// usbdev_av_out_empty
    UsbdevAvOutEmpty = 68,
    /// usbdev_rx_full
    UsbdevRxFull = 69,
    /// usbdev_av_overflow
    UsbdevAvOverflow = 70,
    /// usbdev_link_in_err
    UsbdevLinkInErr = 71,
    /// usbdev_rx_crc_err
    UsbdevRxCrcErr = 72,
    /// usbdev_rx_pid_err
    UsbdevRxPidErr = 73,
    /// usbdev_rx_bitstuff_err
    UsbdevRxBitstuffErr = 74,
    /// usbdev_frame
    UsbdevFrame = 75,
    /// usbdev_powered
    UsbdevPowered = 76,
    /// usbdev_link_out_err
    UsbdevLinkOutErr = 77,
    /// usbdev_av_setup_empty
    UsbdevAvSetupEmpty = 78,
    /// pwrmgr_aon_wakeup
    PwrmgrAonWakeup = 79,
    /// aon_timer_aon_wkup_timer_expired
    AonTimerAonWkupTimerExpired = 80,
    /// aon_timer_aon_wdog_timer_bark
    AonTimerAonWdogTimerBark = 81,
    /// flash_ctrl_prog_empty
    FlashCtrlProgEmpty = 82,
    /// flash_ctrl_prog_lvl
    FlashCtrlProgLvl = 83,
    /// flash_ctrl_rd_full
    FlashCtrlRdFull = 84,
    /// flash_ctrl_rd_lvl
    FlashCtrlRdLvl = 85,
    /// flash_ctrl_op_done
    FlashCtrlOpDone = 86,
    /// flash_ctrl_corr_err
    FlashCtrlCorrErr = 87,
}

impl TryFrom<u32> for PlicIrqId {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::None),
            1 => Ok(Self::Uart0TxWatermark),
            2 => Ok(Self::Uart0RxWatermark),
            3 => Ok(Self::Uart0TxDone),
            4 => Ok(Self::Uart0RxOverflow),
            5 => Ok(Self::Uart0RxFrameErr),
            6 => Ok(Self::Uart0RxBreakErr),
            7 => Ok(Self::Uart0RxTimeout),
            8 => Ok(Self::Uart0RxParityErr),
            9 => Ok(Self::Uart0TxEmpty),
            10 => Ok(Self::Uart1TxWatermark),
            11 => Ok(Self::Uart1RxWatermark),
            12 => Ok(Self::Uart1TxDone),
            13 => Ok(Self::Uart1RxOverflow),
            14 => Ok(Self::Uart1RxFrameErr),
            15 => Ok(Self::Uart1RxBreakErr),
            16 => Ok(Self::Uart1RxTimeout),
            17 => Ok(Self::Uart1RxParityErr),
            18 => Ok(Self::Uart1TxEmpty),
            19 => Ok(Self::GpioGpio0),
            20 => Ok(Self::GpioGpio1),
            21 => Ok(Self::GpioGpio2),
            22 => Ok(Self::GpioGpio3),
            23 => Ok(Self::GpioGpio4),
            24 => Ok(Self::GpioGpio5),
            25 => Ok(Self::GpioGpio6),
            26 => Ok(Self::GpioGpio7),
            27 => Ok(Self::GpioGpio8),
            28 => Ok(Self::GpioGpio9),
            29 => Ok(Self::GpioGpio10),
            30 => Ok(Self::GpioGpio11),
            31 => Ok(Self::GpioGpio12),
            32 => Ok(Self::GpioGpio13),
            33 => Ok(Self::GpioGpio14),
            34 => Ok(Self::GpioGpio15),
            35 => Ok(Self::GpioGpio16),
            36 => Ok(Self::GpioGpio17),
            37 => Ok(Self::GpioGpio18),
            38 => Ok(Self::GpioGpio19),
            39 => Ok(Self::GpioGpio20),
            40 => Ok(Self::GpioGpio21),
            41 => Ok(Self::GpioGpio22),
            42 => Ok(Self::GpioGpio23),
            43 => Ok(Self::GpioGpio24),
            44 => Ok(Self::GpioGpio25),
            45 => Ok(Self::GpioGpio26),
            46 => Ok(Self::GpioGpio27),
            47 => Ok(Self::GpioGpio28),
            48 => Ok(Self::GpioGpio29),
            49 => Ok(Self::GpioGpio30),
            50 => Ok(Self::GpioGpio31),
            51 => Ok(Self::SpiDeviceUploadCmdfifoNotEmpty),
            52 => Ok(Self::SpiDeviceUploadPayloadNotEmpty),
            53 => Ok(Self::SpiDeviceUploadPayloadOverflow),
            54 => Ok(Self::SpiDeviceReadbufWatermark),
            55 => Ok(Self::SpiDeviceReadbufFlip),
            56 => Ok(Self::SpiDeviceTpmHeaderNotEmpty),
            57 => Ok(Self::SpiDeviceTpmRdfifoCmdEnd),
            58 => Ok(Self::SpiDeviceTpmRdfifoDrop),
            59 => Ok(Self::SpiHost0Error),
            60 => Ok(Self::SpiHost0SpiEvent),
            61 => Ok(Self::UsbdevPktReceived),
            62 => Ok(Self::UsbdevPktSent),
            63 => Ok(Self::UsbdevDisconnected),
            64 => Ok(Self::UsbdevHostLost),
            65 => Ok(Self::UsbdevLinkReset),
            66 => Ok(Self::UsbdevLinkSuspend),
            67 => Ok(Self::UsbdevLinkResume),
            68 => Ok(Self::UsbdevAvOutEmpty),
            69 => Ok(Self::UsbdevRxFull),
            70 => Ok(Self::UsbdevAvOverflow),
            71 => Ok(Self::UsbdevLinkInErr),
            72 => Ok(Self::UsbdevRxCrcErr),
            73 => Ok(Self::UsbdevRxPidErr),
            74 => Ok(Self::UsbdevRxBitstuffErr),
            75 => Ok(Self::UsbdevFrame),
            76 => Ok(Self::UsbdevPowered),
            77 => Ok(Self::UsbdevLinkOutErr),
            78 => Ok(Self::UsbdevAvSetupEmpty),
            79 => Ok(Self::PwrmgrAonWakeup),
            80 => Ok(Self::AonTimerAonWkupTimerExpired),
            81 => Ok(Self::AonTimerAonWdogTimerBark),
            82 => Ok(Self::FlashCtrlProgEmpty),
            83 => Ok(Self::FlashCtrlProgLvl),
            84 => Ok(Self::FlashCtrlRdFull),
            85 => Ok(Self::FlashCtrlRdLvl),
            86 => Ok(Self::FlashCtrlOpDone),
            87 => Ok(Self::FlashCtrlCorrErr),
            _ => Err(val),
        }
    }
}

/// PLIC Interrupt Target.
///
/// Enumeration used to determine which set of IE, CC, threshold registers to
/// access for a given interrupt target.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum PlicTarget {
    /// Ibex Core 0
    Ibex0 = 0,
}

/// Alert Handler Source Peripheral.
///
/// Enumeration used to determine which peripheral asserted the corresponding
/// alert.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum AlertPeripheral {
    /// uart0
    Uart0 = 0,
    /// uart1
    Uart1 = 1,
    /// gpio
    Gpio = 2,
    /// spi_device
    SpiDevice = 3,
    /// spi_host0
    SpiHost0 = 4,
    /// rv_timer
    RvTimer = 5,
    /// usbdev
    Usbdev = 6,
    /// pwrmgr_aon
    PwrmgrAon = 7,
    /// rstmgr_aon
    RstmgrAon = 8,
    /// clkmgr_aon
    ClkmgrAon = 9,
    /// pinmux_aon
    PinmuxAon = 10,
    /// aon_timer_aon
    AonTimerAon = 11,
    /// flash_ctrl
    FlashCtrl = 12,
    /// rv_plic
    RvPlic = 13,
    /// aes
    Aes = 14,
    /// sram_ctrl_main
    SramCtrlMain = 15,
    /// rom_ctrl
    RomCtrl = 16,
    /// rv_core_ibex
    RvCoreIbex = 17,
}

/// Alert Handler Alert Source.
///
/// Enumeration of all Alert Handler Alert Sources. The alert sources belonging to
/// the same peripheral are guaranteed to be consecutive.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum AlertId {
    /// uart0_fatal_fault
    Uart0FatalFault = 0,
    /// uart1_fatal_fault
    Uart1FatalFault = 1,
    /// gpio_fatal_fault
    GpioFatalFault = 2,
    /// spi_device_fatal_fault
    SpiDeviceFatalFault = 3,
    /// spi_host0_fatal_fault
    SpiHost0FatalFault = 4,
    /// rv_timer_fatal_fault
    RvTimerFatalFault = 5,
    /// usbdev_fatal_fault
    UsbdevFatalFault = 6,
    /// pwrmgr_aon_fatal_fault
    PwrmgrAonFatalFault = 7,
    /// rstmgr_aon_fatal_fault
    RstmgrAonFatalFault = 8,
    /// rstmgr_aon_fatal_cnsty_fault
    RstmgrAonFatalCnstyFault = 9,
    /// clkmgr_aon_recov_fault
    ClkmgrAonRecovFault = 10,
    /// clkmgr_aon_fatal_fault
    ClkmgrAonFatalFault = 11,
    /// pinmux_aon_fatal_fault
    PinmuxAonFatalFault = 12,
    /// aon_timer_aon_fatal_fault
    AonTimerAonFatalFault = 13,
    /// flash_ctrl_recov_err
    FlashCtrlRecovErr = 14,
    /// flash_ctrl_fatal_std_err
    FlashCtrlFatalStdErr = 15,
    /// flash_ctrl_fatal_err
    FlashCtrlFatalErr = 16,
    /// flash_ctrl_fatal_prim_flash_alert
    FlashCtrlFatalPrimFlashAlert = 17,
    /// flash_ctrl_recov_prim_flash_alert
    FlashCtrlRecovPrimFlashAlert = 18,
    /// rv_plic_fatal_fault
    RvPlicFatalFault = 19,
    /// aes_recov_ctrl_update_err
    AesRecovCtrlUpdateErr = 20,
    /// aes_fatal_fault
    AesFatalFault = 21,
    /// sram_ctrl_main_fatal_error
    SramCtrlMainFatalError = 22,
    /// rom_ctrl_fatal
    RomCtrlFatal = 23,
    /// rv_core_ibex_fatal_sw_err
    RvCoreIbexFatalSwErr = 24,
    /// rv_core_ibex_recov_sw_err
    RvCoreIbexRecovSwErr = 25,
    /// rv_core_ibex_fatal_hw_err
    RvCoreIbexFatalHwErr = 26,
    /// rv_core_ibex_recov_hw_err
    RvCoreIbexRecovHwErr = 27,
}

impl TryFrom<u32> for AlertId {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::Uart0FatalFault),
            1 => Ok(Self::Uart1FatalFault),
            2 => Ok(Self::GpioFatalFault),
            3 => Ok(Self::SpiDeviceFatalFault),
            4 => Ok(Self::SpiHost0FatalFault),
            5 => Ok(Self::RvTimerFatalFault),
            6 => Ok(Self::UsbdevFatalFault),
            7 => Ok(Self::PwrmgrAonFatalFault),
            8 => Ok(Self::RstmgrAonFatalFault),
            9 => Ok(Self::RstmgrAonFatalCnstyFault),
            10 => Ok(Self::ClkmgrAonRecovFault),
            11 => Ok(Self::ClkmgrAonFatalFault),
            12 => Ok(Self::PinmuxAonFatalFault),
            13 => Ok(Self::AonTimerAonFatalFault),
            14 => Ok(Self::FlashCtrlRecovErr),
            15 => Ok(Self::FlashCtrlFatalStdErr),
            16 => Ok(Self::FlashCtrlFatalErr),
            17 => Ok(Self::FlashCtrlFatalPrimFlashAlert),
            18 => Ok(Self::FlashCtrlRecovPrimFlashAlert),
            19 => Ok(Self::RvPlicFatalFault),
            20 => Ok(Self::AesRecovCtrlUpdateErr),
            21 => Ok(Self::AesFatalFault),
            22 => Ok(Self::SramCtrlMainFatalError),
            23 => Ok(Self::RomCtrlFatal),
            24 => Ok(Self::RvCoreIbexFatalSwErr),
            25 => Ok(Self::RvCoreIbexRecovSwErr),
            26 => Ok(Self::RvCoreIbexFatalHwErr),
            27 => Ok(Self::RvCoreIbexRecovHwErr),
            _ => Err(val),
        }
    }
}

/// PLIC Interrupt Source to Peripheral Map
///
/// This array is a mapping from `PlicIrqId` to
/// `PlicPeripheral`.
pub const PLIC_INTERRUPT_FOR_PERIPHERAL: [PlicPeripheral; 88] = [
    // None -> PlicPeripheral::Unknown
    PlicPeripheral::Unknown,
    // Uart0TxWatermark -> PlicPeripheral::Uart0
    PlicPeripheral::Uart0,
    // Uart0RxWatermark -> PlicPeripheral::Uart0
    PlicPeripheral::Uart0,
    // Uart0TxDone -> PlicPeripheral::Uart0
    PlicPeripheral::Uart0,
    // Uart0RxOverflow -> PlicPeripheral::Uart0
    PlicPeripheral::Uart0,
    // Uart0RxFrameErr -> PlicPeripheral::Uart0
    PlicPeripheral::Uart0,
    // Uart0RxBreakErr -> PlicPeripheral::Uart0
    PlicPeripheral::Uart0,
    // Uart0RxTimeout -> PlicPeripheral::Uart0
    PlicPeripheral::Uart0,
    // Uart0RxParityErr -> PlicPeripheral::Uart0
    PlicPeripheral::Uart0,
    // Uart0TxEmpty -> PlicPeripheral::Uart0
    PlicPeripheral::Uart0,
    // Uart1TxWatermark -> PlicPeripheral::Uart1
    PlicPeripheral::Uart1,
    // Uart1RxWatermark -> PlicPeripheral::Uart1
    PlicPeripheral::Uart1,
    // Uart1TxDone -> PlicPeripheral::Uart1
    PlicPeripheral::Uart1,
    // Uart1RxOverflow -> PlicPeripheral::Uart1
    PlicPeripheral::Uart1,
    // Uart1RxFrameErr -> PlicPeripheral::Uart1
    PlicPeripheral::Uart1,
    // Uart1RxBreakErr -> PlicPeripheral::Uart1
    PlicPeripheral::Uart1,
    // Uart1RxTimeout -> PlicPeripheral::Uart1
    PlicPeripheral::Uart1,
    // Uart1RxParityErr -> PlicPeripheral::Uart1
    PlicPeripheral::Uart1,
    // Uart1TxEmpty -> PlicPeripheral::Uart1
    PlicPeripheral::Uart1,
    // GpioGpio0 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio1 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio2 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio3 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio4 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio5 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio6 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio7 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio8 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio9 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio10 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio11 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio12 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio13 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio14 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio15 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio16 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio17 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio18 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio19 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio20 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio21 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio22 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio23 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio24 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio25 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio26 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio27 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio28 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio29 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio30 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // GpioGpio31 -> PlicPeripheral::Gpio
    PlicPeripheral::Gpio,
    // SpiDeviceUploadCmdfifoNotEmpty -> PlicPeripheral::SpiDevice
    PlicPeripheral::SpiDevice,
    // SpiDeviceUploadPayloadNotEmpty -> PlicPeripheral::SpiDevice
    PlicPeripheral::SpiDevice,
    // SpiDeviceUploadPayloadOverflow -> PlicPeripheral::SpiDevice
    PlicPeripheral::SpiDevice,
    // SpiDeviceReadbufWatermark -> PlicPeripheral::SpiDevice
    PlicPeripheral::SpiDevice,
    // SpiDeviceReadbufFlip -> PlicPeripheral::SpiDevice
    PlicPeripheral::SpiDevice,
    // SpiDeviceTpmHeaderNotEmpty -> PlicPeripheral::SpiDevice
    PlicPeripheral::SpiDevice,
    // SpiDeviceTpmRdfifoCmdEnd -> PlicPeripheral::SpiDevice
    PlicPeripheral::SpiDevice,
    // SpiDeviceTpmRdfifoDrop -> PlicPeripheral::SpiDevice
    PlicPeripheral::SpiDevice,
    // SpiHost0Error -> PlicPeripheral::SpiHost0
    PlicPeripheral::SpiHost0,
    // SpiHost0SpiEvent -> PlicPeripheral::SpiHost0
    PlicPeripheral::SpiHost0,
    // UsbdevPktReceived -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevPktSent -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevDisconnected -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevHostLost -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevLinkReset -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevLinkSuspend -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevLinkResume -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevAvOutEmpty -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevRxFull -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevAvOverflow -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevLinkInErr -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevRxCrcErr -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevRxPidErr -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevRxBitstuffErr -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevFrame -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevPowered -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevLinkOutErr -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // UsbdevAvSetupEmpty -> PlicPeripheral::Usbdev
    PlicPeripheral::Usbdev,
    // PwrmgrAonWakeup -> PlicPeripheral::PwrmgrAon
    PlicPeripheral::PwrmgrAon,
    // AonTimerAonWkupTimerExpired -> PlicPeripheral::AonTimerAon
    PlicPeripheral::AonTimerAon,
    // AonTimerAonWdogTimerBark -> PlicPeripheral::AonTimerAon
    PlicPeripheral::AonTimerAon,
    // FlashCtrlProgEmpty -> PlicPeripheral::FlashCtrl
    PlicPeripheral::FlashCtrl,
    // FlashCtrlProgLvl -> PlicPeripheral::FlashCtrl
    PlicPeripheral::FlashCtrl,
    // FlashCtrlRdFull -> PlicPeripheral::FlashCtrl
    PlicPeripheral::FlashCtrl,
    // FlashCtrlRdLvl -> PlicPeripheral::FlashCtrl
    PlicPeripheral::FlashCtrl,
    // FlashCtrlOpDone -> PlicPeripheral::FlashCtrl
    PlicPeripheral::FlashCtrl,
    // FlashCtrlCorrErr -> PlicPeripheral::FlashCtrl
    PlicPeripheral::FlashCtrl,
];

/// Alert Handler Alert Source to Peripheral Map
///
/// This array is a mapping from `AlertId` to
/// `AlertPeripheral`.
pub const ALERT_FOR_PERIPHERAL: [AlertPeripheral; 28] = [
    // Uart0FatalFault -> AlertPeripheral::Uart0
    AlertPeripheral::Uart0,
    // Uart1FatalFault -> AlertPeripheral::Uart1
    AlertPeripheral::Uart1,
    // GpioFatalFault -> AlertPeripheral::Gpio
    AlertPeripheral::Gpio,
    // SpiDeviceFatalFault -> AlertPeripheral::SpiDevice
    AlertPeripheral::SpiDevice,
    // SpiHost0FatalFault -> AlertPeripheral::SpiHost0
    AlertPeripheral::SpiHost0,
    // RvTimerFatalFault -> AlertPeripheral::RvTimer
    AlertPeripheral::RvTimer,
    // UsbdevFatalFault -> AlertPeripheral::Usbdev
    AlertPeripheral::Usbdev,
    // PwrmgrAonFatalFault -> AlertPeripheral::PwrmgrAon
    AlertPeripheral::PwrmgrAon,
    // RstmgrAonFatalFault -> AlertPeripheral::RstmgrAon
    AlertPeripheral::RstmgrAon,
    // RstmgrAonFatalCnstyFault -> AlertPeripheral::RstmgrAon
    AlertPeripheral::RstmgrAon,
    // ClkmgrAonRecovFault -> AlertPeripheral::ClkmgrAon
    AlertPeripheral::ClkmgrAon,
    // ClkmgrAonFatalFault -> AlertPeripheral::ClkmgrAon
    AlertPeripheral::ClkmgrAon,
    // PinmuxAonFatalFault -> AlertPeripheral::PinmuxAon
    AlertPeripheral::PinmuxAon,
    // AonTimerAonFatalFault -> AlertPeripheral::AonTimerAon
    AlertPeripheral::AonTimerAon,
    // FlashCtrlRecovErr -> AlertPeripheral::FlashCtrl
    AlertPeripheral::FlashCtrl,
    // FlashCtrlFatalStdErr -> AlertPeripheral::FlashCtrl
    AlertPeripheral::FlashCtrl,
    // FlashCtrlFatalErr -> AlertPeripheral::FlashCtrl
    AlertPeripheral::FlashCtrl,
    // FlashCtrlFatalPrimFlashAlert -> AlertPeripheral::FlashCtrl
    AlertPeripheral::FlashCtrl,
    // FlashCtrlRecovPrimFlashAlert -> AlertPeripheral::FlashCtrl
    AlertPeripheral::FlashCtrl,
    // RvPlicFatalFault -> AlertPeripheral::RvPlic
    AlertPeripheral::RvPlic,
    // AesRecovCtrlUpdateErr -> AlertPeripheral::Aes
    AlertPeripheral::Aes,
    // AesFatalFault -> AlertPeripheral::Aes
    AlertPeripheral::Aes,
    // SramCtrlMainFatalError -> AlertPeripheral::SramCtrlMain
    AlertPeripheral::SramCtrlMain,
    // RomCtrlFatal -> AlertPeripheral::RomCtrl
    AlertPeripheral::RomCtrl,
    // RvCoreIbexFatalSwErr -> AlertPeripheral::RvCoreIbex
    AlertPeripheral::RvCoreIbex,
    // RvCoreIbexRecovSwErr -> AlertPeripheral::RvCoreIbex
    AlertPeripheral::RvCoreIbex,
    // RvCoreIbexFatalHwErr -> AlertPeripheral::RvCoreIbex
    AlertPeripheral::RvCoreIbex,
    // RvCoreIbexRecovHwErr -> AlertPeripheral::RvCoreIbex
    AlertPeripheral::RvCoreIbex,
];

// PERIPH_INSEL ranges from 0 to NUM_MIO_PADS + 2 -1}
//  0 and 1 are tied to value 0 and 1
pub const NUM_MIO_PADS: usize = 47;
pub const NUM_DIO_PADS: usize = 14;

pub const PINMUX_MIO_PERIPH_INSEL_IDX_OFFSET: usize = 2;
pub const PINMUX_PERIPH_OUTSEL_IDX_OFFSET: usize = 3;

/// Pinmux Peripheral Input.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum PinmuxPeripheralIn {
    /// Peripheral Input 0
    GpioGpio0 = 0,
    /// Peripheral Input 1
    GpioGpio1 = 1,
    /// Peripheral Input 2
    GpioGpio2 = 2,
    /// Peripheral Input 3
    GpioGpio3 = 3,
    /// Peripheral Input 4
    GpioGpio4 = 4,
    /// Peripheral Input 5
    GpioGpio5 = 5,
    /// Peripheral Input 6
    GpioGpio6 = 6,
    /// Peripheral Input 7
    GpioGpio7 = 7,
    /// Peripheral Input 8
    GpioGpio8 = 8,
    /// Peripheral Input 9
    GpioGpio9 = 9,
    /// Peripheral Input 10
    GpioGpio10 = 10,
    /// Peripheral Input 11
    GpioGpio11 = 11,
    /// Peripheral Input 12
    GpioGpio12 = 12,
    /// Peripheral Input 13
    GpioGpio13 = 13,
    /// Peripheral Input 14
    GpioGpio14 = 14,
    /// Peripheral Input 15
    GpioGpio15 = 15,
    /// Peripheral Input 16
    GpioGpio16 = 16,
    /// Peripheral Input 17
    GpioGpio17 = 17,
    /// Peripheral Input 18
    GpioGpio18 = 18,
    /// Peripheral Input 19
    GpioGpio19 = 19,
    /// Peripheral Input 20
    GpioGpio20 = 20,
    /// Peripheral Input 21
    GpioGpio21 = 21,
    /// Peripheral Input 22
    GpioGpio22 = 22,
    /// Peripheral Input 23
    GpioGpio23 = 23,
    /// Peripheral Input 24
    GpioGpio24 = 24,
    /// Peripheral Input 25
    GpioGpio25 = 25,
    /// Peripheral Input 26
    GpioGpio26 = 26,
    /// Peripheral Input 27
    GpioGpio27 = 27,
    /// Peripheral Input 28
    GpioGpio28 = 28,
    /// Peripheral Input 29
    GpioGpio29 = 29,
    /// Peripheral Input 30
    GpioGpio30 = 30,
    /// Peripheral Input 31
    GpioGpio31 = 31,
    /// Peripheral Input 32
    Uart0Rx = 32,
    /// Peripheral Input 33
    Uart1Rx = 33,
    /// Peripheral Input 34
    FlashCtrlTck = 34,
    /// Peripheral Input 35
    FlashCtrlTms = 35,
    /// Peripheral Input 36
    FlashCtrlTdi = 36,
    /// Peripheral Input 37
    UsbdevSense = 37,
}

impl TryFrom<u32> for PinmuxPeripheralIn {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::GpioGpio0),
            1 => Ok(Self::GpioGpio1),
            2 => Ok(Self::GpioGpio2),
            3 => Ok(Self::GpioGpio3),
            4 => Ok(Self::GpioGpio4),
            5 => Ok(Self::GpioGpio5),
            6 => Ok(Self::GpioGpio6),
            7 => Ok(Self::GpioGpio7),
            8 => Ok(Self::GpioGpio8),
            9 => Ok(Self::GpioGpio9),
            10 => Ok(Self::GpioGpio10),
            11 => Ok(Self::GpioGpio11),
            12 => Ok(Self::GpioGpio12),
            13 => Ok(Self::GpioGpio13),
            14 => Ok(Self::GpioGpio14),
            15 => Ok(Self::GpioGpio15),
            16 => Ok(Self::GpioGpio16),
            17 => Ok(Self::GpioGpio17),
            18 => Ok(Self::GpioGpio18),
            19 => Ok(Self::GpioGpio19),
            20 => Ok(Self::GpioGpio20),
            21 => Ok(Self::GpioGpio21),
            22 => Ok(Self::GpioGpio22),
            23 => Ok(Self::GpioGpio23),
            24 => Ok(Self::GpioGpio24),
            25 => Ok(Self::GpioGpio25),
            26 => Ok(Self::GpioGpio26),
            27 => Ok(Self::GpioGpio27),
            28 => Ok(Self::GpioGpio28),
            29 => Ok(Self::GpioGpio29),
            30 => Ok(Self::GpioGpio30),
            31 => Ok(Self::GpioGpio31),
            32 => Ok(Self::Uart0Rx),
            33 => Ok(Self::Uart1Rx),
            34 => Ok(Self::FlashCtrlTck),
            35 => Ok(Self::FlashCtrlTms),
            36 => Ok(Self::FlashCtrlTdi),
            37 => Ok(Self::UsbdevSense),
            _ => Err(val),
        }
    }
}

/// Pinmux MIO Input Selector.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum PinmuxInsel {
    /// Tie constantly to zero
    ConstantZero = 0,
    /// Tie constantly to one
    ConstantOne = 1,
    /// MIO Pad 0
    Ioa0 = 2,
    /// MIO Pad 1
    Ioa1 = 3,
    /// MIO Pad 2
    Ioa2 = 4,
    /// MIO Pad 3
    Ioa3 = 5,
    /// MIO Pad 4
    Ioa4 = 6,
    /// MIO Pad 5
    Ioa5 = 7,
    /// MIO Pad 6
    Ioa6 = 8,
    /// MIO Pad 7
    Ioa7 = 9,
    /// MIO Pad 8
    Ioa8 = 10,
    /// MIO Pad 9
    Iob0 = 11,
    /// MIO Pad 10
    Iob1 = 12,
    /// MIO Pad 11
    Iob2 = 13,
    /// MIO Pad 12
    Iob3 = 14,
    /// MIO Pad 13
    Iob4 = 15,
    /// MIO Pad 14
    Iob5 = 16,
    /// MIO Pad 15
    Iob6 = 17,
    /// MIO Pad 16
    Iob7 = 18,
    /// MIO Pad 17
    Iob8 = 19,
    /// MIO Pad 18
    Iob9 = 20,
    /// MIO Pad 19
    Iob10 = 21,
    /// MIO Pad 20
    Iob11 = 22,
    /// MIO Pad 21
    Iob12 = 23,
    /// MIO Pad 22
    Ioc0 = 24,
    /// MIO Pad 23
    Ioc1 = 25,
    /// MIO Pad 24
    Ioc2 = 26,
    /// MIO Pad 25
    Ioc3 = 27,
    /// MIO Pad 26
    Ioc4 = 28,
    /// MIO Pad 27
    Ioc5 = 29,
    /// MIO Pad 28
    Ioc6 = 30,
    /// MIO Pad 29
    Ioc7 = 31,
    /// MIO Pad 30
    Ioc8 = 32,
    /// MIO Pad 31
    Ioc9 = 33,
    /// MIO Pad 32
    Ioc10 = 34,
    /// MIO Pad 33
    Ioc11 = 35,
    /// MIO Pad 34
    Ioc12 = 36,
    /// MIO Pad 35
    Ior0 = 37,
    /// MIO Pad 36
    Ior1 = 38,
    /// MIO Pad 37
    Ior2 = 39,
    /// MIO Pad 38
    Ior3 = 40,
    /// MIO Pad 39
    Ior4 = 41,
    /// MIO Pad 40
    Ior5 = 42,
    /// MIO Pad 41
    Ior6 = 43,
    /// MIO Pad 42
    Ior7 = 44,
    /// MIO Pad 43
    Ior10 = 45,
    /// MIO Pad 44
    Ior11 = 46,
    /// MIO Pad 45
    Ior12 = 47,
    /// MIO Pad 46
    Ior13 = 48,
}

impl TryFrom<u32> for PinmuxInsel {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::ConstantZero),
            1 => Ok(Self::ConstantOne),
            2 => Ok(Self::Ioa0),
            3 => Ok(Self::Ioa1),
            4 => Ok(Self::Ioa2),
            5 => Ok(Self::Ioa3),
            6 => Ok(Self::Ioa4),
            7 => Ok(Self::Ioa5),
            8 => Ok(Self::Ioa6),
            9 => Ok(Self::Ioa7),
            10 => Ok(Self::Ioa8),
            11 => Ok(Self::Iob0),
            12 => Ok(Self::Iob1),
            13 => Ok(Self::Iob2),
            14 => Ok(Self::Iob3),
            15 => Ok(Self::Iob4),
            16 => Ok(Self::Iob5),
            17 => Ok(Self::Iob6),
            18 => Ok(Self::Iob7),
            19 => Ok(Self::Iob8),
            20 => Ok(Self::Iob9),
            21 => Ok(Self::Iob10),
            22 => Ok(Self::Iob11),
            23 => Ok(Self::Iob12),
            24 => Ok(Self::Ioc0),
            25 => Ok(Self::Ioc1),
            26 => Ok(Self::Ioc2),
            27 => Ok(Self::Ioc3),
            28 => Ok(Self::Ioc4),
            29 => Ok(Self::Ioc5),
            30 => Ok(Self::Ioc6),
            31 => Ok(Self::Ioc7),
            32 => Ok(Self::Ioc8),
            33 => Ok(Self::Ioc9),
            34 => Ok(Self::Ioc10),
            35 => Ok(Self::Ioc11),
            36 => Ok(Self::Ioc12),
            37 => Ok(Self::Ior0),
            38 => Ok(Self::Ior1),
            39 => Ok(Self::Ior2),
            40 => Ok(Self::Ior3),
            41 => Ok(Self::Ior4),
            42 => Ok(Self::Ior5),
            43 => Ok(Self::Ior6),
            44 => Ok(Self::Ior7),
            45 => Ok(Self::Ior10),
            46 => Ok(Self::Ior11),
            47 => Ok(Self::Ior12),
            48 => Ok(Self::Ior13),
            _ => Err(val),
        }
    }
}

/// Pinmux MIO Output.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum PinmuxMioOut {
    /// MIO Pad 0
    Ioa0 = 0,
    /// MIO Pad 1
    Ioa1 = 1,
    /// MIO Pad 2
    Ioa2 = 2,
    /// MIO Pad 3
    Ioa3 = 3,
    /// MIO Pad 4
    Ioa4 = 4,
    /// MIO Pad 5
    Ioa5 = 5,
    /// MIO Pad 6
    Ioa6 = 6,
    /// MIO Pad 7
    Ioa7 = 7,
    /// MIO Pad 8
    Ioa8 = 8,
    /// MIO Pad 9
    Iob0 = 9,
    /// MIO Pad 10
    Iob1 = 10,
    /// MIO Pad 11
    Iob2 = 11,
    /// MIO Pad 12
    Iob3 = 12,
    /// MIO Pad 13
    Iob4 = 13,
    /// MIO Pad 14
    Iob5 = 14,
    /// MIO Pad 15
    Iob6 = 15,
    /// MIO Pad 16
    Iob7 = 16,
    /// MIO Pad 17
    Iob8 = 17,
    /// MIO Pad 18
    Iob9 = 18,
    /// MIO Pad 19
    Iob10 = 19,
    /// MIO Pad 20
    Iob11 = 20,
    /// MIO Pad 21
    Iob12 = 21,
    /// MIO Pad 22
    Ioc0 = 22,
    /// MIO Pad 23
    Ioc1 = 23,
    /// MIO Pad 24
    Ioc2 = 24,
    /// MIO Pad 25
    Ioc3 = 25,
    /// MIO Pad 26
    Ioc4 = 26,
    /// MIO Pad 27
    Ioc5 = 27,
    /// MIO Pad 28
    Ioc6 = 28,
    /// MIO Pad 29
    Ioc7 = 29,
    /// MIO Pad 30
    Ioc8 = 30,
    /// MIO Pad 31
    Ioc9 = 31,
    /// MIO Pad 32
    Ioc10 = 32,
    /// MIO Pad 33
    Ioc11 = 33,
    /// MIO Pad 34
    Ioc12 = 34,
    /// MIO Pad 35
    Ior0 = 35,
    /// MIO Pad 36
    Ior1 = 36,
    /// MIO Pad 37
    Ior2 = 37,
    /// MIO Pad 38
    Ior3 = 38,
    /// MIO Pad 39
    Ior4 = 39,
    /// MIO Pad 40
    Ior5 = 40,
    /// MIO Pad 41
    Ior6 = 41,
    /// MIO Pad 42
    Ior7 = 42,
    /// MIO Pad 43
    Ior10 = 43,
    /// MIO Pad 44
    Ior11 = 44,
    /// MIO Pad 45
    Ior12 = 45,
    /// MIO Pad 46
    Ior13 = 46,
}

impl TryFrom<u32> for PinmuxMioOut {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::Ioa0),
            1 => Ok(Self::Ioa1),
            2 => Ok(Self::Ioa2),
            3 => Ok(Self::Ioa3),
            4 => Ok(Self::Ioa4),
            5 => Ok(Self::Ioa5),
            6 => Ok(Self::Ioa6),
            7 => Ok(Self::Ioa7),
            8 => Ok(Self::Ioa8),
            9 => Ok(Self::Iob0),
            10 => Ok(Self::Iob1),
            11 => Ok(Self::Iob2),
            12 => Ok(Self::Iob3),
            13 => Ok(Self::Iob4),
            14 => Ok(Self::Iob5),
            15 => Ok(Self::Iob6),
            16 => Ok(Self::Iob7),
            17 => Ok(Self::Iob8),
            18 => Ok(Self::Iob9),
            19 => Ok(Self::Iob10),
            20 => Ok(Self::Iob11),
            21 => Ok(Self::Iob12),
            22 => Ok(Self::Ioc0),
            23 => Ok(Self::Ioc1),
            24 => Ok(Self::Ioc2),
            25 => Ok(Self::Ioc3),
            26 => Ok(Self::Ioc4),
            27 => Ok(Self::Ioc5),
            28 => Ok(Self::Ioc6),
            29 => Ok(Self::Ioc7),
            30 => Ok(Self::Ioc8),
            31 => Ok(Self::Ioc9),
            32 => Ok(Self::Ioc10),
            33 => Ok(Self::Ioc11),
            34 => Ok(Self::Ioc12),
            35 => Ok(Self::Ior0),
            36 => Ok(Self::Ior1),
            37 => Ok(Self::Ior2),
            38 => Ok(Self::Ior3),
            39 => Ok(Self::Ior4),
            40 => Ok(Self::Ior5),
            41 => Ok(Self::Ior6),
            42 => Ok(Self::Ior7),
            43 => Ok(Self::Ior10),
            44 => Ok(Self::Ior11),
            45 => Ok(Self::Ior12),
            46 => Ok(Self::Ior13),
            _ => Err(val),
        }
    }
}

/// Pinmux Peripheral Output Selector.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum PinmuxOutsel {
    /// Tie constantly to zero
    ConstantZero = 0,
    /// Tie constantly to one
    ConstantOne = 1,
    /// Tie constantly to high-Z
    ConstantHighZ = 2,
    /// Peripheral Output 0
    GpioGpio0 = 3,
    /// Peripheral Output 1
    GpioGpio1 = 4,
    /// Peripheral Output 2
    GpioGpio2 = 5,
    /// Peripheral Output 3
    GpioGpio3 = 6,
    /// Peripheral Output 4
    GpioGpio4 = 7,
    /// Peripheral Output 5
    GpioGpio5 = 8,
    /// Peripheral Output 6
    GpioGpio6 = 9,
    /// Peripheral Output 7
    GpioGpio7 = 10,
    /// Peripheral Output 8
    GpioGpio8 = 11,
    /// Peripheral Output 9
    GpioGpio9 = 12,
    /// Peripheral Output 10
    GpioGpio10 = 13,
    /// Peripheral Output 11
    GpioGpio11 = 14,
    /// Peripheral Output 12
    GpioGpio12 = 15,
    /// Peripheral Output 13
    GpioGpio13 = 16,
    /// Peripheral Output 14
    GpioGpio14 = 17,
    /// Peripheral Output 15
    GpioGpio15 = 18,
    /// Peripheral Output 16
    GpioGpio16 = 19,
    /// Peripheral Output 17
    GpioGpio17 = 20,
    /// Peripheral Output 18
    GpioGpio18 = 21,
    /// Peripheral Output 19
    GpioGpio19 = 22,
    /// Peripheral Output 20
    GpioGpio20 = 23,
    /// Peripheral Output 21
    GpioGpio21 = 24,
    /// Peripheral Output 22
    GpioGpio22 = 25,
    /// Peripheral Output 23
    GpioGpio23 = 26,
    /// Peripheral Output 24
    GpioGpio24 = 27,
    /// Peripheral Output 25
    GpioGpio25 = 28,
    /// Peripheral Output 26
    GpioGpio26 = 29,
    /// Peripheral Output 27
    GpioGpio27 = 30,
    /// Peripheral Output 28
    GpioGpio28 = 31,
    /// Peripheral Output 29
    GpioGpio29 = 32,
    /// Peripheral Output 30
    GpioGpio30 = 33,
    /// Peripheral Output 31
    GpioGpio31 = 34,
    /// Peripheral Output 32
    Uart0Tx = 35,
    /// Peripheral Output 33
    Uart1Tx = 36,
    /// Peripheral Output 34
    FlashCtrlTdo = 37,
}

impl TryFrom<u32> for PinmuxOutsel {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::ConstantZero),
            1 => Ok(Self::ConstantOne),
            2 => Ok(Self::ConstantHighZ),
            3 => Ok(Self::GpioGpio0),
            4 => Ok(Self::GpioGpio1),
            5 => Ok(Self::GpioGpio2),
            6 => Ok(Self::GpioGpio3),
            7 => Ok(Self::GpioGpio4),
            8 => Ok(Self::GpioGpio5),
            9 => Ok(Self::GpioGpio6),
            10 => Ok(Self::GpioGpio7),
            11 => Ok(Self::GpioGpio8),
            12 => Ok(Self::GpioGpio9),
            13 => Ok(Self::GpioGpio10),
            14 => Ok(Self::GpioGpio11),
            15 => Ok(Self::GpioGpio12),
            16 => Ok(Self::GpioGpio13),
            17 => Ok(Self::GpioGpio14),
            18 => Ok(Self::GpioGpio15),
            19 => Ok(Self::GpioGpio16),
            20 => Ok(Self::GpioGpio17),
            21 => Ok(Self::GpioGpio18),
            22 => Ok(Self::GpioGpio19),
            23 => Ok(Self::GpioGpio20),
            24 => Ok(Self::GpioGpio21),
            25 => Ok(Self::GpioGpio22),
            26 => Ok(Self::GpioGpio23),
            27 => Ok(Self::GpioGpio24),
            28 => Ok(Self::GpioGpio25),
            29 => Ok(Self::GpioGpio26),
            30 => Ok(Self::GpioGpio27),
            31 => Ok(Self::GpioGpio28),
            32 => Ok(Self::GpioGpio29),
            33 => Ok(Self::GpioGpio30),
            34 => Ok(Self::GpioGpio31),
            35 => Ok(Self::Uart0Tx),
            36 => Ok(Self::Uart1Tx),
            37 => Ok(Self::FlashCtrlTdo),
            _ => Err(val),
        }
    }
}

/// Dedicated Pad Selects
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum DirectPads {
    SpiHost0Sd0 = 0,
    SpiHost0Sd1 = 1,
    SpiHost0Sd2 = 2,
    SpiHost0Sd3 = 3,
    SpiDeviceSd0 = 4,
    SpiDeviceSd1 = 5,
    SpiDeviceSd2 = 6,
    SpiDeviceSd3 = 7,
    UsbdevUsbDp = 8,
    UsbdevUsbDn = 9,
    SpiDeviceSck = 10,
    SpiDeviceCsb = 11,
    SpiHost0Sck = 12,
    SpiHost0Csb = 13,
}

impl TryFrom<u32> for DirectPads {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::SpiHost0Sd0),
            1 => Ok(Self::SpiHost0Sd1),
            2 => Ok(Self::SpiHost0Sd2),
            3 => Ok(Self::SpiHost0Sd3),
            4 => Ok(Self::SpiDeviceSd0),
            5 => Ok(Self::SpiDeviceSd1),
            6 => Ok(Self::SpiDeviceSd2),
            7 => Ok(Self::SpiDeviceSd3),
            8 => Ok(Self::UsbdevUsbDp),
            9 => Ok(Self::UsbdevUsbDn),
            10 => Ok(Self::SpiDeviceSck),
            11 => Ok(Self::SpiDeviceCsb),
            12 => Ok(Self::SpiHost0Sck),
            13 => Ok(Self::SpiHost0Csb),
            _ => Err(val),
        }
    }
}

/// Muxed Pad Selects
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum MuxedPads {
    Ioa0 = 0,
    Ioa1 = 1,
    Ioa2 = 2,
    Ioa3 = 3,
    Ioa4 = 4,
    Ioa5 = 5,
    Ioa6 = 6,
    Ioa7 = 7,
    Ioa8 = 8,
    Iob0 = 9,
    Iob1 = 10,
    Iob2 = 11,
    Iob3 = 12,
    Iob4 = 13,
    Iob5 = 14,
    Iob6 = 15,
    Iob7 = 16,
    Iob8 = 17,
    Iob9 = 18,
    Iob10 = 19,
    Iob11 = 20,
    Iob12 = 21,
    Ioc0 = 22,
    Ioc1 = 23,
    Ioc2 = 24,
    Ioc3 = 25,
    Ioc4 = 26,
    Ioc5 = 27,
    Ioc6 = 28,
    Ioc7 = 29,
    Ioc8 = 30,
    Ioc9 = 31,
    Ioc10 = 32,
    Ioc11 = 33,
    Ioc12 = 34,
    Ior0 = 35,
    Ior1 = 36,
    Ior2 = 37,
    Ior3 = 38,
    Ior4 = 39,
    Ior5 = 40,
    Ior6 = 41,
    Ior7 = 42,
    Ior10 = 43,
    Ior11 = 44,
    Ior12 = 45,
    Ior13 = 46,
}

impl TryFrom<u32> for MuxedPads {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::Ioa0),
            1 => Ok(Self::Ioa1),
            2 => Ok(Self::Ioa2),
            3 => Ok(Self::Ioa3),
            4 => Ok(Self::Ioa4),
            5 => Ok(Self::Ioa5),
            6 => Ok(Self::Ioa6),
            7 => Ok(Self::Ioa7),
            8 => Ok(Self::Ioa8),
            9 => Ok(Self::Iob0),
            10 => Ok(Self::Iob1),
            11 => Ok(Self::Iob2),
            12 => Ok(Self::Iob3),
            13 => Ok(Self::Iob4),
            14 => Ok(Self::Iob5),
            15 => Ok(Self::Iob6),
            16 => Ok(Self::Iob7),
            17 => Ok(Self::Iob8),
            18 => Ok(Self::Iob9),
            19 => Ok(Self::Iob10),
            20 => Ok(Self::Iob11),
            21 => Ok(Self::Iob12),
            22 => Ok(Self::Ioc0),
            23 => Ok(Self::Ioc1),
            24 => Ok(Self::Ioc2),
            25 => Ok(Self::Ioc3),
            26 => Ok(Self::Ioc4),
            27 => Ok(Self::Ioc5),
            28 => Ok(Self::Ioc6),
            29 => Ok(Self::Ioc7),
            30 => Ok(Self::Ioc8),
            31 => Ok(Self::Ioc9),
            32 => Ok(Self::Ioc10),
            33 => Ok(Self::Ioc11),
            34 => Ok(Self::Ioc12),
            35 => Ok(Self::Ior0),
            36 => Ok(Self::Ior1),
            37 => Ok(Self::Ior2),
            38 => Ok(Self::Ior3),
            39 => Ok(Self::Ior4),
            40 => Ok(Self::Ior5),
            41 => Ok(Self::Ior6),
            42 => Ok(Self::Ior7),
            43 => Ok(Self::Ior10),
            44 => Ok(Self::Ior11),
            45 => Ok(Self::Ior12),
            46 => Ok(Self::Ior13),
            _ => Err(val),
        }
    }
}

/// Power Manager Wakeup Signals
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum PowerManagerWakeUps {
    PinmuxAonPinWkupReq = 0,
    PinmuxAonUsbWkupReq = 1,
    AonTimerAonWkupReq = 2,
}

/// Reset Manager Software Controlled Resets
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum ResetManagerSwResets {
    SpiDevice = 0,
    SpiHost0 = 1,
    Usb = 2,
}

/// Power Manager Reset Request Signals
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum PowerManagerResetRequests {
    AonTimerAonAonTimerRstReq = 0,
}

/// Clock Manager Software-Controlled ("Gated") Clocks.
///
/// The Software has full control over these clocks.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum GateableClocks {
    /// Clock clk_io_div4_peri in group peri
    IoDiv4Peri = 0,
    /// Clock clk_io_div2_peri in group peri
    IoDiv2Peri = 1,
    /// Clock clk_io_peri in group peri
    IoPeri = 2,
    /// Clock clk_usb_peri in group peri
    UsbPeri = 3,
}

/// Clock Manager Software-Hinted Clocks.
///
/// The Software has partial control over these clocks. It can ask them to stop,
/// but the clock manager is in control of whether the clock actually is stopped.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum HintableClocks {
    /// Clock clk_main_aes in group trans
    MainAes = 0,
}

/// MMIO Region
///
/// MMIO region excludes any memory that is separate from the module
/// configuration space, i.e. ROM, main SRAM, and flash are excluded but
/// retention SRAM, spi_device memory, or usbdev memory are included.
pub const MMIO_BASE_ADDR: usize = 0x40000000;
pub const MMIO_SIZE_BYTES: usize = 0x10000000;
