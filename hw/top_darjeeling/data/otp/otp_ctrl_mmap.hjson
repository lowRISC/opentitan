// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Use the gen-otp-mmap.py script to update dependent files (like documentation
// tables the comportable hjson and metadata SV package):
//
// $ ./util/design/gen-otp-mmap.py
//
// Make sure to regenerate the CSRs after converting the memory map:
//
// $ cd ${PROJ_ROOT}
// $ make -C hw regs
//

{
    otp: {
        width: "2", // bytes
        depth: "10240"
    }

    // Definition of scrambling and digest constants and keys.
    scrambling: {
        key_size:  "16",
        iv_size:   "8",
        cnst_size: "16",
        keys: [
            {
                name:  "Secret0Key",
                value: "<random>",
            }
            {
                name:  "Secret1Key",
                value: "<random>",
            }
            {
                name:  "Secret2Key",
                value: "<random>",
            }
            {
                name:  "Secret3Key",
                value: "<random>",
            }
        ]
        digests: [
            // This is the consistency digest used by all partitions.
            {
                name:       "CnstyDigest",
                iv_value:   "<random>",
                cnst_value: "<random>",
            }
            // The other digest configurations below are used for
            // key derivation and token hashing.
            {
                name:       "SramDataKey",
                iv_value:   "<random>",
                cnst_value: "<random>",
            }
        ]
    }


    // The enumeration order below defines OTP address map,
    // unless the offsets are assigned explicitly via the "offset" key.
    // Note that the digest items are added automatically to the address map.
    partitions: [
        {
            name:           "VENDOR_TEST",
            variant:        "Unbuffered",
            absorb:         false,
            secret:         false,
            sw_digest:      true,
            hw_digest:      false,
            write_lock:     "Digest",
            read_lock:      "CSR",
            key_sel:        "NoKey",
            integrity:      false, // Do not use integrity (ECC) on this partition.
            bkout_type:     false, // Do not generate a breakout type for this partition.
            zeroizable:     true
            skip_sw_header: true,
            items: [
                {
                    name: "SCRATCH",
                    size: "56"
                }
            ],
            desc: '''Vendor test partition.
            This is reserved for manufacturing smoke checks. The OTP wrapper
            control logic inside prim_otp is allowed to read/write to this
            region. ECC uncorrectable errors seen on the functional prim_otp
            interface will not lead to an alert for this partition.
            Instead, such errors will be reported as correctable ECC errors.
            '''
        }
        {
            name:       "CREATOR_SW_CFG",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,  // Use integrity (ECC) on this partition.
            bkout_type: false, // Do not generate a breakout type for this partition.
            zeroizable: true,
            items: [
                {
                    name: "CREATOR_SW_CFG_AST_CFG",
                    size: "124",
                    desc: '''
                    AST configuration data. These values get blindly copied to
                    the AST CSRs during ROM execution.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_AST_INIT_SIZE",
                    size: "4",
                    desc: '''
                    Controls how many 32-bit words from the CREATOR_SW_CFG_AST_CFG item
                    get copied to the AST CSRs during ROM execution.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_ROM_SECURE_BOOT_EN",
                    size: "4",
                    ismubi: true,
                    inv_default: false,
                    desc: '''
                    Secure boot chicken bit. Secure boot is enabled iff this is
                    set to kMultiBitBool32True. OTBN is not loaded with any code
                    for any other values.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_ROM_SIGGEN_EN",
                    size: "4",
                    ismubi: true,
                    inv_default: false,
                    desc: '''
                    Signature generation chicken bit. Asset signatures are
                    generated iff both this item and
                    CREATOR_SW_CFG_ROM_SECURE_BOOT_EN are set to
                    kMultiBitBool32True.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_ROM_SIGVERIFY_EN",
                    size: "4",
                    ismubi: true,
                    inv_default: false,
                    desc: '''
                    Signature verification chicken bit. Asset signatures are
                    verified iff this item, the CREATOR_SW_CFG_ROM_SECURE_BOOT_EN
                    and the CREATOR_SW_CFG_ROM_SIGGEN_EN ones are all set to
                    kMultiBitBool32True.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_SIGVERIFY_SPX_EN",
                    size: "4",
                    desc: '''
                    Controls whether or not SPHINCS+ signature verification will
                    be executed when the ROM attempts to boot the ROM_EXT.
                    A value of kSigverifySpxDisabledOtp disables SPHINCS+
                    signature verification, while all other values enable it.
                    Note, SPHINCS+ signature verification is always disabled in
                    TEST_UNLOCKED* LC states.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_RNG_EN",
                    size: "4",
                    desc: '''
                    Whether or not to enable use of hardware generated entropy
                    (from the entropy complex via EDN) in the `rnd_uint32`
                    function. A value of kHardenedBoolTrue enables the use of
                    hardware generated entropy, while all other values disable.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_JITTER_EN",
                    size: "4",
                    desc: '''
                    Whether or not to enable clock jitter. A value of
                    kMultiBitBool4False disables, while all other values enable.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_RET_RAM_RESET_MASK",
                    size: "4",
                    desc: '''
                    Reset reason mask used to initialize (by overwriting with
                    random data) retention SRAM during ROM execution. A value of
                    0 only initializes retention SRAM on power-on-resets.See
                    rstmgr RESET_INFO CSR documentation for more details.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_CPUCTRL",
                    size: "4",
                    desc: '''
                    Value to write to the Ibex CPUCTRL CSR during ROM execution.
                    This field controls settings such as ICACHE enablement. See
                    Ibex documentation for more information.
                    '''
                }
                {
                    name: "CREATOR_SW_CFG_RNG_REPCNT_THRESHOLDS",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_REPCNTS_THRESHOLDS",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_ADAPTP_HI_THRESHOLDS",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_ADAPTP_LO_THRESHOLDS",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_BUCKET_THRESHOLDS",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_MARKOV_HI_THRESHOLDS",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_MARKOV_LO_THRESHOLDS",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_EXTHT_HI_THRESHOLDS",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_EXTHT_LO_THRESHOLDS",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_ALERT_THRESHOLD",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_RNG_HEALTH_CONFIG_DIGEST",
                    size: "4"
                }
                {
                    name: "CREATOR_SW_CFG_SRAM_KEY_RENEW_EN",
                    size: "4",
                    desc: '''
                    Whether or not the ROM should request SRAM to be re-scrambled
                    with a new key on every boot. kHardenedBoolFalse disables,
                    while all other values enable.
                    '''
                }
            ],
            desc: '''Software configuration partition.
            This is for device-specific calibration data. For example, clock,
            LDO, RNG.
            '''
        }
        {
            name:       "OWNER_SW_CFG",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "OWNER_SW_CFG_ROM_ERROR_REPORTING",
                    size: "4",
                    desc: '''
                    The shutdown error reporting verbosity used by the ROM.
                    Should be configured to one of several
                    `shutdown_error_redact_t` values. See
                    `sw/device/silicon_creator/lib/shutdown.h` for more details.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_CLASS_EN",
                    size: "4",
                    desc: '''
                    A four byte packed field, where each byte controls whether
                    or not the ROM enables each alert class (A through D) of the
                    alert_handler. The byte-sized sub-fields are arranged from D
                    to A, MSB to LSB. Each byte should be set to an
                    `alert_enable_t` value accordingly. See the alert_handler
                    documentation for more details.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_ESCALATION",
                    size: "4",
                    desc: '''
                    A four byte packed field, where each byte controls the
                    escalation configuration for each alert class (A through D)
                    of the alert_handler configured by the ROM. The byte-sized
                    sub-fields are arranged from D to A, MSB to LSB. Each byte
                    should be set to an `alert_escalate_t` value accordingly.
                    See the alert_handler documentation for more details.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_CLASSIFICATION",
                    size: "788",
                    desc: '''
                    The alert classifications (A through D) for each alert
                    source of the alert_handler to be configured by the ROM. The
                    field consists of a contiguous 320-byte block, or 80 32-bit
                    words. The four bytes in each word encode the configuration
                    of a single alert source across four lifecycle states, in
                    order from LSB to MSB: PROD, PROD_END, DEV, and RMA. Each
                    byte should be set to an `alert_class_t` value accordingly.
                    The order of the 197 32-bit words, from LSB to MSB can be
                    found in the DARJEELING_ALERTS list in
                    `hw/top_darjeeling/data/autogen/defs.bzl`.
                    See the alert_handler documentation for more details.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_LOCAL_ALERT_CLASSIFICATION",
                    size: "28",
                    desc: '''
                    Same as the `OWNER_SW_CFG_ROM_ALERT_CLASSIFICATION` field,
                    except these configuration correspond to the local alert
                    sources found in the `DARJEELING_LOC_ALERTS list in
                    `rules/const.bzl`.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_ACCUM_THRESH",
                    size: "16",
                    desc: '''
                    The alert accumulation threshold values for each alert class
                    (A through D) of the alert_handler to be configured by the
                    ROM. This field consists of four 32-bit words encoding the
                    accumulation thresholds for each alert class A through D
                    arranged LSW to MSW. See the alert_handler documentation for
                    more details.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_TIMEOUT_CYCLES",
                    size: "16",
                    desc: '''
                    Same as the `OWNER_SW_CFG_ROM_ALERT_ACCUM_THRESH` field,
                    except each value corresponds to the interrupt timeout
                    configuration of an alert class.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_PHASE_CYCLES",
                    size: "64",
                    desc: '''
                    The alert escalation phase durations, measured in clock
                    cycles, the ROM will configure the four alert phases for
                    each alert class of the alert_handler. This field consists
                    of a contiguous 64-byte block, or an array of four 128-bit
                    fields. Each 128-bit sub-field encodes four 32-bit words that
                    contain the alert phase cycle count configurations for alert
                    escalation phases 0 to 3, from LSW to MSW. Each 128-bit
                    sub-field is contains all configurations for a single alert
                    class, arranged from class A to D, from LS to MS. For
                    example, the cycle durations of each escalation phase in
                    this field should be configured as such, from LSB to MSB:
                    <classA,phase0>...<classA,phase3>...<classD,phase0>...
                    <classD,phase3>. See the alert_handler documentation for
                    more details.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_DIGEST_PROD",
                    size: "4",
                    desc: '''
                    The expected CRC32 digest over all of the alert_handler
                    configurations set up by the ROM for a device operating in
                    the PROD LC state. The ROM reads this field and checks it
                    against a digest it computes over the alert_handler
                    configuration it programmed. This field is expected to be
                    automatically computed by the `otp_alert_digest()` Bazel
                    rule. See the `alert_config_crc32()` function in the
                    SiliconCreator alert_handler driver for more details on what
                    configurations are included in this digest.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_DIGEST_PROD_END",
                    size: "4",
                    desc: '''
                    Same as the `OWNER_SW_CFG_ROM_ALERT_DIGEST_PROD` field,
                    except the expected digest is for chips operating in the
                    PROD_END LC state.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_DIGEST_DEV",
                    size: "4",
                    desc: '''
                    Same as the `OWNER_SW_CFG_ROM_ALERT_DIGEST_PROD` field,
                    except the expected digest is for chips operating in the
                    DEV LC state.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_ALERT_DIGEST_RMA",
                    size: "4",
                    desc: '''
                    Same as the `OWNER_SW_CFG_ROM_ALERT_DIGEST_PROD` field,
                    except the expected digest is for chips operating in the
                    RMA LC state.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_WATCHDOG_BITE_THRESHOLD_CYCLES",
                    size: "4",
                    desc: '''
                    Watchdog timer bite threshold (in cycles) configured by the ROM.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_KEYMGR_OTP_MEAS_EN",
                    size: "4",
                    desc: '''
                    Whether or not to configure the attestation SW binding CSRs
                    of the keymgr with the value of the measurement of the OTP
                    CreatorSwCfg, OwnerSwCfg, and secure boot key integrity digest.
                    A value of kHardenedBoolTrue uses the ROM computed OTP
                    measurements.
                    '''
                }
                {
                    name: "OWNER_SW_CFG_ROM_RSTMGR_INFO_EN",
                    size: "4",
                    desc: '''
                    A two byte packed word that indicates the expected rstmgr
                    alert and CPU info dump enable states, configured in the
                    rstmgr's ALERT_INFO_CTRL and CPU_INFO_CTRL CSRs respectively.
                    The expected format of this fields is
                    {0,0,kHardenedBool*,kHardenedBool*}, read MSB to LSB, where
                    the left most kHardenedBool* entry indicates the expected
                    enablement state of the ALERT_INFO_CTRL, and the right most
                    indicates the enablement state of the CPU_INFO_CTRL. Since
                    the ROM expects both to be disabled upon handing over
                    execution control to the ROM_EXT, this entire OTP field
                    **should be left unprovisioned, or set to all 0**.
                    '''
                }
            ],
            desc: '''Software configuration partition.
            This contains data that changes software behavior in the ROM, for
            example enabling defensive features in ROM or selecting failure
            modes if verification fails.
            '''
        }
        {
            name:       "OWNERSHIP_SLOT_STATE",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  false,
            hw_digest:  false,
            write_lock: "None",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "OWNERSHIP_SLOT_STATE_ROT_OWNER_AUTH",
                    size: "16"
                    desc: ''' RoT Owner Ownership transfer state management
                    OWNERSHIP_ST_RAW:       ownership not yet claimed (factory default)
                    OWNERSHIP_ST_LOCKED0:   first ownership slot claimed
                    OWNERSHIP_ST_RELEASED0: first ownership slot released (assets have been cleared, ready to xfer)
                    OWNERSHIP_ST_LOCKED1:   second ownership slot claimed
                    OWNERSHIP_ST_SCRAPPED:  scrap state - terminal
                    '''
                }
                {
                    name: "OWNERSHIP_SLOT_STATE_PLAT_INTEG_AUTH",
                    size: "16"
                    desc: ''' Platform Integrator Ownership transfer state management
                    OWNERSHIP_ST_RAW:       ownership not yet claimed (factory default)
                    OWNERSHIP_ST_LOCKED0:   first ownership slot claimed
                    OWNERSHIP_ST_RELEASED0: first ownership slot released (assets have been cleared, ready to xfer)
                    OWNERSHIP_ST_LOCKED1:   second ownership slot claimed
                    OWNERSHIP_ST_SCRAPPED:  scrap state - terminal
                    '''
                }
                {
                    name: "OWNERSHIP_SLOT_STATE_PLAT_OWNER_AUTH",
                    size: "16"
                    desc: ''' Platform Owner Ownership transfer state management
                    OWNERSHIP_ST_RAW:       ownership not yet claimed (factory default)
                    OWNERSHIP_ST_LOCKED0:   first ownership slot claimed
                    OWNERSHIP_ST_RELEASED0: first ownership slot released (assets have been cleared, ready to xfer)
                    OWNERSHIP_ST_LOCKED1:   second ownership slot claimed
                    OWNERSHIP_ST_RELEASED1: second ownership slot released (assets have been cleared, ready to xfer)
                    OWNERSHIP_ST_LOCKED2:   third ownership slot claimed
                    OWNERSHIP_ST_RELEASED2: third ownership slot released (assets have been cleared, ready to xfer)
                    OWNERSHIP_ST_LOCKED3:   fourth ownership slot claimed
                    OWNERSHIP_ST_SCRAPPED:  scrap state - terminal
                    '''
                }
            ]
            desc: '''SW managed asset ownership states partition.

            Multi-bit enable value for the tracking the asset ownership states.
            Note that the states can be written multiple times in a device lifetime.
            The values to be written are engineered in the same way as the LC_CTRL
            state encoding words so that the ECC encoding remains valid even after
            updating the values.

            The constants can be found in the lc_ctrl_state_pkg.sv package.

            The programming order has to adhere to:

            OWNERSHIP_ST_RAW (factory all-zero state) ->
            OWNERSHIP_ST_LOCKED0 ->
            OWNERSHIP_ST_RELEASED0 ->
            ...
            OWNERSHIP_ST_SCRAPPED

            Note that if there are less than 4 slots available the higher slot states
            become logically equivalent to OWNERSHIP_SCRAPPED (firmware has to handle
            this correctly).
            '''
        }
        {
            name:       "ROT_CREATOR_IDENTITY",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "ROT_CREATOR_IDENTITY_CERT",
                    size: "768"
                    desc: ''' RoT Device Identity Certificate endorsed by the Silicon Creator stable PKI (off device).
                    It is expected to be provisioned at Factory Testing (FT) stage when LC = DEV or PROD.
                    Provisioning happens through a secured channel between the DUT and the HSM, i.e. the key
                    is protected against supply-chain and manufacturing attacks.
                    '''
                }
                {
                    name: "ROT_CREATOR_IDENTITY_CERT_CMAC",
                    size: "16"
                    desc: ''' A Cipher-based MAC for the RoT Device Identity Certificate.
                    '''
                }
            ],
            desc: '''Software managed partition for the RoT Creator identity.
            '''
        }
        {
            name:       "ROT_OWNER_AUTH_SLOT0",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "ROT_OWNER_AUTH_SLOT0_NON_RAW_MFW_CODESIGN_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_NON_RAW_MFW_CODESIGN_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleBootstrapFirmwareSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_NON_RAW_MFW_CODESIGN_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify manufacturing and debug firmware images.
                    Key Type: ECC NIST-P256 Curve.
                    It is expected to be provisioned at Final Test (FT) stage when LC = TEST_UNLOCKED.
                    Together with the ROM2_PATCH_SIGVERIFY_KEY and KEYMANIFEST_KEY keys, and their
                    associated device ID and metadata (stored in resp. KEY_DEVICE_ID and KEY_METADATA),
                    this key is signed with a Silicon Creator endorsed ECDSA P-256 key in order to protect
                    it from supply-chain and manufacturing attacks.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_ROM2_PATCH_SIGVERIFY_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_ROM2_PATCH_SIGVERIFY_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleRomPatchSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_ROM2_PATCH_SIGVERIFY_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the ROM2 OTP based patch.
                    Key Type: ECC NIST-P256 Curve.
                    It is expected to be provisioned at Final Test (FT) stage when LC = TEST_UNLOCKED.
                    Together with the NON_RAW_MFW_CODESIGN_KEY and KEYMANIFEST_KEY keys, and their
                    associated device ID and metadata (stored in resp. KEY_DEVICE_ID and KEY_METADATA),
                    this key is signed with a Silicon Creator endorsed ECDSA P-256 key in order to protect
                    it from supply-chain and manufacturing attacks.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_KEYMANIFEST_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_KEYMANIFEST_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleKeyBundleSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_KEYMANIFEST_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the RoT Creator (a.k.a. Silicon Creator) Key Manifest.
                    Key Type: ECC NIST-P256 Curve.
                    Together with the ROM2_PATCH_SIGVERIFY_KEY and NON_RAW_MFW_CODESIGN_KEY keys, and their
                    associated device ID and metadata (stored in resp. KEY_DEVICE_ID and KEY_METADATA),
                    this key is signed with a Silicon Creator endorsed ECDSA P-256 key in order to protect
                    it from supply-chain and manufacturing attacks.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_KEY_BINDING",
                    size: "64"
                    desc: ''' A key binding value used to bind the ROT_OWNER_AUTH_SLOT0 keys to a SKU.
                    This item must store a SKU specific payload known at FT, like for example a fused
                    product identitfier or a ROM constant. The base ROM must verify the authenticity of
                    the ROT_OWNER_AUTH_SLOT0 first and then match the KEY_BINDING via an inline ROM check
                    before it uses the keys provisioned in this partition.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT0_KEY_SIGNATURE",
                    size: "64"
                    desc: ''' ECDSA P-256 signature of the NON_RAW_MFW_CODESIGN_KEY,
                    ROM2_PATCH_SIGVERIFY_KEY, KEYMANIFEST_KEY, KEY_BINDING items in this partition.
                    As those three keys are expected to be provisioned at Final Test (FT) stage when
                    LC = TEST_UNLOCKED, this signatures aims at protecting them from supply-chain and
                    manufacturing attacks.
                    ROM images must include the corresponding signing key in order to verify all three
                    signatures.
                    '''
                }
            ],
            desc: '''Software managed partition for the first RoT Owner (a.k.a. RoT Creator) key manifest.
            '''
        }
        {
            name:       "ROT_OWNER_AUTH_SLOT1",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "ROT_OWNER_AUTH_SLOT1_NON_RAW_MFW_CODESIGN_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_NON_RAW_MFW_CODESIGN_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleBootstrapFirmwareSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_NON_RAW_MFW_CODESIGN_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify manufacturing and debug firmware images.
                    Key Type: ECC NIST-P256 Curve.
                    It is expected to be provisioned at Final Test (FT) stage when LC = TEST_UNLOCKED.
                    Together with the ROM2_PATCH_SIGVERIFY_KEY and KEYMANIFEST_KEY keys, and their
                    associated device ID and metadata (stored in resp. KEY_DEVICE_ID and KEY_METADATA),
                    this key is signed with a Silicon Creator endorsed ECDSA P-256 key in order to protect
                    it from supply-chain and manufacturing attacks.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_ROM2_PATCH_SIGVERIFY_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_ROM2_PATCH_SIGVERIFY_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleRomPatchSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_ROM2_PATCH_SIGVERIFY_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the ROM2 OTP based patch.
                    Key Type: ECC NIST-P256 Curve.
                    It is expected to be provisioned at Final Test (FT) stage when LC = TEST_UNLOCKED.
                    Together with the NON_RAW_MFW_CODESIGN_KEY and KEYMANIFEST_KEY keys, and their
                    associated device ID and metadata (stored in resp. KEY_DEVICE_ID and KEY_METADATA),
                    this key is signed with a Silicon Creator endorsed ECDSA P-256 key in order to protect
                    it from supply-chain and manufacturing attacks.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_KEYMANIFEST_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_KEYMANIFEST_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleKeyBundleSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_KEYMANIFEST_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the RoT Owner (a.k.a. Silicon Owner) Key Manifest.
                    Key Type: ECC NIST-P256 Curve.
                    It is expected to be provisioned as part of the RoT Owner intra-role ownership transfer
                    process, when LC = PROD.
                    Provisioning happens through an Ownership Claim operation, after the previous RoT
                    Owner completed a Relinquish operation.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_UNLOCK4XFER_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_UNLOCK4XFER_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleRelinquishOwnership` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "ROT_OWNER_AUTH_SLOT1_UNLOCK4XFER_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the RoT Owner Unlock Ownership firmware image.
                    Key Type: ECC NIST-P256 Curve.
                    It is expected to be provisioned as part of the RoT Owner intra-role ownership transfer
                    process, when LC = PROD.
                    Provisioning happens through an Ownership Claim operation, after the previous RoT
                    Owner completed a Relinquish operation.
                    '''
                }
            ],
            desc: '''Software managed RoT Owner slot 1 partition.
            '''
        }
        {
            name:       "PLAT_INTEG_AUTH_SLOT0",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "PLAT_INTEG_AUTH_SLOT0_KEYMANIFEST_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT0_KEYMANIFEST_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleKeyBundleSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT0_KEYMANIFEST_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Integrator Key Manifest.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Integrator Activation process, at the Platform
                    Integrator's manufacturing facilities.
                    The initial Platform Integrator provisions its Key Manifest public key using the provisioning
                    boot service provided by the current RoT Owner.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT0_UNLOCK4XFER_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT0_UNLOCK4XFER_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleRelinquishOwnership` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT0_UNLOCK4XFER_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Integrator Unlock Ownership firmware image.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Integrator Activation process, at the Platform
                    Integrator's manufacturing facilities.
                    The initial Platform Integrator provisions its Key Manifest public key using the provisioning
                    boot service provided by the current RoT Owner.
                    '''
                }
            ],
            desc: '''Software managed Platform Integrator slot 0 partition.
            '''
        }
        {
            name:       "PLAT_INTEG_AUTH_SLOT1",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "PLAT_INTEG_AUTH_SLOT1_KEYMANIFEST_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT1_KEYMANIFEST_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleKeyBundleSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT1_KEYMANIFEST_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Integrator Key Manifest.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Integrator intra-role ownership transfer
                    process when the lifecycle state (LC) is PROD. Provisioning occurs via an Ownership Claim
                    operation after the previous Platform Integrator completes a Relinquish operation.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT1_UNLOCK4XFER_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT1_UNLOCK4XFER_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleRelinquishOwnership` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_INTEG_AUTH_SLOT1_UNLOCK4XFER_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Integrator Unlock Ownership firmware image
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Integrator intra-role ownership transfer
                    process when the lifecycle state (LC) is PROD. Provisioning occurs via an Ownership Claim
                    operation after the previous Platform Integrator completes a Relinquish operation.
                    '''
                }
            ],
            desc: '''Software managed Platform Integrator slot 1 partition.
            '''
        }
        {
            name:       "PLAT_OWNER_AUTH_SLOT0",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "PLAT_OWNER_AUTH_SLOT0_KEYMANIFEST_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT0_KEYMANIFEST_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleKeyBundleSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT0_KEYMANIFEST_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Owner Key Manifest.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Owner Activation process, at the Platform
                    Owner's facilities.
                    The initial Platform Owner provisions its Key Manifest public key using the provisioning
                    boot service provided by the current RoT Owner.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT0_UNLOCK4XFER_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT0_UNLOCK4XFER_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleRelinquishOwnership` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT0_UNLOCK4XFER_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Owner Unlock Ownership firmware image.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Owner Activation process, at the Platform
                    Owner's facilities.
                    The initial Platform Owner provisions its Key Manifest public key using the provisioning
                    boot service provided by the current RoT Owner.
                    '''
                }
            ],
            desc: '''Software managed Platform Owner slot 0 partition.
            '''
        }
        {
            name:       "PLAT_OWNER_AUTH_SLOT1",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "PLAT_OWNER_AUTH_SLOT1_KEYMANIFEST_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT1_KEYMANIFEST_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleKeyBundleSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT1_KEYMANIFEST_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Owner Key Manifest.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Owner intra-role ownership transfer
                    process when the lifecycle state (LC) is PROD. Provisioning occurs via an Ownership Claim
                    operation after the previous Platform Owner completes a Relinquish operation.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT1_UNLOCK4XFER_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT1_UNLOCK4XFER_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleRelinquishOwnership` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT1_UNLOCK4XFER_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Owner Unlock Ownership firmware image.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Owner intra-role ownership transfer
                    process when the lifecycle state (LC) is PROD. Provisioning occurs via an Ownership Claim
                    operation after the previous Platform Owner completes a Relinquish operation.
                    '''
                }
            ],
            desc: '''Software managed Platform Owner slot 1 partition.
            '''
        }
        {
            name:       "PLAT_OWNER_AUTH_SLOT2",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "PLAT_OWNER_AUTH_SLOT2_KEYMANIFEST_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT2_KEYMANIFEST_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleKeyBundleSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT2_KEYMANIFEST_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Owner Key Manifest.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Owner intra-role ownership transfer
                    process when the lifecycle state (LC) is PROD. Provisioning occurs via an Ownership Claim
                    operation after the previous Platform Owner completes a Relinquish operation.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT2_UNLOCK4XFER_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT2_UNLOCK4XFER_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleRelinquishOwnership` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT2_UNLOCK4XFER_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Owner Unlock Ownership firmware image.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Owner intra-role ownership transfer
                    process when the lifecycle state (LC) is PROD. Provisioning occurs via an Ownership Claim
                    operation after the previous Platform Owner completes a Relinquish operation.
                    '''
                }
            ],
            desc: '''Software managed Platform Owner slot 2 partition.
            '''
        }
        {
            name:       "PLAT_OWNER_AUTH_SLOT3",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "PLAT_OWNER_AUTH_SLOT3_KEYMANIFEST_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT3_KEYMANIFEST_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleKeyBundleSigning` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT3_KEYMANIFEST_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Owner Key Manifest.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Owner intra-role ownership transfer
                    process when the lifecycle state (LC) is PROD. Provisioning occurs via an Ownership Claim
                    operation after the previous Platform Owner completes a Relinquish operation.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT3_UNLOCK4XFER_KEY_TYPE",
                    size: "4"
                    desc: ''' Key usage type. One of the following 32-bit values defined
                    by the sigverify API:
                    - kSigverifyKeyTypeTest for manufacturing, testing and RMA keys.
                    Keys of this type can be used only in TEST_UNLOCKED* and RMA life
                    cycle states.
                    - kSigverifyKeyTypeProd for production keys.
                    Keys of this type can be used in all operational life cycle states, i.e.
                    states in which CPU execution is enabled.
                    - kSigverifyKeyTypeDev for development keys.
                    Keys of this type can be used only in the DEV life cycle state.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT3_UNLOCK4XFER_KEY_ROLE",
                    size: "4"
                    desc: ''' Key role that describes the kind of assets a key could sign.
                    This must be set to the `kSigverifyKeyRoleRelinquishOwnership` 32-bit
                    value as defined by the sigverify API.
                    '''
                }
                {
                    name: "PLAT_OWNER_AUTH_SLOT3_UNLOCK4XFER_KEY",
                    size: "64"
                    desc: ''' Public Key used to verify the Platform Owner Unlock Ownership firmware image.
                    Key Type: ECC NIST-P256 Curve.
                    This should be provisioned during the Platform Owner intra-role ownership transfer
                    process when the lifecycle state (LC) is PROD. Provisioning occurs via an Ownership Claim
                    operation after the previous Platform Owner completes a Relinquish operation.
                    '''
                }
            ],
            desc: '''Software managed Platform Owner slot 3 partition.
            '''
        }
        {
            name:       "EXT_NVM",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  false,
            hw_digest:  false,
            write_lock: "None",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            // This is a strike counter, hence we need to disable ECC integrity for this to work.
            // Integrity is handled at a higher level by SW as described below.
            integrity:  false,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "EXT_NVM_ANTIREPLAY_FRESHNESS_CNT",
                    size: "1024"
                    desc: ''' Fully SW managed partition
                    1 bit (double bit allocated for redundancy - i.e. 2 physical bits for every logical bit) per day
                    assuming 10 year product lifecycle, allocating 8192 bits of freshness protection.
                    Implemented as thermometer encoding. Redundant bit programming & logical OR-ing managed by
                    software. Cannot be ECC protected since different bits in a fuse row are programmed at different times.
                    '''
                }
            ],
            desc: '''Anti-replay protection Strike Counters partition.
            '''
        }
        {
            name:       "ROM_PATCH",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "ROM_PATCH_DATA",
                    size: "8192"
                    desc: ''' Fully SW managed partition.
                    ROM patch section for signed ROM patches.
                    Each patch contains a header, a signature, the patch match/redirect configuration and the actual patch code.
                    Please refer to the Darjeeling ROM boot & patching specification for more details.
                    '''
                }
            ],
            desc: '''ROM Patch Code section. May contain multiple signed ROM2 patches.
            '''
        }
        {
            name:       "SOC_FUSES_CP",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            items: [
                {
                   name: "SOC_FUSES_CP1_DATA",
                   size: "256"
                }
                {
                   name: "SOC_FUSES_CP2_DATA",
                   size: "128"
                }
            ],
            desc: ''' SoC fuses partition for the Chip Probe (CP) manufacturing stage.
            '''
        }
        {
            name:       "SOC_FUSES_FT",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            items: [
                {
                   name: "SOC_FUSES_FT1_DATA",
                   size: "384"
                }
                {
                   name: "SOC_FUSES_FT2_DATA",
                   size: "3840"
                }
            ],
            desc: ''' SoC fuses partition for the Factory Testing (FT) manufacturing stage.
                '''
        }
        {
            name:       "SCRATCH_FUSES",
            variant:    "Unbuffered",
            absorb:     true,
            secret:     false,
            sw_digest:  false,
            hw_digest:  false,
            write_lock: "None",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            zeroizable: true,
            items: [
                {
                    name: "SCRATCH_FUSES_DATA",
                    absorb: true,
                    desc: ''' Fully SW managed partition.
                    Unstructured, single item partition for any RoT firmware (runtime,
                    bootstrap, manufacturing) to use and organize freely.
                    '''
                }
            ],
            desc: '''Unstructured scratch data partition.
            '''
        }
        {
            name:           "HW_CFG0",
            variant:        "Buffered",
            secret:         false,
            sw_digest:      false,
            hw_digest:      true,
            write_lock:     "Digest",
            read_lock:      "None",
            key_sel:        "NoKey",
            integrity:      true,
            bkout_type:     true,
            zeroizable:     true,
            skip_sw_header: true,
            items: [
                {
                    name:        "DEVICE_ID",
                    size:        "32",
                    // Default value to be output in case partition has not
                    // initialized or is in error state. If not specified,
                    // a value of '0 will be used.
                    inv_default: "<random>",
                desc: '''
                Unique device identifier that is always exposed through the
                lifecycle JTAG tap. See OpenTitan documentation on Device
                Identifiers.
                '''
                },
            ],
            desc: '''Hardware configuration partition 0.
            This contains a device identifier.
            '''
        }
        {
            name:           "HW_CFG1",
            variant:        "Buffered",
            secret:         false,
            sw_digest:      false,
            hw_digest:      true,
            write_lock:     "Digest",
            read_lock:      "None",
            key_sel:        "NoKey",
            integrity:      true,
            bkout_type:     true,
            zeroizable:     true,
            skip_sw_header: true,
            items: [
                {
                    name:        "EN_CSRNG_SW_APP_READ",
                    size:        "1",
                    ismubi:      true,
                    inv_default: false,
                    desc: '''
                    Enablement of CSRNG software application interface. A
                    kMultiBitBool8True value enables, while all other values
                    disable. Enablement is required to extract output from
                    CSRNG via software.
                    '''
                },
                {
                    name:        "EN_SRAM_IFETCH",
                    size:        "1",
                    ismubi:      true,
                    inv_default: false,
                    desc: '''
                    Enablement of execute from SRAM switch in the sram_ctrl (see
                    EXEC CSR). A kMultiBitBool8True value enables, while all
                    other values disable.
                    '''
                },
            ],
            desc: '''Hardware configuration partition 1.
            This contains several hardware feature switches.
            '''
        }
        {
            name:       "HW_CFG2",
            variant:    "Buffered",
            secret:     false,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "None",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: true,
            zeroizable: true,
            items: [
                {
                    name:        "SOC_DBG_STATE",
                    size:        "4",
                    inv_default: "0x0"
                    desc: '''Multi-bit enable value for the SOC debug authorization.
                    SOC_DBG_STATE will be written twice in a device lifetime. The
                    values to be written are engineered in the same way as the LC_CTRL
                    state encoding words: the ECC encoding remains valid even after
                    writing the second value on top of the first.
                    The constants can be found in the lc_ctrl_state_pkg.sv package.
                    The programming order has to adhere to:
                      SOC_DBG_RAW -> SOC_DBG_PRE_PROD -> SOC_DBG_PROD.
                    Encoding:
                      SOC_DBG_RAW: this value is all-zeroes and will be the NOP state;
                        the LC controller will take precedence.
                      SOC_DBG_PRE_PROD: this is where the ROT will be in PROD state
                        but SOC will be in the pre-production unlock state
                      SOC_DBG_PROD: this is the state where the SOC moves to production,
                        and the challenge-response based authentication protocol is
                        required to unlock SOC debug features
                    '''
                },
                {
                    name:        "MANUF_STATE",
                    size:        "32",
                    inv_default: "<random>",
                    desc: '''
                    Field to capture the manufacturing state.
                    '''
                }
            ],
            desc: '''Hardware configuration partition 2.
            This contains the SoC debug state and the manufacturing state.
            '''
        }
        {
            name:           "SECRET0",
            variant:        "Buffered",
            secret:         true,
            sw_digest:      false,
            hw_digest:      true,
            write_lock:     "Digest",
            read_lock:      "Digest",
            ignore_read_lock_in_rma: true,
            key_sel:        "Secret0Key",
            integrity:      true,
            bkout_type:     false,
            zeroizable:     true,
            skip_sw_header: true,
            items: [
                {
                    name: "TEST_UNLOCK_TOKEN",
                    // This will generate a random default to be output in
                    // case partition has not initialized or is in error state.
                    // If not specified, a value of '0 will be used.
                    inv_default: "<random>",
                    size: "16"
                }
                {
                    name: "TEST_EXIT_TOKEN",
                    inv_default: "<random>",
                    size: "16"
                }
            ],
            desc: '''Secret partition 0.
            This contains TEST lifecycle unlock tokens.
            '''
        }
        {
            name:           "SECRET1",
            variant:        "Buffered",
            secret:         true,
            sw_digest:      false,
            hw_digest:      true,
            write_lock:     "Digest",
            read_lock:      "Digest",
            ignore_read_lock_in_rma: true,
            key_sel:        "Secret1Key",
            integrity:      true,
            bkout_type:     false,
            zeroizable:     true,
            skip_sw_header: true,
            items: [
                {
                    name: "SRAM_DATA_KEY_SEED",
                    inv_default: "<random>",
                    size: "16"
                }
            ],
            desc: '''Secret partition 1.
            This contains the SRAM scrambling key seed.
            '''
        }
        {
            name:           "SECRET2",
            variant:        "Buffered",
            secret:         true,
            sw_digest:      false,
            hw_digest:      true,
            write_lock:     "Digest",
            read_lock:      "Digest",
            ignore_read_lock_in_rma: true,
            key_sel:        "Secret2Key",
            integrity:      true,
            bkout_type:     false,
            zeroizable:     true,
            skip_sw_header: true,
            items: [
                {
                    name: "RMA_TOKEN",
                    inv_default: "<random>",
                    size: "16"
                }
                {
                    name: "CREATOR_ROOT_KEY_SHARE0",
                    inv_default: "<random>",
                    size: "32",
                    iskeymgr_creator: true
                }
                {
                    name: "CREATOR_ROOT_KEY_SHARE1",
                    inv_default: "<random>",
                    size: "32"
                    iskeymgr_creator: true
                }
                {
                    name: "CREATOR_SEED",
                    inv_default: "<random>",
                    size: "32",
                    iskeymgr_creator: true
                }
            ],
            desc: '''Secret partition 2.
            This contains RMA unlock token, creator root key, and creator seed.
            '''
        }
        {
            name:           "SECRET3",
            variant:        "Buffered",
            secret:         true,
            sw_digest:      false,
            hw_digest:      true,
            write_lock:     "Digest",
            read_lock:      "Digest",
            key_sel:        "Secret3Key",
            integrity:      true,
            bkout_type:     false,
            zeroizable:     true,
            skip_sw_header: true,
            items: [
                {
                    name: "OWNER_SEED",
                    inv_default: "<random>",
                    size: "32",
                    iskeymgr_owner: true
                }
            ],
            desc: '''Secret partition 3.
            This contains the owner seed.
            '''
        }
        {
            name:           "LIFE_CYCLE",
            variant:        "LifeCycle",
            secret:         false,
            sw_digest:      false,
            hw_digest:      false,
            write_lock:     "None",
            read_lock:      "None",
            key_sel:        "NoKey",
            integrity:      true,
            bkout_type:     false,
            skip_sw_header: true,
            items: [
                // The life cycle transition count is specified
                // first such that any programming attempt of the life cycle
                // partition through the LCI will always write the transition
                // counter words first when programming an updated state vector.
                // This is an additional safeguard, to the sequencing in the
                // life cycle controller to ensure that the counter is always written
                // before any state update. I.e., the life cycle controller
                // already splits the counter and state updates into two
                // subsequent requests through the LCI, where the first request
                // only contains the updated transition counter, and the second
                // request the updated transition counter and state.
                {
                    name: "LC_TRANSITION_CNT",
                    inv_default: "<random>",
                    size: "48"
                }
                {
                    name: "LC_STATE",
                    inv_default: "<random>",
                    size: "40"
                }
            ],
            desc: '''Lifecycle partition.
            This contains lifecycle transition count and state. This partition
            cannot be locked since the life cycle state needs to advance to RMA
            in-field. Note that while this partition is not marked secret, it
            is not readable nor writeable via the DAI. Only the LC controller
            can access this partition, and even via the LC controller it is not
            possible to read the raw manufacturing life cycle state in encoded
            form, since that encoding is considered a netlist secret. The LC
            controller only exposes a decoded version of this state.
            '''
        }
    ]
}
