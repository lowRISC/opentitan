// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// This file was autogenerated by `//sw/host/hsmtool/scripts/pkcs11_consts.py`.
// Do not edit.'

use cryptoki_sys::*;
use std::convert::TryFrom;

use crate::util::attribute::{AttrData, AttributeError};

#[derive(
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    serde::Serialize,
    serde::Deserialize,
    strum::Display,
    strum::EnumString,
    strum::EnumIter,
    strum::FromRepr,
)]
#[repr(u64)]
pub enum CertificateType {
    #[serde(rename = "CKC_X_509")]
    #[strum(serialize = "CKC_X_509", serialize = "X509", serialize = "x_509")]
    X509 = CKC_X_509,
    #[serde(rename = "CKC_X_509_ATTR_CERT")]
    #[strum(
        serialize = "CKC_X_509_ATTR_CERT",
        serialize = "X509AttrCert",
        serialize = "x_509_attr_cert"
    )]
    X509AttrCert = CKC_X_509_ATTR_CERT,
    #[serde(rename = "CKC_WTLS")]
    #[strum(serialize = "CKC_WTLS", serialize = "Wtls", serialize = "wtls")]
    Wtls = CKC_WTLS,
    #[serde(rename = "CKC_VENDOR_DEFINED")]
    #[strum(
        serialize = "CKC_VENDOR_DEFINED",
        serialize = "VendorDefined",
        serialize = "vendor_defined"
    )]
    VendorDefined = CKC_VENDOR_DEFINED,
    UnknownCertificateType = u64::MAX,
}

impl From<u64> for CertificateType {
    fn from(val: u64) -> Self {
        CertificateType::from_repr(val).unwrap_or(CertificateType::UnknownCertificateType)
    }
}

impl From<CertificateType> for u64 {
    fn from(val: CertificateType) -> u64 {
        val as u64
    }
}

impl From<cryptoki::object::CertificateType> for CertificateType {
    fn from(val: cryptoki::object::CertificateType) -> Self {
        let val = CK_CERTIFICATE_TYPE::from(val);
        Self::from(val)
    }
}

impl TryFrom<CertificateType> for cryptoki::object::CertificateType {
    type Error = cryptoki::error::Error;
    fn try_from(val: CertificateType) -> Result<Self, Self::Error> {
        let val = CK_CERTIFICATE_TYPE::from(val);
        cryptoki::object::CertificateType::try_from(val)
    }
}

impl TryFrom<&AttrData> for CertificateType {
    type Error = AttributeError;
    fn try_from(val: &AttrData) -> Result<Self, Self::Error> {
        match val {
            AttrData::CertificateType(x) => Ok(*x),
            _ => Err(AttributeError::EncodingError),
        }
    }
}

impl From<CertificateType> for AttrData {
    fn from(val: CertificateType) -> Self {
        AttrData::CertificateType(val)
    }
}
