// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// USB streaming data test
//
// Linux host-side application that receives a stream of LFSR-generated data
// from the USB device, checks the received bytestream and then XORs it with a
// host-side LFSR-generated byte stream to transmit back to the device.
//
// By default the streaming test expects a number of USB serial connections to
// the target device, one port per endpoint:
//
//   /dev/ttyUSB0 - supplies and receives LFSR-generated byte stream for one/
//                  the only endpoint
//   /dev/ttyUSB1 - a secondary stream
//   /dev/ttyUSB..
//
// Note that the mapping from device endpoints to USB port number is not
// guaranteed, and  when multiple streams are used, it is _not_ necessarily the
// case that ascending streams/endpoints in usbdev_stream_test are mapped to
// a contiguous range of ascending ttyUSBi port names.
//
// Either or both of the initial input port and the initial output port may be
// overridden using command line parameters.
//
// Usage:
//   stream [-n<streams>][-v<bool>][-c<bool>][-r<bool>][-s<bool>]
//          [<input port>[ <output port>]]
//
//   -c   check any retrieved data against expectations
//   -n<> Number of concurrent byte streams to test
//   -r   retrieve data from device
//   -s   send data to device
//   -v   verbose reporting
//
// Build: gcc -Wall -Werror -o stream_test stream_test.c

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#ifndef ABS
#define ABS(x) (((x) < 0) ? -(x) : (x))
#endif

// Maximum number of concurrent streams
#ifdef USBDEV_NUM_ENDPOINTS
#define STREAMS_MAX USBDEV_NUM_ENDPOINTS
#else
#define STREAMS_MAX 12U
#endif

// Test properties
#ifndef BYTES_TO_TRANSFER
// This is about the amount that we can transfer within a 1 hour 'eternal' test
//#define BYTES_TO_TRANSFER (0x60U << 20)
// This takes about 80s presently with transfer of sending of undefined data
// and no checking of the received data, but ca. 213s with LFSR generation and
// checking
#define BYTES_TO_TRANSFER (0x10U << 20)
// This takes about 10 seconds on CW-310 FPGA
//#define BYTES_TO_TRANSFER (1U << 20)
// This is appropriate for a Verilator chip simulation with 15 min timeout
//#define BYTES_TO_TRANSFER 0x2400U
#endif

// Stream signature words
#define STREAM_SIGNATURE_HEAD 0x579EA01AU
#define STREAM_SIGNATURE_TAIL 0x160AE975U

// Seed numbers for the LFSR generators in each transfer direction for
// the given stream number
#define USBTST_LFSR_SEED(s) (uint8_t)(0x10U + (s)*7U)
#define USBDPI_LFSR_SEED(s) (uint8_t)(0x9BU - (s)*7U)

// Simple LFSR for 8-bit sequences
#define LFSR_ADVANCE(lfsr) \
  (((lfsr) << 1) ^         \
   ((((lfsr) >> 1) ^ ((lfsr) >> 2) ^ ((lfsr) >> 3) ^ ((lfsr) >> 7)) & 1u))

// Size of data buffer to be used
#ifndef BUFFER_SIZE
#define BUFFER_SIZE 0x100000U
#endif

/**
 * States in reception of signature state
 */
typedef enum {
  SigState_Start = 0,
  SigState_CheckHead,
  SigState_SkipBody,
  SigState_CheckTail,
  // Signature has been correctly received
  SigState_Received,
} sig_state_t;

/**
 * Stream signature
 * Note: this needs to be transferred over a byte stream
 */
typedef struct __attribute__((packed)) usbdev_stream_sig {
  /**
   * Head signature word
   */
  uint32_t head_sig;
  /**
   * Initial value of LFSR
   */
  uint8_t init_lfsr;
  /**
   * Stream number
   */
  uint8_t stream;
  /**
   * Reserved fields; should be zero
   */
  uint8_t reserved1;
  uint8_t reserved2;
  /**
   * Number of bytes to be transferred
   */
  uint32_t num_bytes;
  /**
   * Tail signature word
   */
  uint32_t tail_sig;
} usbdev_stream_sig_t;

// Maximum number of bytes to receive at a time
#define MAX_CHUNK_SIZE 0x10000U

// Data stream
typedef struct {
  /**
   * Stream IDentifier
   */
  unsigned id;
  /**
   * Input port handle
   */
  int in;
  /**
   * Output port handle
   */
  int out;
  /**
   * Input port name
   */
  //  char in_name[FILENAME_MAX];
  /**
   * Output port name
   */
  //  char out_name[FILENAME_MAX];
  /**
   * Have we received the stream signature yet?
   */
  sig_state_t sig_recvd;
  unsigned sig_cnt;
  /**
   * Total number of bytes received
   */
  uint32_t bytes_recvd;
  /**
   * Total number of bytes sent
   */
  uint32_t bytes_sent;
  /**
   * Device-side LFSR; byte stream expected from usbdev_stream_test
   */
  uint8_t tst_lfsr;
  /**
   * Host/DPI-side LFSR
   */
  uint8_t dpi_lfsr;
  /**
   * Number of bytes to be transferred
   */
  uint32_t transfer_bytes;
  /**
   * Circular buffer of streamed data
   */
  struct {
    /**
     * Offset at which to write the next received data (IN from device)
     */
    uint32_t wr_idx;
    /**
     * Offset of next byte to be read from the buffer (OUT to device)
     */
    uint32_t rd_idx;
    /**
     * Circular buffer of data being transferred from input to output port
     */
    uint8_t data[BUFFER_SIZE];
  } buf;
} stream_t;

// Verbose logging/diagnostic reporting
static bool bVerbose = false;

// Retrieve data from the device
static bool bRetrieve = true;

// Check the retrieved data against expectations
static bool bCheck = true;

// Send data to the device
static bool bSend = true;

// Has any data yet been received from the device?
static bool bReceived = false;

// Time of first data reception
static uint64_t start_time = 0U;

// State information for each of the streams
static stream_t streams[STREAMS_MAX];

// Parse a command line option and return boolean value
static bool get_bool(const char *p);

// Open and configure a serial port connection to/from the USB device
static int port_open(const char *dev_name, bool bWrite);

// Construct a modified port name for the next stream
static void port_next(char *next, size_t n, const char *curr);

// Report command line syntax
static void report_syntax(void);

// Receive a sequence of bytes from the USB device
static ssize_t recv_bytes(int in, uint8_t *buf, size_t len);

// Send a sequence of bytes to the USB device
static ssize_t send_bytes(int out, const uint8_t *data, size_t len);

// Return an indication of whether this stream has completed its transfer
static bool stream_completed(stream_t *s);

// Finalise the given stream, releasing all resources
static void stream_fin(stream_t *s);

// Iniitialise a stream between the specified input and output ports
static bool stream_init(stream_t *s, unsigned id, const char *in_name,
                        const char *out_name, uint32_t transfer_bytes);

// Service the given data stream
static bool stream_service(stream_t *s);

// Return current monotonic wall time in microsecoinds
static uint64_t time_us(void);

// Parse a command line option and return boolean value
bool get_bool(const char *p) {
  return (*p == '1') || (tolower(*p) == 'y') || (*p == '\r') || (*p == '\n') ||
         (*p == '\0');
}

// Construct a modified port name for the next stream
void port_next(char *next, size_t n, const char *curr) {
  if (curr != next) {
    strncpy(next, curr, n);
  }
  // TODO - tidy and make more robust
  while (*next != '\0') {
    if (isdigit(*next)) {
      int port = atoi(next);
      sprintf(next, "%u", (unsigned)port + 1U);
      break;
    }
    next++;
  }
}

// Open and configure a serial port connection to/from the USB device
int port_open(const char *dev_name, bool bWrite) {
  const char *port_type = bWrite ? "output" : "input";
  int fd = open(dev_name, bWrite ? O_WRONLY : O_RDONLY);
  if (fd < 0) {
    fprintf(stderr, "ERROR: Could not open %s port '%s'\n", port_type,
            dev_name);
    report_syntax();
    return -1;
  }

  // We need to ensure that we can send full 8-bit binary data with no character
  // translations and no character echo etc
  struct termios tty;
  if (tcgetattr(fd, &tty) != 0) {
    fprintf(stderr, "ERROR: %s (error %d) from tcgetattr\n", strerror(errno),
            errno);
    return -1;
  }

  //  8-bits, no parity, no hardware handshaking
  tty.c_cflag &= ~(PARENB | CSTOPB | CSIZE | CRTSCTS);
  tty.c_cflag |= CS8 | CREAD | CLOCAL;

  // No character echo
  tty.c_lflag &= ~(ICANON | ECHO | ECHOE | ECHONL | ISIG);

  // No software handshaking, no special characters
  tty.c_iflag &= ~(IXON | IXOFF | IXANY);
  tty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL);

  // Disable line feed conversions and special characters on output traffic
  tty.c_oflag &= ~(OPOST | ONLCR);

  // Non-blocking
  tty.c_cc[VTIME] = 0;
  tty.c_cc[VMIN] = 0;

  // Set in/out baud rate to be as high as possible; just in case, but it has
  // no impact upon the measured transfer speed
  cfsetispeed(&tty, B4000000);
  cfsetospeed(&tty, B4000000);

  // Save tty settings, also checking for error
  if (tcsetattr(fd, TCSANOW, &tty) != 0) {
    fprintf(stderr, "ERROR: %s (error %d) from tcsetattr\n", strerror(errno),
            errno);
    return -1;
  }

  return fd;
}

// Receive a sequence of bytes from the USB device
ssize_t recv_bytes(int in, uint8_t *buf, size_t len) {
  ssize_t nread = 0;

  // Read as many bytes as we can from the input port;
  ssize_t n = read(in, buf, len);
  if (bVerbose) {
    printf("Received %zd byte(s)\n", n);
    for (int idx = 0; idx < n; idx++) {
      printf("%x\n", buf[idx]);
    }
    fflush(stdout);
  }
  if (n < 0) {
    fprintf(stderr, "ERROR: Failed to read from input port (%s, errno %d)\n",
            strerror(errno), errno);
    return -1;
  }

  nread += n;
  buf += n;
  len -= (size_t)n;

  return nread;
}

// Send a sequence of bytes to the USB device
ssize_t send_bytes(int out, const uint8_t *data, size_t len) {
  ssize_t nwritten = 0;

  if (len > 0u) {
    ssize_t n = write(out, data, len);
    if (n < 0) {
      fprintf(stderr, "ERROR: Failed to write to output port (%s, errno %d)\n",
              strerror(errno), errno);
      return -1;
    }

    nwritten += n;
    data += n;
    len -= n;
  }

  return nwritten;
}

// Utility function for collecting a byte from the stream signature
static inline uint8_t sig_read8(stream_t *s, size_t offset) {
  unsigned rd_idx = s->buf.rd_idx + offset;
  if (rd_idx >= BUFFER_SIZE) {
    rd_idx -= BUFFER_SIZE;
  }
  return s->buf.data[rd_idx];
}

// Utility function for collecting a 32-bit word from the stream signature
static inline uint32_t sig_read32(stream_t *s, size_t offset) {
  unsigned rd_idx = s->buf.rd_idx + offset;
  unsigned n = 4U;
  uint32_t d = 0U;
  while (n-- > 0U) {
    if (rd_idx >= BUFFER_SIZE) {
      rd_idx -= BUFFER_SIZE;
    }
    // Transmission of multi-byte value is little endian
    d = (d >> 8) | (s->buf.data[rd_idx++] << 24);
  }
  return d;
}

// Detect a stream signature within the byte stream;
// simple restartable parser that drops all bytes until we find a header
// signature.
//
// The signature permits usbdev_stream_test to pass test parameters to this
// program as well as overcoming the issue of the mapping from device
// endpoints/streams to USB ports not being under our control.
ssize_t sig_detect(stream_t *s, ssize_t nrecv) {
  assert(nrecv > 0);
  do {
    if (s->sig_recvd == SigState_Start) {
      s->sig_recvd = SigState_CheckHead;
      s->sig_cnt = 0U;
    }

    unsigned rd_idx = s->buf.rd_idx + s->sig_cnt;
    if (rd_idx >= BUFFER_SIZE) {
      rd_idx -= BUFFER_SIZE;
    }
    const uint8_t *sp = &s->buf.data[rd_idx];
    const size_t tail_offset = offsetof(usbdev_stream_sig_t, tail_sig);

    // Advance the parser beyond this byte
    // Note: valid signature bytes remain in the buffer until the signature is
    // complete

    bool discard = false;
    switch (s->sig_recvd) {
      // Check the bytes of the header signature
      case SigState_CheckHead: {
        const unsigned sh = s->sig_cnt << 3;
        uint8_t match = (uint8_t)(STREAM_SIGNATURE_HEAD >> sh);
        if (match == *sp) {
          if (++s->sig_cnt >= 4U) {
            s->sig_recvd = SigState_SkipBody;
          }
        } else {
          s->sig_recvd = SigState_Start;
          discard = true;
        }
      } break;

      // Just collect the signature body for later validation
      case SigState_SkipBody: {
        if (++s->sig_cnt >= tail_offset) {
          s->sig_recvd = SigState_CheckTail;
        }
      } break;

      // Check the bytes of the tail signature
      case SigState_CheckTail: {
        const unsigned sh = (s->sig_cnt - tail_offset) << 3;
        uint8_t match = (uint8_t)(STREAM_SIGNATURE_TAIL >> sh);
        if (match == *sp) {
          if (++s->sig_cnt >= sizeof(usbdev_stream_sig_t)) {
            uint32_t num_bytes;
            uint8_t init_lfsr;
            uint8_t stream;
            uint8_t res1;
            uint8_t res2;

            // We have a complete stream signature; validate it
            stream = sig_read8(s, offsetof(usbdev_stream_sig_t, stream));
            init_lfsr = sig_read8(s, offsetof(usbdev_stream_sig_t, init_lfsr));
            res1 = sig_read8(s, offsetof(usbdev_stream_sig_t, reserved1));
            res2 = sig_read8(s, offsetof(usbdev_stream_sig_t, reserved2));
            num_bytes = sig_read32(s, offsetof(usbdev_stream_sig_t, num_bytes));

            if (bVerbose) {
              printf("Signature detected: stream #%u LFSR 0x%02x bytes 0x%x\n",
                     stream, init_lfsr, num_bytes);
            }

            // Simple sanity check of the received signature
            if (num_bytes > 0U && num_bytes < 0x10000000U && !res1 && !res2 &&
                stream < STREAMS_MAX) {
              if (bVerbose) {
                printf("Signature accepted\n");
              }
              s->dpi_lfsr = USBDPI_LFSR_SEED(stream);
              s->tst_lfsr = init_lfsr;
              s->transfer_bytes = num_bytes;
              s->sig_recvd = SigState_Received;
            } else {
              s->sig_recvd = SigState_Start;
            }
            discard = true;
          }
        } else {
          s->sig_recvd = SigState_Start;
          discard = true;
        }
      } break;

      default:
        // Note: should not be called once we have a valid stream signature
        assert(!"Invalid/undefined sig_recvd state");
        break;
    }

    if (discard) {
      // Mismatch; discard the checked data, and retry
      if (++rd_idx >= BUFFER_SIZE) {
        rd_idx = 0U;
      }
      s->buf.rd_idx = rd_idx;
      s->sig_cnt = 0U;
    }

  } while (--nrecv > 0U && s->sig_recvd != SigState_Received);

  return nrecv;
}

// Return an indication of whether this stream has completed its transfer
bool stream_completed(stream_t *s) {
  return (!bRetrieve || s->bytes_recvd >= s->transfer_bytes) &&
         (!bSend || s->bytes_sent >= s->transfer_bytes);
}

// Finalise the given stream, releasing all resources
void stream_fin(stream_t *s) {
  // Close any open port handles
  if (s->in >= 0) {
    close(s->in);
    s->in = -1;
  }
  if (s->out >= 0) {
    close(s->out);
    s->out = -1;
  }
}

// Iniitialise a stream between the specified input and output ports
bool stream_init(stream_t *s, unsigned id, const char *in_name,
                 const char *out_name, uint32_t transfer_bytes) {
  // Remember stream IDentifier
  s->id = id;

  // Not yet received stream signature
  s->sig_recvd = SigState_Start;

  // Initialise LFSR state
  s->tst_lfsr = USBTST_LFSR_SEED(id);
  s->dpi_lfsr = USBDPI_LFSR_SEED(id);

  // Initialise circular buffer
  s->buf.wr_idx = 0U;
  s->buf.rd_idx = 0U;

  // Number of bytes to be transferred
  s->transfer_bytes = transfer_bytes;

  // Total counts of bytes received and sent
  s->bytes_recvd = 0U;
  s->bytes_sent = 0U;

  // Open the input and output ports to the board/device for this stream
  s->in = port_open(in_name, false);
  if (s->in < 0) {
    return false;
  }
  s->out = port_open(out_name, true);
  if (s->out < 0) {
    close(s->in);
    return false;
  }

  if (bVerbose)
    printf("S%u: input '%s' (%d) output '%s' (%d)\n", id, in_name, s->in,
           out_name, s->out);

  return true;
}

// Service the given data stream
bool stream_service(stream_t *s) {
  if (bVerbose) {
    printf("S%u : rd_idx 0x%x wr_idx 0x%x\n", s->id, s->buf.rd_idx,
           s->buf.wr_idx);
  }

  // ----- Sending of OUT traffic to device -----

  if (s->sig_recvd == SigState_Received) {
    // Decide how much data we should try to write OUT to the device
    uint32_t to_send = BUFFER_SIZE - s->buf.rd_idx;
    if (s->buf.wr_idx >= s->buf.rd_idx) {
      to_send = s->buf.wr_idx - s->buf.rd_idx;
    }
    if (to_send > 0U) {
      ssize_t nsent;
      if (bSend) {
        if (bVerbose) {
          printf("S%u: Trying to send %u byte(s)\n", s->id, to_send);
        }
        // Propagate the modified bytes to the output port
        nsent = send_bytes(s->out, &s->buf.data[s->buf.rd_idx], to_send);
        if (nsent < 0) {
          return false;
        }
      } else {
        nsent = to_send;
      }

      if (bVerbose) {
        printf("S%u: %s %zd byte(s)\n", s->id, bSend ? "Sent" : "Dropped",
               nsent);
      }

      // Update the buffer reading state
      s->bytes_sent += nsent;
      s->buf.rd_idx += nsent;
      if (s->buf.rd_idx >= BUFFER_SIZE) {
        s->buf.rd_idx = 0U;
      }
    }
  }

  // ----- Retrieving of IN traffic from device -----

  // Decide how many bytes to try to read into our buffer; do not go beyond
  //   the end of the physical buffer or beyond the current read pointer
  uint32_t to_fetch = BUFFER_SIZE - s->buf.wr_idx;
  if (s->buf.rd_idx > s->buf.wr_idx) {
    to_fetch = (s->buf.rd_idx - 1) - s->buf.wr_idx;
  } else if (to_fetch >= BUFFER_SIZE) {
    to_fetch = BUFFER_SIZE - 1U;
  }
  if (to_fetch > BYTES_TO_TRANSFER - s->bytes_recvd) {
    to_fetch = BYTES_TO_TRANSFER - s->bytes_recvd;
  }

  uint8_t *dp = &s->buf.data[s->buf.wr_idx];
  ssize_t nrecvd;
  if (bRetrieve) {
    if (bVerbose) {
      printf("S%u: Trying to fetch %u byte(s)\n", s->id, to_fetch);
    }
    // Read as many bytes as we can from the input port
    nrecvd = recv_bytes(s->in, dp, to_fetch);
    if (nrecvd < 0) {
      return false;
    }
  } else {
    if (s->sig_recvd != SigState_Received) {
      // Pretend that we've received the expected signature
      // Note: transfer_bytes remains at the requested value
      s->tst_lfsr = USBTST_LFSR_SEED(s->id);
      s->sig_recvd = SigState_Received;
    }

    // Generate a stream of bytes _as if_ we'd received them correctly from
    // the device
    uint8_t next_lfsr = s->tst_lfsr;
    for (unsigned idx = 0U; idx < to_fetch; idx++) {
      dp[idx] = next_lfsr;
      next_lfsr = LFSR_ADVANCE(next_lfsr);
    }
    nrecvd = to_fetch;
  }

  if (nrecvd > 0) {
    // Update the buffer writing state
    s->buf.wr_idx += (uint32_t)nrecvd;
    if (s->buf.wr_idx >= BUFFER_SIZE) {
      s->buf.wr_idx = 0U;
    }

    // If we don't yet have a stream signature then we consume all bytes until
    // we have a complete signature
    if (s->sig_recvd != SigState_Received) {
      nrecvd = sig_detect(s, nrecvd);
      // Skip over any signature that we've just consumed
      dp = &s->buf.data[s->buf.rd_idx];
    }

    if (nrecvd > 0) {
      // Record the time of the first data reception
      if (!bReceived) {
        start_time = time_us();
        bReceived = true;
      }

      if (bVerbose) {
        printf("S%u: %s %zd byte(s)\n", s->id,
               bRetrieve ? "Received" : "Generated", nrecvd);
      }

      // We can just check and overwrite the input data in-situ
      const uint8_t *sp = dp;
      for (unsigned idx = 0U; idx < (unsigned)nrecvd; idx++) {
        uint8_t expected = s->tst_lfsr;
        uint8_t recvd = sp[idx];

        // Check whether the received byte is as expected
        if (bCheck) {
          if (bRetrieve && recvd != expected) {
            printf("S%u: Mismatched data from device 0x%02x, expected 0x%02x\n",
                   s->id, recvd, expected);
          }
        }

        // Simply XOR the two LFSR-generated streams together
        dp[idx] = recvd ^ s->dpi_lfsr;
        if (bVerbose) {
          printf("S%u: 0x%02x <- 0x%02x ^ 0x%02x\n", s->id, dp[idx], recvd,
                 s->dpi_lfsr);
        }

        // Advance our LFSRs
        s->tst_lfsr = LFSR_ADVANCE(s->tst_lfsr);
        s->dpi_lfsr = LFSR_ADVANCE(s->dpi_lfsr);
      }

      // Update the buffer writing state
      s->bytes_recvd += (uint32_t)nrecvd;
    }
  }

  return true;
}

// Report command line syntax
void report_syntax(void) {
  fputs(
      "Usage:\n"
      "   stream [-v<bool>][-r<bool>][-s<bool>][<input port>[ <output port>]]"
      "\n\n"
      "  -v   verbose reporting\n"
      "  -r   retrieve data from device\n"
      "  -s   send data to device\n",
      stderr);
}

// Current monotonic wall clock time in microseconds
uint64_t time_us(void) {
  struct timeval ts;
  int ret = gettimeofday(&ts, NULL);
  if (ret < 0)
    return (uint64_t)0u;
  return ((uint64_t)ts.tv_sec * 1000000u) + ts.tv_usec;
}

int main(int argc, char *argv[]) {
  const char *out_port = NULL;
  const char *in_port = NULL;
  unsigned nstreams = 1U;

  // Collect alternative port names
  for (int i = 1; i < argc; i++) {
    if (argv[i][0] == '-') {
      switch (tolower(argv[i][1])) {
        case 'c':
          bCheck = get_bool(&argv[i][2]);
          break;
        case 'n':
          nstreams = atoi(&argv[i][2]);
          break;
        case 'r':
          bRetrieve = get_bool(&argv[i][2]);
          break;
        case 's':
          bSend = get_bool(&argv[i][2]);
          break;
        case 'v':
          bVerbose = get_bool(&argv[i][2]);
          break;
        default:
          fprintf(stderr, "ERROR: Unrecognised option '%s'\n", argv[i]);
          report_syntax();
          return 6;
      }
    } else if (!out_port) {
      out_port = argv[i];
    } else if (!in_port) {
      in_port = argv[i];
    } else {
      fprintf(stderr, "ERROR: Parameter '%s' unrecognised\n", argv[i]);
      report_syntax();
      return 7;
    }
  }

  // Furnish test with default port names
  // TODO - it would be good if we can locate the serial ports from the presence
  // of the appropriate USB device (vendor/product)
  if (!out_port) {
    out_port = "/dev/ttyUSB0";
  }
  if (!in_port) {
    in_port = "/dev/ttyUSB0";
  }

  puts(
      "USB Streaming Test\n"
      " (host side implementation of usbdev_stream_test)\n");

  // Decide upon the number of bytes to be transferred for the entire test
  uint32_t transfer_bytes = BYTES_TO_TRANSFER;
  transfer_bytes = (transfer_bytes + nstreams - 1) / nstreams;
  if (bVerbose) {
    printf(" - %u stream(s), 0x%x bytes each\n", nstreams, transfer_bytes);
  }

  // We need to modify the port names for each non-initial stream
  char out_name[FILENAME_MAX];
  char in_name[FILENAME_MAX];

  // Initialise all streams
  for (unsigned idx = 0U; idx < nstreams; idx++) {
    if (!stream_init(&streams[idx], idx, in_port, out_port, transfer_bytes)) {
      while (idx-- > 0U) {
        stream_fin(&streams[idx]);
      }
      return 1;
    }

    // Modify the port name for the next stream
    port_next(out_name, sizeof(out_name), out_port);
    port_next(in_name, sizeof(in_name), in_port);
    out_port = out_name;
    in_port = in_name;
  }

  printf("Streaming...\r");

  int32_t prev_bytes = INT32_MAX;
  bool bDone = false;
  do {
    uint32_t total_bytes = 0U;
    int32_t bytes_sent = 0U;
    bDone = true;

    for (unsigned idx = 0U; idx < nstreams; idx++) {
      stream_t *s = &streams[idx];

      // Service this stream
      if (!stream_service(s)) {
        while (idx-- > 0U) {
          stream_fin(&streams[idx]);
        }
        return 2;
      }

      // Update the running totals
      total_bytes += s->transfer_bytes;
      bytes_sent += (int32_t)s->bytes_sent;

      // Has the stream completed all its work yet?
      if (!stream_completed(s)) {
        bDone = false;
      }
    }

    // Down counting of the number of bytes remaining to be transferred
    if (ABS(bytes_sent - prev_bytes) >= 0x1000 || bDone) {
      printf("Bytes left: 0x%x         \r", total_bytes - bytes_sent);
      fflush(stdout);
      prev_bytes = bytes_sent;
    }

  } while (!bDone);

  uint64_t elapsed_time = time_us() - start_time;

  // Report time elapsed from the start of data transfer
  for (unsigned idx = 0U; idx < nstreams; idx++) {
    stream_fin(&streams[idx]);
  }

  // TODO - introduce a crude estimate of the performance being achieved,
  //        particularly for read speed?

  double elapsed_secs = elapsed_time / 1e6;
  printf("Test completed in %.2lf seconds (%" PRIu64 "us)\n", elapsed_secs,
         elapsed_time);

  return 0;
}
