// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#include "usbdev_serial.h"

#include <cstdio>
#include <iostream>
#include <unistd.h>

#include "stream_test.h"
#include "usbdev_utils.h"

USBDevSerial::~USBDevSerial() { Close(); }

// Iniitialise a stream between the specified input and output ports
bool USBDevSerial::Open(const char *in_name, const char *out_name) {
  // Open the input and output ports to the board/device for this stream
  in_ = port_open(in_name, false);
  if (in_ < 0) {
    return false;
  }
  out_ = port_open(out_name, true);
  if (out_ < 0) {
    close(in_);
    return false;
  }

  if (cfg.verbose) {
    printf("S%u: input '%s' (%d) output '%s' (%d)\n", id_, in_name, in_,
           out_name, out_);
  }

  return true;
}

// Finalise the given stream, releasing all resources
void USBDevSerial::Close() {
  // Close any open port handles
  if (in_ >= 0) {
    close(in_);
    in_ = -1;
  }
  if (out_ >= 0) {
    close(out_);
    out_ = -1;
  }
}

// Sending of OUT traffic to device
bool USBDevSerial::ServiceOUT() {
  uint8_t *data;
  size_t to_send = DataAvailable(&data, true);
  if (to_send > 0U) {
    ssize_t nsent;
    if (send_) {
      if (cfg.verbose) {
        std::cout << PrefixID() << "Trying to send " << to_send << "byte(s)"
                  << std::endl;
      }
      // Propagate the modified bytes to the output port
      nsent = send_bytes(out_, &buf_.data[buf_.rd_idx], to_send);
      if (nsent < 0) {
        return false;
      }
    } else {
      nsent = to_send;
    }

    if (cfg.verbose) {
      std::cout << PrefixID() << (send_ ? "Sent" : "Dropped") << nsent
                << " byte(s)" << std::endl;
    }

    ConsumeData(nsent);
  }

  return true;
}

// Retrieving of IN traffic from device
bool USBDevSerial::ServiceIN() {
  // Decide how many bytes to try to read into our buffer
  uint8_t *dp;
  uint32_t space_bytes = SpaceAvailable(&dp, true);

  uint32_t to_fetch = space_bytes;
  if (to_fetch > transfer_bytes_ - bytes_recvd_) {
    to_fetch = transfer_bytes_ - bytes_recvd_;
  }

  ssize_t nrecvd;
  if (!SigReceived() || retrieve_) {
    // Read as many bytes as we can from the input port
    nrecvd = recv_bytes(in_, dp, to_fetch);
    if (nrecvd < 0) {
      return false;
    }

    // Update the circular buffer with the amount of data that we've written
    CommitData(nrecvd);

    if (nrecvd > 0 && !SigReceived()) {
      uint32_t dropped = SigDetect(&sig_, dp, (uint32_t)nrecvd);

      // Consume stream signature, rather than propagating it to the output
      // side.
      if (SigReceived()) {
        SigProcess(sig_);
        dropped += sizeof(usbdev_stream_sig_t);
      }

      // Skip past any dropped bytes, including the signature, so that if there
      // are additional bytes we may process them.
      nrecvd = (nrecvd > dropped) ? (nrecvd - dropped) : 0;
      dp += dropped;

      if (dropped) {
        ConsumeData(dropped);
      }
    }
  } else {
    // Generate a stream of bytes _as if_ we'd received them correctly from
    // the device
    GenerateData(dp, to_fetch);
    nrecvd = to_fetch;

    // Update the circular buffer with the amount of data that we've written
    CommitData(nrecvd);
  }

  bool ok = true;
  if (nrecvd > 0) {
    // Check the received LFSR-generated byte(s) and combine them with the
    // output of our host-side LFSR
    ok = ProcessData(dp, nrecvd);
  }

  return ok;
}

// Service this stream
bool USBDevSerial::Service() {
  // The base class may perform some diagnostic reporting common to all streams.
  bool ok = USBDevStream::Service();
  if (ok) {
    // Handle OUT traffic first to try to create more buffer space.
    ok = ServiceOUT();
    if (ok) {
      ok = ServiceIN();
    }
  }
  return ok;
}
