// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// USB streaming data test
//
// Linux host-side application that receives a stream of LFSR-generated data
// from the USB device, checks the received bytestream and then XORs it with a
// host-side LFSR-generated byte stream to transmit back to the device.
//
// By default the streaming test expects a number of USB serial connections to
// the target device, one port per endpoint:
//
//   /dev/ttyUSB0 - supplies and receives LFSR-generated byte stream for one/
//                  the only endpoint
//   /dev/ttyUSB1 - a secondary stream
//   /dev/ttyUSB..
//
// Note that the mapping from device endpoints to USB port number is not
// guaranteed, and  when multiple streams are used, it is _not_ necessarily the
// case that ascending streams/endpoints in usbdev_stream_test are mapped to
// a contiguous range of ascending ttyUSBi port names.
//
// Either or both of the initial input port and the initial output port may be
// overridden using command line parameters.
//
// Usage:
//   stream [-n<streams>][-v<bool>][-c<bool>][-r<bool>][-s<bool>]
//          [<input port>[ <output port>]]
//
//   -c   check any retrieved data against expectations
//   -n<> Number of concurrent byte streams to test
//   -r   retrieve data from device
//   -s   send data to device
//   -v   verbose reporting
//
// Build:
//   eg. g++ -Wall -Werror -o stream_test
//           stream_test.cc usbdev_stream.cc usbdev_utils.cc

#include "stream_test.h"

#include <cassert>
#include <cctype>
#include <cerrno>
#include <cinttypes>
#include <cstdbool>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <sys/time.h>

#include "usbdev_stream.h"
#include "usbdev_utils.h"

// Test properties
// This is about the amount that we can transfer within a 1 hour 'eternal' test
// constexpr uint32_t bytes_to_transfer = (0x60U << 20);
// This takes about 80s presently with transfer of sending of undefined data
// and no checking of the received data, but ca. 260s with LFSR generation and
// checking
constexpr uint32_t kBytesToTransfer = (0x10U << 20);
// This takes about 10 seconds on CW310 FPGA
// constexpr uint32_t kBytesToTransfer = (1U << 20);

// This is appropriate for a Verilator chip simulation with 15 min timeout
// constexpr uint32_t kBytesToTransfer = 0x2400U;

// Has any data yet been received from the device?
bool received = false;

// Time of first data reception
uint64_t start_time = 0U;

// Configuration settings for the test
TestConfig cfg(false,  // Not verbose
               true,   // Retrieve data from the device
               true,   // Check the retrieved data
               true);  // Send modified data to the device

// State information for each of the streams
static USBDevStream streams[STREAMS_MAX];

// Parse a command line option and return boolean value
static bool get_bool(const char *p);

// Construct a modified port name for the next stream
static void port_next(char *next, size_t n, const char *curr);

// Parse a command line option and return boolean value
bool get_bool(const char *p) {
  return (*p == '1') || (tolower(*p) == 'y') || (*p == '\r') || (*p == '\n') ||
         (*p == '\0');
}

// Construct a modified port name for the next stream
void port_next(char *next, size_t n, const char *curr) {
  // We're expecting a port name of the form '/dev/ttyUSB<n>'
  if (curr != next) {
    strncpy(next, curr, n);
  }
  while (*next != '\0') {
    if (isdigit(*next)) {
      int port = atoi(next);
      snprintf(next, n, "%u", (unsigned)port + 1U);
      break;
    }
    next++;
    n--;
  }
}

// Report command line syntax
void report_syntax(void) {
  fputs(
      "Usage:\n"
      "   stream [-v<bool>][-r<bool>][-s<bool>][<input port>[ <output port>]]"
      "\n\n"
      "  -v   verbose reporting\n"
      "  -r   retrieve data from device\n"
      "  -s   send data to device\n",
      stderr);
}

int main(int argc, char *argv[]) {
  const char *out_port = NULL;
  const char *in_port = NULL;
  unsigned nstreams = 2U;

  // Collect alternative port names
  for (int i = 1; i < argc; i++) {
    if (argv[i][0] == '-') {
      switch (tolower(argv[i][1])) {
        case 'c':
          cfg.check = get_bool(&argv[i][2]);
          break;
        case 'n':
          nstreams = atoi(&argv[i][2]);
          break;
        case 'r':
          cfg.retrieve = get_bool(&argv[i][2]);
          break;
        case 's':
          cfg.send = get_bool(&argv[i][2]);
          break;
        case 'v':
          cfg.verbose = get_bool(&argv[i][2]);
          break;
        default:
          fprintf(stderr, "ERROR: Unrecognised option '%s'\n", argv[i]);
          report_syntax();
          return 6;
      }
    } else if (!out_port) {
      out_port = argv[i];
    } else if (!in_port) {
      in_port = argv[i];
    } else {
      fprintf(stderr, "ERROR: Parameter '%s' unrecognised\n", argv[i]);
      report_syntax();
      return 7;
    }
  }

  // Furnish test with default port names
  // TODO: in a later revision we should interface directly through libusb
  // such that we can identify the specific DUT and not rely upon explicit port
  // names
  if (!out_port) {
    out_port = "/dev/ttyUSB0";
  }
  if (!in_port) {
    in_port = "/dev/ttyUSB0";
  }

  puts(
      "USB Streaming Test\n"
      " (host side implementation of usbdev_stream_test)\n");

  // Decide upon the number of bytes to be transferred for the entire test
  uint32_t transfer_bytes = kBytesToTransfer;
  transfer_bytes = (transfer_bytes + nstreams - 1) / nstreams;
  if (cfg.verbose) {
    printf(" - %u stream(s), 0x%x bytes each\n", nstreams, transfer_bytes);
  }

  // We need to modify the port names for each non-initial stream
  char out_name[FILENAME_MAX];
  char in_name[FILENAME_MAX];

  // Initialise all streams
  for (unsigned idx = 0U; idx < nstreams; idx++) {
    if (!streams[idx].Open(idx, in_port, out_port, transfer_bytes)) {
      while (idx-- > 0U) {
        streams[idx].Close();
      }
      return 1;
    }

    // Modify the port name for the next stream
    port_next(out_name, sizeof(out_name), out_port);
    port_next(in_name, sizeof(in_name), in_port);
    out_port = out_name;
    in_port = in_name;
  }

  printf("Streaming...\r");

  int32_t prev_bytes = INT32_MAX;
  bool bDone = false;
  do {
    uint32_t total_bytes = 0U;
    int32_t bytes_sent = 0U;
    bDone = true;

    for (unsigned idx = 0U; idx < nstreams; idx++) {
      // Service this stream
      if (!streams[idx].Service()) {
        while (idx-- > 0U) {
          streams[idx].Close();
        }
        return 2;
      }

      // Update the running totals
      total_bytes += streams[idx].TransferBytes();
      bytes_sent += (int32_t)streams[idx].BytesSent();

      // Has the stream completed all its work yet?
      if (!streams[idx].Completed()) {
        bDone = false;
      }
    }

    // Down counting of the number of bytes remaining to be transferred
    if (ABS(bytes_sent - prev_bytes) >= 0x1000 || bDone) {
      printf("Bytes left: 0x%x         \r", total_bytes - bytes_sent);
      fflush(stdout);
      prev_bytes = bytes_sent;
    }

  } while (!bDone);

  uint64_t elapsed_time = time_us() - start_time;

  // Report time elapsed from the start of data transfer
  for (unsigned idx = 0U; idx < nstreams; idx++) {
    streams[idx].Close();
  }

  // TODO: introduce a crude estimate of the performance being achieved,
  // for profiling the performance of IN and OUT traffic; totals and individual
  // endpoints

  double elapsed_secs = elapsed_time / 1e6;
  printf("Test completed in %.2lf seconds (%" PRIu64 "us)\n", elapsed_secs,
         elapsed_time);

  return 0;
}
