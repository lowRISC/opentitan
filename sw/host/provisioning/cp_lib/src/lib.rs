// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

use std::time::Duration;

use anyhow::{Context, Result};
use clap::Args;
use serde::Serialize;

use opentitanlib::app::{TransportWrapper, UartRx};
use opentitanlib::console::spi::SpiConsoleDevice;
use opentitanlib::io::jtag::{JtagParams, JtagTap};
use opentitanlib::test_utils::lc_transition::trigger_lc_transition;
use opentitanlib::test_utils::load_sram_program::{
    ExecutionMode, ExecutionResult, SramProgramParams,
};
use opentitanlib::test_utils::rpc::{ConsoleRecv, ConsoleSend};
use opentitanlib::uart::console::UartConsole;
use ot_hal::dif::lc_ctrl::{DifLcCtrlState, DifLcCtrlToken, LcCtrlReg};
use ujson_lib::provisioning_data::{ManufCpProvisioningData, ManufCpProvisioningDataOut};

// Generated by the `lc_raw_unlock_token` Bazel rule from `//rules/lc.bzl`.
mod lc_raw_unlock_token;

/// Provisioning data command-line parameters.
#[derive(Debug, Args, Clone)]
pub struct ManufCpProvisioningDataInput {
    /// Wafer Authentication Secret to provision.
    #[arg(long)]
    pub wafer_auth_secret: String,

    /// TestUnlock token to provision.
    #[arg(long)]
    pub test_unlock_token: String,

    /// TestExit token to provision.
    #[arg(long)]
    pub test_exit_token: String,
}

#[derive(Debug, Clone, Default, Serialize)]
pub struct CpResponse {
    pub cp_device_id: String,
}

pub fn unlock_raw(transport: &TransportWrapper, jtag_params: &JtagParams) -> Result<()> {
    // Set the TAP straps for the lifecycle controller and reset.
    transport
        .pin_strapping("PINMUX_TAP_LC")?
        .apply()
        .context("failed to apply LC TAP strapping")?;
    transport.reset(UartRx::Clear).context("failed to reset")?;

    // Connect to the LC TAP via JTAG.
    let mut jtag = jtag_params
        .create(transport)?
        .connect(JtagTap::LcTap)
        .context("failed to connect to LC TAP over JTAG")?;

    // Provide the `RAW_UNLOCK` token
    let token = DifLcCtrlToken::from(lc_raw_unlock_token::RND_CNST_RAW_UNLOCK_TOKEN.to_le_bytes());
    let token_words = token.into_register_values();

    // ROM execution is not enabled in the OTP so we can safely reconnect to the LC TAP after
    // the transition without risking the chip resetting.
    trigger_lc_transition(
        transport,
        jtag,
        DifLcCtrlState::TestUnlocked0,
        Some(token_words),
        /*use_external_clk=*/
        true, // AST will NOT be calibrated yet, so we need ext_clk.
        Some(JtagTap::LcTap),
    )
    .context("failed to transition to TEST_UNLOCKED0.")?;

    jtag = jtag_params.create(transport)?.connect(JtagTap::LcTap)?;

    // Check that LC state is `TEST_UNLOCKED0`.
    let state = jtag.read_lc_ctrl_reg(&LcCtrlReg::LcState)?;
    assert_eq!(state, DifLcCtrlState::TestUnlocked0.redundant_encoding());
    jtag.disconnect()?;
    transport.pin_strapping("PINMUX_TAP_LC")?.remove()?;

    Ok(())
}

#[allow(clippy::too_many_arguments)]
pub fn run_sram_cp_provision(
    transport: &TransportWrapper,
    jtag_params: &JtagParams,
    sram_program: &SramProgramParams,
    data_in: &ManufCpProvisioningData,
    spi_console: &SpiConsoleDevice,
    response: &mut CpResponse,
    timeout: Duration,
) -> Result<()> {
    // Reset the SPI console before loading the target firmware.
    spi_console.reset_frame_counter();

    // Set CPU TAP straps, reset, and connect to the JTAG interface.
    transport.pin_strapping("PINMUX_TAP_RISCV")?.apply()?;
    transport.reset(UartRx::Clear)?;
    let mut jtag = jtag_params.create(transport)?.connect(JtagTap::RiscvTap)?;

    // Reset and halt the CPU to ensure we are in a known state, and clear out any ROM messages
    // printed over the console.
    jtag.reset(/*run=*/ false)?;

    // Load and execute the SRAM program that contains the provisioning code.
    let result = sram_program.load_and_execute(&mut *jtag, ExecutionMode::Jump)?;
    match result {
        ExecutionResult::Executing => log::info!("SRAM program loaded and is executing."),
        _ => panic!("SRAM program load/execution failed: {:?}.", result),
    }

    // Wait for test to start running.
    let _ = UartConsole::wait_for(
        spi_console,
        r"Waiting for CP provisioning data ...",
        timeout,
    )?;

    // Inject provisioning data into the device.
    data_in.send(spi_console)?;

    // Wait to receive CP device ID, and encode in big-endian in response.
    let _ = UartConsole::wait_for(spi_console, r"Exporting CP device ID ...", timeout)?;
    response.cp_device_id = ManufCpProvisioningDataOut::recv(spi_console, timeout, true)?
        .cp_device_id
        .iter()
        .rev()
        .map(|v| format!("{v:08X}"))
        .collect::<Vec<String>>()
        .join("");

    // Wait for provisioning operations to complete.
    let _ = UartConsole::wait_for(spi_console, r"CP provisioning done.", timeout)?;

    jtag.disconnect()?;
    transport.pin_strapping("PINMUX_TAP_RISCV")?.remove()?;

    Ok(())
}

pub fn reset_and_lock(transport: &TransportWrapper, jtag_params: &JtagParams) -> Result<()> {
    // Set the TAP straps for the lifecycle controller and reset.
    transport
        .pin_strapping("PINMUX_TAP_LC")?
        .apply()
        .context("failed to apply LC TAP strapping")?;
    transport.reset(UartRx::Clear).context("failed to reset")?;

    // Connect to the LC TAP via JTAG.
    let mut jtag = jtag_params
        .create(transport)?
        .connect(JtagTap::LcTap)
        .context("failed to connect to LC TAP over JTAG")?;

    // CPU execution is not enabled in TEST_LOCKED0 so we can safely reconnect to the LC TAP
    // after the transition without risking the chip resetting.
    trigger_lc_transition(
        transport,
        jtag,
        DifLcCtrlState::TestLocked0,
        None,
        /*use_external_clk=*/
        false, // AST will be calibrated by now, so no need for ext_clk.
        Some(JtagTap::LcTap),
    )
    .context("failed to transition to TEST_LOCKED0.")?;

    jtag = jtag_params.create(transport)?.connect(JtagTap::LcTap)?;

    // Check that LC state is `TEST_LOCKED0`.
    let state = jtag.read_lc_ctrl_reg(&LcCtrlReg::LcState)?;
    assert_eq!(state, DifLcCtrlState::TestLocked0.redundant_encoding());
    jtag.disconnect()?;
    transport.pin_strapping("PINMUX_TAP_LC")?.remove()?;

    Ok(())
}
