// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

//! This module is capable of generating C code for generating a binary X.509
//! certificate according to a [`Template`](crate::template::Template).

use anyhow::{Context, Result};
use heck::ToUpperCamelCase;
use std::collections::HashMap;

use crate::asn1::codegen::{self, ConstantPool, VariableCodegenInfo, VariableInfo};
use crate::asn1::x509::X509;
use crate::template::{EcdsaSignature, Signature, Template, Value, Variable, VariableType};

const INDENT: &str = "  ";
const WRITER_MAIN: &str = r#"
#include <stdio.h>
#include <stdlib.h>

status_t fgetc_wrapper(void *context) {
  int c = fgetc((FILE *)context);
  if (c == EOF) return UNAVAILABLE(c);
  else return OK_STATUS(c);
}

status_t putbuf_wrapper(void *context, const char *msg, size_t len) {
  fwrite(msg, len, 1, stderr);
  return OK_STATUS();
}

status_t execute_test(ujson_t uj, FILE *outf) {
  values_t values;
  TRY(ujson_deserialize_values_t(&uj, &values));
  size_t cert_size = 1000;
  uint8_t *cert = malloc(cert_size);
  TRY(build_cert(&values, cert, &cert_size));
  fwrite(cert, cert_size, 1, outf);
  fclose(outf);
  return OK_STATUS();
}

int main(int argc, char **argv) {
  if (argc != 3) {
    fprintf(stderr, "usage: %s <values.json> <output.pem>\n", argv[0]);
    return 1;
  }
  FILE *inf = fopen(argv[1], "r");
  if (inf == NULL) {
    perror("cannot open json file with values");
    return 2;
  }
  FILE *outf = fopen(argv[2], "wb");
  if (outf == NULL) {
    perror("cannot open output certificate file with values");
    return 2;
  }
  ujson_t ujson = ujson_init(inf, fgetc_wrapper, putbuf_wrapper);
  status_t err = execute_test(ujson, outf);
  const char *code = NULL;
  int32_t arg = 0;
  char mod_id[5];
  bool is_err = status_extract(err, &code, &arg, mod_id);
  mod_id[4] = 0;
  if(is_err) {
    fprintf(stderr, "An error occured: %s[%d,%s]\n", code, arg, mod_id);
  }
  return 0;
}
"#;

pub struct Codegen {
    /// Header.
    pub source_h: String,
    /// Code containing the template and setters.
    pub source_c: String,
    /// Code containing the template writer.
    pub writer: String,
}

/// Generate the certificate template header and source file.
///
/// The generated files will indicate that they have been automatically
/// generated from `from_file`.
/// Returns the implementation first and the header file second.
pub fn generate_cert(from_file: &str, tmpl: &Template) -> Result<Codegen> {
    let mut source_c = String::new();
    let mut source_h = String::new();
    let mut source_writer = String::new();

    let license_and_warning = indoc::formatdoc! { r#"
        // Copyright lowRISC contributors.
        // Licensed under the Apache License, Version 2.0, see LICENSE for details.
        // SPDX-License-Identifier: Apache-2.0

        // This file was automatically generated using opentitantool from:
        // {from_file}
        "#};

    // License, warning about autogenerated code and guard inclusion checks.
    source_c.push_str(&license_and_warning);
    source_h.push_str(&license_and_warning);
    source_writer.push_str(&license_and_warning);
    let preproc_guard_include = tmpl.name.to_uppercase();
    source_h.push_str(&format!("#ifndef __{}__\n", preproc_guard_include));
    source_h.push_str(&format!("#define __{}__\n\n", preproc_guard_include));

    // Headers inclusion.
    source_c.push('\n');
    source_c.push_str(&format!("#include \"{}.h\"\n", tmpl.name));
    source_c.push_str("#include \"sw/device/silicon_creator/lib/cert/asn1.h\"\n\n");

    source_h.push_str("#include \"sw/device/lib/base/status.h\"\n\n");

    source_writer.push('\n');
    source_writer.push_str(&format!("#include \"{}.h\"\n", tmpl.name));
    source_writer.push_str("#define UJSON_SERDE_IMPL 1\n");
    source_writer.push_str("#include \"sw/device/lib/ujson/ujson_derive.h\"\n\n");

    // Partition variables between TBS and signature
    let mut tbs_vars = HashMap::<String, VariableType>::new();
    let mut sig_vars = HashMap::<String, VariableType>::new();
    for (var_name, var) in tmpl.variables.clone() {
        if var_appears_in_sig(&var_name, &tmpl.certificate.signature) {
            sig_vars.insert(var_name, var);
        } else {
            tbs_vars.insert(var_name, var);
        }
    }

    // Structure containing the TBS variables.
    let tbs_value_struct_name = format!("{}_tbs_values", tmpl.name);
    source_h.push_str(&generate_value_struct(&tbs_value_struct_name, &tbs_vars));
    let tbs_value_struct_name = tbs_value_struct_name + "_t";

    // Create a constant pool to share between the two functions.
    let mut const_pool = ConstantPool::new();

    // Generate TBS function.
    let generate_tbs_fn_name = format!("{}_build_tbs", tmpl.name);
    let (generate_tbs_fn_def, generate_tbs_fn_impl, max_tbs_size) = generate_builder(
        &generate_tbs_fn_name,
        &tbs_value_struct_name,
        &mut const_pool,
        &tbs_vars,
        |builder| X509::push_tbs_certificate(builder, &tmpl.certificate),
    )?;

    // Create a special variable to hold the TBS binary.
    let tbs_binary_val_name = "tbs";
    sig_vars.insert(
        tbs_binary_val_name.to_string(),
        VariableType::ByteArray { size: max_tbs_size },
    );
    let tbs_binary_val = Value::Variable(Variable {
        name: tbs_binary_val_name.to_string(),
        convert: None,
    });

    // Structure containing the signature variables.
    let sig_value_struct_name = format!("{}_sig_values", tmpl.name);
    source_h.push_str(&generate_value_struct(&sig_value_struct_name, &sig_vars));
    let sig_value_struct_name = sig_value_struct_name + "_t";

    // Generate sig function.
    let generate_cert_fn_name = format!("{}_build_cert", tmpl.name);
    let (generate_cert_fn_def, generate_cert_fn_impl, max_cert_size) = generate_builder(
        &generate_cert_fn_name,
        &sig_value_struct_name,
        &mut const_pool,
        &sig_vars,
        |builder| X509::push_certificate(builder, &tbs_binary_val, &tmpl.certificate.signature),
    )?;

    // Create two constants for the maximum possible size of TBS and cert.
    // TODO: add a comment specifying the sizes used to compute this?
    let max_tbs_size_const_name = format!("k{}MaxTbsSizeBytes", tmpl.name.to_upper_camel_case());
    let max_cert_size_const_name = format!("k{}MaxCertSizeBytes", tmpl.name.to_upper_camel_case());
    source_h.push_str(&indoc::formatdoc! {"enum {{
    {INDENT}{max_tbs_size_const_name} = {max_tbs_size},
    {INDENT}{max_cert_size_const_name} = {max_cert_size},
    }};"});

    source_h.push_str("\n\n");
    source_h.push_str(&generate_tbs_fn_def);
    source_h.push_str(&generate_cert_fn_def);
    source_h.push('\n');

    source_c.push_str(&const_pool.codestring());
    source_c.push('\n');
    source_c.push_str(&generate_tbs_fn_impl);
    source_c.push_str(&generate_cert_fn_impl);
    source_c.push('\n');

    source_h.push_str(&format!("\n#endif /* __{}__ */\n", preproc_guard_include));

    // Writer ujson declaration.
    source_writer.push_str("#define STRUCT_VALUES(field, string)");
    for (var_name, var_type) in &tmpl.variables {
        source_writer.push_str(" \\\n");
        source_writer.push_str(INDENT);
        match var_type {
            VariableType::ByteArray { size } => {
                source_writer.push_str(&format!("field({var_name}, uint8_t, {size})"))
            }
            VariableType::String { size } => {
                source_writer.push_str(&format!("field({var_name}, char, {size})"))
            }
            &VariableType::Integer { size } => match c_integer_for_length(size) {
                Some(typename) => source_writer.push_str(&format!("field({var_name}, {typename})")),
                None => source_writer.push_str(&format!("field({var_name}, uint8_t, {size})")),
            },
        }
    }
    source_writer.push_str("\nUJSON_SERDE_STRUCT(Values, values_t, STRUCT_VALUES);\n\n");

    // Writer setters call.
    source_writer.push_str(
        "rom_error_t build_cert(values_t *values, uint8_t *out_cert, size_t *inout_size) {\n",
    );
    // Copy TBS values.
    source_writer.push_str(&generate_value_copy(
        &tbs_value_struct_name,
        "tbs_values",
        "values",
        &tbs_vars,
    ));
    // Call TBS generator to generate TBS in a temporary buffer.
    source_writer.push_str(&format!(
        "{INDENT}static uint8_t tbs_buf[{max_tbs_size_const_name}];\n"
    ));
    source_writer.push_str(&format!("{INDENT}size_t tbs_size = sizeof(tbs_buf);\n"));
    source_writer.push_str(&format!(
        "{INDENT}RETURN_IF_ERROR({generate_tbs_fn_name}(&tbs_values, tbs_buf, &tbs_size));\n"
    ));
    // Copy signature values.
    sig_vars.remove(tbs_binary_val_name);
    source_writer.push_str(&generate_value_copy(
        &sig_value_struct_name,
        "sig_values",
        "values",
        &sig_vars,
    ));
    // Set TBS binary.
    source_writer.push_str(&format!(
        "{INDENT}sig_values.{tbs_binary_val_name} = tbs_buf;\n"
    ));
    source_writer.push_str(&format!(
        "{INDENT}sig_values.{tbs_binary_val_name}_size = tbs_size;\n"
    ));
    // Call certificate generator.
    source_writer.push_str(&format!(
        "{INDENT}return {generate_cert_fn_name}(&sig_values, out_cert, inout_size);\n"
    ));
    source_writer.push_str("}\n\n\n");

    // Writer main.
    source_writer.push_str(WRITER_MAIN);

    Ok(Codegen {
        source_h,
        source_c,
        writer: source_writer,
    })
}

fn generate_value_struct(
    value_struct_name: &str,
    variables: &HashMap<String, VariableType>,
) -> String {
    let mut source = String::new();
    source.push_str(&format!("typedef struct {value_struct_name} {{\n"));
    for (var_name, var_type) in variables {
        // Ignore variables in the signature.
        // TODO: add comments for documentation?
        let (_, struct_def) = c_variable_info(var_name, "", var_type);
        source.push_str(&struct_def);
    }
    source.push_str(&format!("}} {value_struct_name}_t;\n\n"));
    source
}

fn generate_value_copy(
    local_struct_type: &str,
    local_struct_name: &str,
    uj_struct_name: &str,
    vars: &HashMap<String, VariableType>,
) -> String {
    let mut source = String::new();
    source.push_str(&format!(
        "{INDENT}{local_struct_type} {local_struct_name} = {{\n"
    ));
    for (var_name, var_type) in vars {
        let (codegen, _) = c_variable_info(var_name, "", var_type);
        match codegen {
            VariableCodegenInfo::Pointer {
                ptr_expr,
                size_expr,
            } => {
                source.push_str(&format!(
                    "{INDENT}{INDENT}.{ptr_expr} = {uj_struct_name}->{ptr_expr},\n"
                ));
                // NOTE: here we know that the `ptr_expr` is actually an array type, not a pointer, so sizeof() is correct.
                source.push_str(&format!(
                    "{INDENT}{INDENT}.{size_expr} = sizeof({uj_struct_name}->{ptr_expr}),\n"
                ));
            }
            VariableCodegenInfo::Int32 { value_expr } => source.push_str(&format!(
                "{INDENT}{INDENT}.{value_expr} = {uj_struct_name}->{value_expr},\n"
            )),
        }
    }
    source.push_str(&format!("{INDENT}}};\n"));
    source
}

fn var_appears_in_sig(var_name: &str, sig: &Signature) -> bool {
    match sig {
        Signature::EcdsaWithSha256 { value } => {
            let Some(EcdsaSignature { r, s }) = value else {
                return false;
            };
            r.refers_to(var_name) || s.refers_to(var_name)
        }
    }
}

fn generate_builder(
    fnname: &str,
    value_struct_name: &str,
    constants: &mut ConstantPool,
    variables: &HashMap<String, VariableType>,
    gen: impl FnOnce(&mut codegen::Codegen) -> Result<()>,
) -> Result<(String, String, usize)> {
    let generate_fn_def = format!(
        "rom_error_t {fnname}({value_struct_name} *values, uint8_t *tbs, size_t *tbs_inout_size)"
    );
    let mut generate_fn_impl = String::new();
    generate_fn_impl.push_str(&format!("rom_error_t {fnname}({value_struct_name} *values, uint8_t *tbs, size_t *tbs_inout_size) {{\n"));
    let get_var_info = |var_name: &str| -> Result<VariableInfo> {
        let var_type = variables
            .get(var_name)
            .with_context(|| format!("could not find variable '{var_name}'"))
            .copied()?;
        let (codegen, _) = c_variable_info(var_name, "values->", &var_type);
        Ok(VariableInfo { var_type, codegen })
    };
    let (implementation, max_size) = codegen::Codegen::generate(
        /* buf_name */ "tbs",
        /* buf_size_name */ "tbs_inout_size",
        /* indent */ INDENT,
        /* indent_lvl */ 1,
        constants,
        &get_var_info,
        gen,
    )?;
    generate_fn_impl.push_str(&implementation);
    generate_fn_impl.push_str("  return kErrorOk;\n");
    generate_fn_impl.push_str("}\n\n");

    Ok((generate_fn_def + ";\n", generate_fn_impl, max_size))
}

fn c_integer_for_length(size: usize) -> Option<&'static str> {
    match size {
        4 => Some("uint32_t"),
        _ => None,
    }
}

// Return information about a variable (codegen info, definition in struct)
fn c_variable_info(
    name: &str,
    struct_expr: &str,
    var_type: &VariableType,
) -> (VariableCodegenInfo, String) {
    match var_type {
        VariableType::ByteArray { .. } => (
            VariableCodegenInfo::Pointer {
                ptr_expr: format!("{struct_expr}{name}"),
                size_expr: format!("{struct_expr}{name}_size"),
            },
            format!("{INDENT}uint8_t *{name};\n{INDENT}size_t {name}_size;\n"),
        ),
        VariableType::Integer { size } => match c_integer_for_length(*size) {
            Some(c_type) => (
                VariableCodegenInfo::Int32 {
                    value_expr: format!("{struct_expr}{name}"),
                },
                format!("{INDENT}{c_type} {name};\n"),
            ),
            None => (
                VariableCodegenInfo::Pointer {
                    ptr_expr: format!("{struct_expr}{name}"),
                    size_expr: format!("{struct_expr}{name}_size"),
                },
                format!("{INDENT}uint8_t *{name};\n{INDENT}size_t {name}_size;\n"),
            ),
        },
        VariableType::String { .. } => (
            VariableCodegenInfo::Pointer {
                ptr_expr: format!("{struct_expr}{name}"),
                size_expr: format!("{struct_expr}{name}_len"),
            },
            format!("{INDENT}char *{name};\n{INDENT}size_t {name}_len;\n"),
        ),
    }
}
