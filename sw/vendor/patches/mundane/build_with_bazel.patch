diff --git a/.gitignore b/.gitignore
index aa085cd..e16558b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
 Cargo.lock
 /target
 **/*.rs.bk
+bazel-*
diff --git a/BUILD.bazel b/BUILD.bazel
new file mode 100644
index 0000000..649d2b5
--- /dev/null
+++ b/BUILD.bazel
@@ -0,0 +1,48 @@
+load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
+
+package(default_visibility = ["//visibility:public"])
+
+rust_library(
+    name = "mundane",
+    srcs = [
+        "src/boringssl/abort.rs",
+        "src/boringssl/mod.rs",
+        "src/boringssl/raw.rs",
+        "src/boringssl/wrapper.rs",
+        "src/bytes.rs",
+        "src/hash.rs",
+        "src/hmac.rs",
+        "src/insecure.rs",
+        "src/insecure_rc4.rs",
+        "src/kdf.rs",
+        "src/lib.rs",
+        "src/macros.rs",
+        "src/password.rs",
+        "src/public/ec/curve.rs",
+        "src/public/ec/mod.rs",
+        "src/public/ed25519.rs",
+        "src/public/mod.rs",
+        "src/public/rsa/bits.rs",
+        "src/public/rsa/mod.rs",
+        "src/util.rs",
+    ],
+    compile_data = [
+        "//boringssl:boringssl_without_renames.rs",
+    ],
+    crate_features = [
+        "bazel_build",
+        "rsa-pkcs1v15",
+    ],
+    edition = "2015",
+    deps = [
+        "@boringssl//:crypto",
+    ],
+)
+
+rust_test(
+    name = "mundane_test",
+    crate = ":mundane",
+    crate_features = [
+        "bazel_build",
+    ],
+)
diff --git a/WORKSPACE.bazel b/WORKSPACE.bazel
new file mode 100644
index 0000000..4b7301c
--- /dev/null
+++ b/WORKSPACE.bazel
@@ -0,0 +1,28 @@
+workspace(name = "mundane")
+
+load("@bazel_tools//tools/build_defs/repo:git.bzl", "git_repository")
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
+
+http_archive(
+    name = "rules_rust",
+    sha256 = "531bdd470728b61ce41cf7604dc4f9a115983e455d46ac1d0c1632f613ab9fc3",
+    strip_prefix = "rules_rust-d8238877c0e552639d3e057aadd6bfcf37592408",
+    urls = [
+        # `main` branch as of 2021-08-23
+        "https://github.com/bazelbuild/rules_rust/archive/d8238877c0e552639d3e057aadd6bfcf37592408.tar.gz",
+    ],
+)
+
+load("@rules_rust//rust:repositories.bzl", "rust_repositories")
+
+rust_repositories(
+    edition = "2018",
+    version = "1.53.0",
+)
+
+# boringssl `main-with-bazel` branch as of 2021-11-09.
+git_repository(
+    name = "boringssl",
+    commit = "4fb158925f7753d80fb858cb0239dff893ef9f15",
+    remote = "https://boringssl.googlesource.com/boringssl",
+)
diff --git a/boringssl/BUILD.bazel b/boringssl/BUILD.bazel
new file mode 100644
index 0000000..5bf28c3
--- /dev/null
+++ b/boringssl/BUILD.bazel
@@ -0,0 +1,3 @@
+package(default_visibility = ["//visibility:public"])
+
+exports_files(glob(["**"]))
diff --git a/boringssl/README.md b/boringssl/README.md
index 7f9a6fe..37cae7e 100644
--- a/boringssl/README.md
+++ b/boringssl/README.md
@@ -50,6 +50,11 @@ In order to avoid this problem, we compile BoringSSL with a custom symbol prefix
 specific to the crate version. This document describes the details of how this
 works.
 
+Note: If you are building this library with [Bazel](https://bazel.build/),
+symbol prefixing is *not* applied.  This is because a bazel workspace
+configuration will insist on exactly one instance of BoringSSL and, as such,
+linking with multiple versions of the library is impossible.
+
 ### Prefixing
 
 Each BoringSSL symbol is given a prefix of `__RUST_MUNDANE_X_Y_Z_`, where the
diff --git a/boringssl/bindgen.sh b/boringssl/bindgen.sh
index 9f317aa..5c7a8a6 100755
--- a/boringssl/bindgen.sh
+++ b/boringssl/bindgen.sh
@@ -12,7 +12,7 @@ set -e
 readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
 cd "$SCRIPT_DIR"
 
-if [ $# -ne 3 ]; then
+if [[ $# -ne 3 ]]; then
     echo "Usage: $0 <major> <minor> <patch>" >&2
     exit 1
 fi
@@ -170,7 +170,7 @@ ALLOWLIST="(${ALLOWLIST_FUNCS}|${ALLOWLIST_OTHERS})"
 # changing the Rust types that are generated for particular C types). If a more
 # recent version of bindgen is available, "roll" bindgen by updating the
 # `BINDGEN_EXPECTED_VERSION` variable here.
-BINDGEN_EXPECTED_VERSION="bindgen 0.57.0"
+BINDGEN_EXPECTED_VERSION="bindgen 0.59.1"
 BINDGEN_GOT_VERSION="$(bindgen --version)"
 if [ "$BINDGEN_GOT_VERSION" != "$BINDGEN_EXPECTED_VERSION" ]; then
     echo "Unexpected version of bindgen: got $BINDGEN_GOT_VERSION; wanted $BINDGEN_EXPECTED_VERSION.
@@ -187,8 +187,6 @@ fi
 bindgen bindgen.h --whitelist-function "$ALLOWLIST" --whitelist-type "$ALLOWLIST" \
     --whitelist-var "$ALLOWLIST" -o boringssl.rs -- -I ./boringssl/include
 
-TMP="$(mktemp)"
-
 # Prepend copyright comment, #[allow] for various warnings we don't care about,
 # and a line telling Rust to link against libcrypto.
 (cat <<'EOF'
@@ -208,18 +206,21 @@ TMP="$(mktemp)"
 #![allow(non_snake_case)]
 #![allow(non_upper_case_globals)]
 #![allow(clippy::all)]
+#![allow(deref_nullptr)]
 
 EOF
 
 # Do this on a separate line because we need string interpolation, but we can't
 # use string interpolation in the preceding 'cat' command, or else the !
 # characters would be interpreted.
+echo "#[cfg(not(feature = \"bazel_build\"))]"
 echo "#[link(name = \"crypto_${MAJOR}_${MINOR}_${PATCH}\")] extern {}"
 echo
 
-cat boringssl.rs) \
-| rustfmt \
-| (
+cat boringssl.rs) | rustfmt > "boringssl_without_renames.rs"
+rm boringssl.rs
+
+cat "boringssl_without_renames.rs" | rustfmt | (
 # Postprocess the generated bindings, adding the "#[link_name ...]"
 # attribute to exported functions. Since the function sites are matched
 # lexically, check the consistency of matches against the list of function
@@ -257,5 +258,4 @@ END {
             print "fatal: fn match count = " f[fn] + 0 ", should be 1: " fn | "cat >&2"
             exit 1
         }
-}') > "$TMP"
-mv "$TMP" boringssl.rs
+}') > "boringssl_with_renames.rs"
diff --git a/boringssl/boringssl.rs b/boringssl/boringssl_with_renames.rs
similarity index 97%
rename from boringssl/boringssl.rs
rename to boringssl/boringssl_with_renames.rs
index e7064b0..d761dfa 100644
--- a/boringssl/boringssl.rs
+++ b/boringssl/boringssl_with_renames.rs
@@ -14,11 +14,13 @@
 #![allow(non_snake_case)]
 #![allow(non_upper_case_globals)]
 #![allow(clippy::all)]
+#![allow(deref_nullptr)]
 
+#[cfg(not(feature = "bazel_build"))]
 #[link(name = "crypto_0_4_4")]
 extern "C" {}
 
-/* automatically generated by rust-bindgen 0.57.0 */
+/* automatically generated by rust-bindgen 0.59.1 */
 
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
@@ -103,44 +105,9 @@ pub const SHA256_DIGEST_LENGTH: u32 = 32;
 pub const SHA384_DIGEST_LENGTH: u32 = 48;
 pub const SHA512_DIGEST_LENGTH: u32 = 64;
 pub type size_t = ::std::os::raw::c_ulong;
-#[repr(C)]
-#[derive(Copy, Clone)]
-pub struct _opaque_pthread_rwlock_t {
-    pub __sig: ::std::os::raw::c_long,
-    pub __opaque: [::std::os::raw::c_char; 192usize],
-}
-#[test]
-fn bindgen_test_layout__opaque_pthread_rwlock_t() {
-    assert_eq!(
-        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
-        200usize,
-        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
-    );
-    assert_eq!(
-        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
-        8usize,
-        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
-    );
-    assert_eq!(
-        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
-        0usize,
-        concat!("Offset of field: ", stringify!(_opaque_pthread_rwlock_t), "::", stringify!(__sig))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(_opaque_pthread_rwlock_t),
-            "::",
-            stringify!(__opaque)
-        )
-    );
-}
-pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
-pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
+pub type __uint8_t = ::std::os::raw::c_uchar;
+pub type __uint32_t = ::std::os::raw::c_uint;
+pub type __uint64_t = ::std::os::raw::c_ulong;
 pub type BIGNUM = bignum_st;
 pub type BN_GENCB = bn_gencb_st;
 pub type BN_MONT_CTX = bn_mont_ctx_st;
@@ -204,7 +171,36 @@ pub type RSA = rsa_st;
 pub type SHA256_CTX = sha256_state_st;
 pub type SHA512_CTX = sha512_state_st;
 pub type SHA_CTX = sha_state_st;
-pub type CRYPTO_MUTEX = pthread_rwlock_t;
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub union crypto_mutex_st {
+    pub alignment: f64,
+    pub padding: [u8; 56usize],
+}
+#[test]
+fn bindgen_test_layout_crypto_mutex_st() {
+    assert_eq!(
+        ::std::mem::size_of::<crypto_mutex_st>(),
+        56usize,
+        concat!("Size of: ", stringify!(crypto_mutex_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<crypto_mutex_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(crypto_mutex_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<crypto_mutex_st>())).alignment as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(crypto_mutex_st), "::", stringify!(alignment))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<crypto_mutex_st>())).padding as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(crypto_mutex_st), "::", stringify!(padding))
+    );
+}
+pub type CRYPTO_MUTEX = crypto_mutex_st;
 pub type CRYPTO_refcount_t = u32;
 extern "C" {
     #[link_name = "__RUST_MUNDANE_0_4_4_BN_init"]
@@ -825,7 +821,6 @@ pub union evp_pkey_st__bindgen_ty_1 {
     pub dsa: *mut DSA,
     pub dh: *mut DH,
     pub ec: *mut EC_KEY,
-    _bindgen_union_align: u64,
 }
 #[test]
 fn bindgen_test_layout_evp_pkey_st__bindgen_ty_1() {
@@ -1002,7 +997,7 @@ extern "C" {
     pub fn MD5_Transform(md5: *mut MD5_CTX, block: *const u8);
 }
 #[repr(C)]
-#[derive(Copy, Clone)]
+#[derive(Debug, Copy, Clone)]
 pub struct md5_state_st {
     pub h: [u32; 4usize],
     pub Nl: u32,
@@ -1061,7 +1056,7 @@ extern "C" {
     pub fn RAND_bytes(buf: *mut u8, len: size_t) -> ::std::os::raw::c_int;
 }
 #[repr(C)]
-#[derive(Copy, Clone)]
+#[derive(Debug, Copy, Clone)]
 pub struct rc4_key_st {
     pub x: u32,
     pub y: u32,
@@ -1349,7 +1344,7 @@ pub struct rsa_st {
 }
 #[test]
 fn bindgen_test_layout_rsa_st() {
-    assert_eq!(::std::mem::size_of::<rsa_st>(), 384usize, concat!("Size of: ", stringify!(rsa_st)));
+    assert_eq!(::std::mem::size_of::<rsa_st>(), 240usize, concat!("Size of: ", stringify!(rsa_st)));
     assert_eq!(
         ::std::mem::align_of::<rsa_st>(),
         8usize,
@@ -1422,37 +1417,37 @@ fn bindgen_test_layout_rsa_st() {
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).mont_n as *const _ as usize },
-        288usize,
+        144usize,
         concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(mont_n))
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).mont_p as *const _ as usize },
-        296usize,
+        152usize,
         concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(mont_p))
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).mont_q as *const _ as usize },
-        304usize,
+        160usize,
         concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(mont_q))
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).d_fixed as *const _ as usize },
-        312usize,
+        168usize,
         concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(d_fixed))
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).dmp1_fixed as *const _ as usize },
-        320usize,
+        176usize,
         concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmp1_fixed))
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).dmq1_fixed as *const _ as usize },
-        328usize,
+        184usize,
         concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmq1_fixed))
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).inv_small_mod_large_mont as *const _ as usize },
-        336usize,
+        192usize,
         concat!(
             "Offset of field: ",
             stringify!(rsa_st),
@@ -1462,22 +1457,22 @@ fn bindgen_test_layout_rsa_st() {
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).num_blindings as *const _ as usize },
-        344usize,
+        200usize,
         concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(num_blindings))
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).blindings as *const _ as usize },
-        352usize,
+        208usize,
         concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(blindings))
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).blindings_inuse as *const _ as usize },
-        360usize,
+        216usize,
         concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(blindings_inuse))
     );
     assert_eq!(
         unsafe { &(*(::std::ptr::null::<rsa_st>())).blinding_fork_generation as *const _ as usize },
-        368usize,
+        224usize,
         concat!(
             "Offset of field: ",
             stringify!(rsa_st),
@@ -1540,7 +1535,6 @@ pub struct sha_state_st {
 pub union sha_state_st__bindgen_ty_1 {
     pub h: [u32; 5usize],
     pub __bindgen_anon_1: sha_state_st__bindgen_ty_1__bindgen_ty_1,
-    _bindgen_union_align: [u32; 5usize],
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
@@ -1697,7 +1691,7 @@ extern "C" {
     pub fn SHA256_Final(out: *mut u8, sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
 }
 #[repr(C)]
-#[derive(Copy, Clone)]
+#[derive(Debug, Copy, Clone)]
 pub struct sha256_state_st {
     pub h: [u32; 8usize],
     pub Nl: u32,
@@ -1782,7 +1776,7 @@ extern "C" {
     pub fn SHA512_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
 }
 #[repr(C)]
-#[derive(Copy, Clone)]
+#[derive(Debug, Copy, Clone)]
 pub struct sha512_state_st {
     pub h: [u64; 8usize],
     pub Nl: u64,
diff --git a/boringssl/boringssl_without_renames.rs b/boringssl/boringssl_without_renames.rs
new file mode 100644
index 0000000..d45d1cb
--- /dev/null
+++ b/boringssl/boringssl_without_renames.rs
@@ -0,0 +1,1743 @@
+// Copyright 2018 Google LLC
+//
+// Use of this source code is governed by an MIT-style
+// license that can be found in the LICENSE file or at
+// https://opensource.org/licenses/MIT.
+
+// Some symbols are only used with certain features enabled, so we need to
+// suppress the unused warning when those features aren't enabled.
+#![allow(unused)]
+// Only necessary for test_symbol_conflict.sh, which exposes these symbols
+// through Mundane's public interface.
+#![allow(missing_docs)]
+#![allow(non_camel_case_types)]
+#![allow(non_snake_case)]
+#![allow(non_upper_case_globals)]
+#![allow(clippy::all)]
+#![allow(deref_nullptr)]
+
+#[cfg(not(feature = "bazel_build"))]
+#[link(name = "crypto_0_4_4")]
+extern "C" {}
+
+/* automatically generated by rust-bindgen 0.59.1 */
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
+pub struct __BindgenBitfieldUnit<Storage> {
+    storage: Storage,
+}
+impl<Storage> __BindgenBitfieldUnit<Storage> {
+    #[inline]
+    pub const fn new(storage: Storage) -> Self {
+        Self { storage }
+    }
+}
+impl<Storage> __BindgenBitfieldUnit<Storage>
+where
+    Storage: AsRef<[u8]> + AsMut<[u8]>,
+{
+    #[inline]
+    pub fn get_bit(&self, index: usize) -> bool {
+        debug_assert!(index / 8 < self.storage.as_ref().len());
+        let byte_index = index / 8;
+        let byte = self.storage.as_ref()[byte_index];
+        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
+        let mask = 1 << bit_index;
+        byte & mask == mask
+    }
+    #[inline]
+    pub fn set_bit(&mut self, index: usize, val: bool) {
+        debug_assert!(index / 8 < self.storage.as_ref().len());
+        let byte_index = index / 8;
+        let byte = &mut self.storage.as_mut()[byte_index];
+        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
+        let mask = 1 << bit_index;
+        if val {
+            *byte |= mask;
+        } else {
+            *byte &= !mask;
+        }
+    }
+    #[inline]
+    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
+        debug_assert!(bit_width <= 64);
+        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
+        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
+        let mut val = 0;
+        for i in 0..(bit_width as usize) {
+            if self.get_bit(i + bit_offset) {
+                let index =
+                    if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
+                val |= 1 << index;
+            }
+        }
+        val
+    }
+    #[inline]
+    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
+        debug_assert!(bit_width <= 64);
+        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
+        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
+        for i in 0..(bit_width as usize) {
+            let mask = 1 << i;
+            let val_bit_is_set = val & mask == mask;
+            let index = if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
+            self.set_bit(index + bit_offset, val_bit_is_set);
+        }
+    }
+}
+pub const ED25519_PRIVATE_KEY_LEN: u32 = 64;
+pub const ED25519_PUBLIC_KEY_LEN: u32 = 32;
+pub const ED25519_SIGNATURE_LEN: u32 = 64;
+pub const NID_md5: u32 = 4;
+pub const NID_sha1: u32 = 64;
+pub const NID_X9_62_prime256v1: u32 = 415;
+pub const NID_sha256: u32 = 672;
+pub const NID_sha384: u32 = 673;
+pub const NID_sha512: u32 = 674;
+pub const NID_secp384r1: u32 = 715;
+pub const NID_secp521r1: u32 = 716;
+pub const MD5_DIGEST_LENGTH: u32 = 16;
+pub const RSA_F4: u32 = 65537;
+pub const SHA_DIGEST_LENGTH: u32 = 20;
+pub const SHA256_DIGEST_LENGTH: u32 = 32;
+pub const SHA384_DIGEST_LENGTH: u32 = 48;
+pub const SHA512_DIGEST_LENGTH: u32 = 64;
+pub type size_t = ::std::os::raw::c_ulong;
+pub type __uint8_t = ::std::os::raw::c_uchar;
+pub type __uint32_t = ::std::os::raw::c_uint;
+pub type __uint64_t = ::std::os::raw::c_ulong;
+pub type BIGNUM = bignum_st;
+pub type BN_GENCB = bn_gencb_st;
+pub type BN_MONT_CTX = bn_mont_ctx_st;
+pub type CBB = cbb_st;
+pub type CBS = cbs_st;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct dh_st {
+    _unused: [u8; 0],
+}
+pub type DH = dh_st;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct dsa_st {
+    _unused: [u8; 0],
+}
+pub type DSA = dsa_st;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct ec_group_st {
+    _unused: [u8; 0],
+}
+pub type EC_GROUP = ec_group_st;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct ec_key_st {
+    _unused: [u8; 0],
+}
+pub type EC_KEY = ec_key_st;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct engine_st {
+    _unused: [u8; 0],
+}
+pub type ENGINE = engine_st;
+pub type EVP_MD_CTX = env_md_ctx_st;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct env_md_st {
+    _unused: [u8; 0],
+}
+pub type EVP_MD = env_md_st;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct evp_pkey_asn1_method_st {
+    _unused: [u8; 0],
+}
+pub type EVP_PKEY_ASN1_METHOD = evp_pkey_asn1_method_st;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct evp_pkey_ctx_st {
+    _unused: [u8; 0],
+}
+pub type EVP_PKEY_CTX = evp_pkey_ctx_st;
+pub type EVP_PKEY = evp_pkey_st;
+pub type HMAC_CTX = hmac_ctx_st;
+pub type MD5_CTX = md5_state_st;
+pub type RC4_KEY = rc4_key_st;
+pub type RSA_METHOD = rsa_meth_st;
+pub type RSA = rsa_st;
+pub type SHA256_CTX = sha256_state_st;
+pub type SHA512_CTX = sha512_state_st;
+pub type SHA_CTX = sha_state_st;
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub union crypto_mutex_st {
+    pub alignment: f64,
+    pub padding: [u8; 56usize],
+}
+#[test]
+fn bindgen_test_layout_crypto_mutex_st() {
+    assert_eq!(
+        ::std::mem::size_of::<crypto_mutex_st>(),
+        56usize,
+        concat!("Size of: ", stringify!(crypto_mutex_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<crypto_mutex_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(crypto_mutex_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<crypto_mutex_st>())).alignment as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(crypto_mutex_st), "::", stringify!(alignment))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<crypto_mutex_st>())).padding as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(crypto_mutex_st), "::", stringify!(padding))
+    );
+}
+pub type CRYPTO_MUTEX = crypto_mutex_st;
+pub type CRYPTO_refcount_t = u32;
+extern "C" {
+    pub fn BN_init(bn: *mut BIGNUM);
+}
+extern "C" {
+    pub fn BN_free(bn: *mut BIGNUM);
+}
+extern "C" {
+    pub fn BN_num_bytes(bn: *const BIGNUM) -> ::std::os::raw::c_uint;
+}
+extern "C" {
+    pub fn BN_set_u64(bn: *mut BIGNUM, value: u64) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn BN_bn2bin_padded(out: *mut u8, len: size_t, in_: *const BIGNUM)
+        -> ::std::os::raw::c_int;
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct bn_gencb_st {
+    pub arg: *mut ::std::os::raw::c_void,
+    pub callback: ::std::option::Option<
+        unsafe extern "C" fn(
+            event: ::std::os::raw::c_int,
+            n: ::std::os::raw::c_int,
+            arg1: *mut bn_gencb_st,
+        ) -> ::std::os::raw::c_int,
+    >,
+}
+#[test]
+fn bindgen_test_layout_bn_gencb_st() {
+    assert_eq!(
+        ::std::mem::size_of::<bn_gencb_st>(),
+        16usize,
+        concat!("Size of: ", stringify!(bn_gencb_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<bn_gencb_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(bn_gencb_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bn_gencb_st>())).arg as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(bn_gencb_st), "::", stringify!(arg))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bn_gencb_st>())).callback as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(bn_gencb_st), "::", stringify!(callback))
+    );
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct bignum_st {
+    pub d: *mut u64,
+    pub width: ::std::os::raw::c_int,
+    pub dmax: ::std::os::raw::c_int,
+    pub neg: ::std::os::raw::c_int,
+    pub flags: ::std::os::raw::c_int,
+}
+#[test]
+fn bindgen_test_layout_bignum_st() {
+    assert_eq!(
+        ::std::mem::size_of::<bignum_st>(),
+        24usize,
+        concat!("Size of: ", stringify!(bignum_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<bignum_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(bignum_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bignum_st>())).d as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(d))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bignum_st>())).width as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(width))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bignum_st>())).dmax as *const _ as usize },
+        12usize,
+        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(dmax))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bignum_st>())).neg as *const _ as usize },
+        16usize,
+        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(neg))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bignum_st>())).flags as *const _ as usize },
+        20usize,
+        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(flags))
+    );
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct bn_mont_ctx_st {
+    pub RR: BIGNUM,
+    pub N: BIGNUM,
+    pub n0: [u64; 2usize],
+}
+#[test]
+fn bindgen_test_layout_bn_mont_ctx_st() {
+    assert_eq!(
+        ::std::mem::size_of::<bn_mont_ctx_st>(),
+        64usize,
+        concat!("Size of: ", stringify!(bn_mont_ctx_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<bn_mont_ctx_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(bn_mont_ctx_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).RR as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(bn_mont_ctx_st), "::", stringify!(RR))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).N as *const _ as usize },
+        24usize,
+        concat!("Offset of field: ", stringify!(bn_mont_ctx_st), "::", stringify!(N))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).n0 as *const _ as usize },
+        48usize,
+        concat!("Offset of field: ", stringify!(bn_mont_ctx_st), "::", stringify!(n0))
+    );
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct cbs_st {
+    pub data: *const u8,
+    pub len: size_t,
+}
+#[test]
+fn bindgen_test_layout_cbs_st() {
+    assert_eq!(::std::mem::size_of::<cbs_st>(), 16usize, concat!("Size of: ", stringify!(cbs_st)));
+    assert_eq!(
+        ::std::mem::align_of::<cbs_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(cbs_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbs_st>())).data as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(cbs_st), "::", stringify!(data))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbs_st>())).len as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(cbs_st), "::", stringify!(len))
+    );
+}
+extern "C" {
+    pub fn CBS_init(cbs: *mut CBS, data: *const u8, len: size_t);
+}
+extern "C" {
+    pub fn CBS_len(cbs: *const CBS) -> size_t;
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct cbb_buffer_st {
+    pub buf: *mut u8,
+    pub len: size_t,
+    pub cap: size_t,
+    pub can_resize: ::std::os::raw::c_char,
+    pub error: ::std::os::raw::c_char,
+}
+#[test]
+fn bindgen_test_layout_cbb_buffer_st() {
+    assert_eq!(
+        ::std::mem::size_of::<cbb_buffer_st>(),
+        32usize,
+        concat!("Size of: ", stringify!(cbb_buffer_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<cbb_buffer_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(cbb_buffer_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).buf as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(buf))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).len as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(len))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).cap as *const _ as usize },
+        16usize,
+        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(cap))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).can_resize as *const _ as usize },
+        24usize,
+        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(can_resize))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).error as *const _ as usize },
+        25usize,
+        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(error))
+    );
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct cbb_st {
+    pub base: *mut cbb_buffer_st,
+    pub child: *mut CBB,
+    pub offset: size_t,
+    pub pending_len_len: u8,
+    pub pending_is_asn1: ::std::os::raw::c_char,
+    pub is_child: ::std::os::raw::c_char,
+}
+#[test]
+fn bindgen_test_layout_cbb_st() {
+    assert_eq!(::std::mem::size_of::<cbb_st>(), 32usize, concat!("Size of: ", stringify!(cbb_st)));
+    assert_eq!(
+        ::std::mem::align_of::<cbb_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(cbb_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_st>())).base as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(base))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_st>())).child as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(child))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_st>())).offset as *const _ as usize },
+        16usize,
+        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(offset))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_st>())).pending_len_len as *const _ as usize },
+        24usize,
+        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(pending_len_len))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_st>())).pending_is_asn1 as *const _ as usize },
+        25usize,
+        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(pending_is_asn1))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<cbb_st>())).is_child as *const _ as usize },
+        26usize,
+        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(is_child))
+    );
+}
+extern "C" {
+    pub fn CBB_init(cbb: *mut CBB, initial_capacity: size_t) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn CBB_cleanup(cbb: *mut CBB);
+}
+extern "C" {
+    pub fn CBB_data(cbb: *const CBB) -> *const u8;
+}
+extern "C" {
+    pub fn CBB_len(cbb: *const CBB) -> size_t;
+}
+extern "C" {
+    pub fn ED25519_keypair(out_public_key: *mut u8, out_private_key: *mut u8);
+}
+extern "C" {
+    pub fn ED25519_sign(
+        out_sig: *mut u8,
+        message: *const u8,
+        message_len: size_t,
+        private_key: *const u8,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn ED25519_verify(
+        message: *const u8,
+        message_len: size_t,
+        signature: *const u8,
+        public_key: *const u8,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn ED25519_keypair_from_seed(
+        out_public_key: *mut u8,
+        out_private_key: *mut u8,
+        seed: *const u8,
+    );
+}
+extern "C" {
+    pub fn EC_GROUP_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_GROUP;
+}
+extern "C" {
+    pub fn EC_GROUP_get_curve_name(group: *const EC_GROUP) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn EC_curve_nid2nist(nid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct openssl_method_common_st {
+    pub references: ::std::os::raw::c_int,
+    pub is_static: ::std::os::raw::c_char,
+}
+#[test]
+fn bindgen_test_layout_openssl_method_common_st() {
+    assert_eq!(
+        ::std::mem::size_of::<openssl_method_common_st>(),
+        8usize,
+        concat!("Size of: ", stringify!(openssl_method_common_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<openssl_method_common_st>(),
+        4usize,
+        concat!("Alignment of ", stringify!(openssl_method_common_st))
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<openssl_method_common_st>())).references as *const _ as usize
+        },
+        0usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(openssl_method_common_st),
+            "::",
+            stringify!(references)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<openssl_method_common_st>())).is_static as *const _ as usize
+        },
+        4usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(openssl_method_common_st),
+            "::",
+            stringify!(is_static)
+        )
+    );
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct stack_st_void {
+    _unused: [u8; 0],
+}
+pub type CRYPTO_EX_DATA = crypto_ex_data_st;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct crypto_ex_data_st {
+    pub sk: *mut stack_st_void,
+}
+#[test]
+fn bindgen_test_layout_crypto_ex_data_st() {
+    assert_eq!(
+        ::std::mem::size_of::<crypto_ex_data_st>(),
+        8usize,
+        concat!("Size of: ", stringify!(crypto_ex_data_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<crypto_ex_data_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(crypto_ex_data_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<crypto_ex_data_st>())).sk as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(crypto_ex_data_st), "::", stringify!(sk))
+    );
+}
+extern "C" {
+    pub fn EC_KEY_new() -> *mut EC_KEY;
+}
+extern "C" {
+    pub fn EC_KEY_free(key: *mut EC_KEY);
+}
+extern "C" {
+    pub fn EC_KEY_up_ref(key: *mut EC_KEY) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn EC_KEY_get0_group(key: *const EC_KEY) -> *const EC_GROUP;
+}
+extern "C" {
+    pub fn EC_KEY_set_group(key: *mut EC_KEY, group: *const EC_GROUP) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn EC_KEY_generate_key(key: *mut EC_KEY) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn EC_KEY_parse_private_key(cbs: *mut CBS, group: *const EC_GROUP) -> *mut EC_KEY;
+}
+extern "C" {
+    pub fn EC_KEY_marshal_private_key(
+        cbb: *mut CBB,
+        key: *const EC_KEY,
+        enc_flags: ::std::os::raw::c_uint,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn ECDSA_sign(
+        type_: ::std::os::raw::c_int,
+        digest: *const u8,
+        digest_len: size_t,
+        sig: *mut u8,
+        sig_len: *mut ::std::os::raw::c_uint,
+        key: *const EC_KEY,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn ECDSA_verify(
+        type_: ::std::os::raw::c_int,
+        digest: *const u8,
+        digest_len: size_t,
+        sig: *const u8,
+        sig_len: size_t,
+        key: *const EC_KEY,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn ECDSA_size(key: *const EC_KEY) -> size_t;
+}
+pub type ERR_print_errors_callback_t = ::std::option::Option<
+    unsafe extern "C" fn(
+        str_: *const ::std::os::raw::c_char,
+        len: size_t,
+        ctx: *mut ::std::os::raw::c_void,
+    ) -> ::std::os::raw::c_int,
+>;
+extern "C" {
+    pub fn ERR_print_errors_cb(
+        callback: ERR_print_errors_callback_t,
+        ctx: *mut ::std::os::raw::c_void,
+    );
+}
+extern "C" {
+    pub fn EVP_md5() -> *const EVP_MD;
+}
+extern "C" {
+    pub fn EVP_sha1() -> *const EVP_MD;
+}
+extern "C" {
+    pub fn EVP_sha256() -> *const EVP_MD;
+}
+extern "C" {
+    pub fn EVP_sha384() -> *const EVP_MD;
+}
+extern "C" {
+    pub fn EVP_sha512() -> *const EVP_MD;
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct evp_md_pctx_ops {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct env_md_ctx_st {
+    pub digest: *const EVP_MD,
+    pub md_data: *mut ::std::os::raw::c_void,
+    pub pctx: *mut EVP_PKEY_CTX,
+    pub pctx_ops: *const evp_md_pctx_ops,
+}
+#[test]
+fn bindgen_test_layout_env_md_ctx_st() {
+    assert_eq!(
+        ::std::mem::size_of::<env_md_ctx_st>(),
+        32usize,
+        concat!("Size of: ", stringify!(env_md_ctx_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<env_md_ctx_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(env_md_ctx_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).digest as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(env_md_ctx_st), "::", stringify!(digest))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).md_data as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(env_md_ctx_st), "::", stringify!(md_data))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).pctx as *const _ as usize },
+        16usize,
+        concat!("Offset of field: ", stringify!(env_md_ctx_st), "::", stringify!(pctx))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).pctx_ops as *const _ as usize },
+        24usize,
+        concat!("Offset of field: ", stringify!(env_md_ctx_st), "::", stringify!(pctx_ops))
+    );
+}
+extern "C" {
+    pub fn EVP_PKEY_new() -> *mut EVP_PKEY;
+}
+extern "C" {
+    pub fn EVP_PKEY_free(pkey: *mut EVP_PKEY);
+}
+extern "C" {
+    pub fn EVP_PKEY_up_ref(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn EVP_PKEY_assign_RSA(pkey: *mut EVP_PKEY, key: *mut RSA) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn EVP_PKEY_get1_RSA(pkey: *const EVP_PKEY) -> *mut RSA;
+}
+extern "C" {
+    pub fn EVP_PKEY_assign_EC_KEY(pkey: *mut EVP_PKEY, key: *mut EC_KEY) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn EVP_PKEY_get1_EC_KEY(pkey: *const EVP_PKEY) -> *mut EC_KEY;
+}
+extern "C" {
+    pub fn EVP_parse_public_key(cbs: *mut CBS) -> *mut EVP_PKEY;
+}
+extern "C" {
+    pub fn EVP_marshal_public_key(cbb: *mut CBB, key: *const EVP_PKEY) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn PKCS5_PBKDF2_HMAC(
+        password: *const ::std::os::raw::c_char,
+        password_len: size_t,
+        salt: *const u8,
+        salt_len: size_t,
+        iterations: ::std::os::raw::c_uint,
+        digest: *const EVP_MD,
+        key_len: size_t,
+        out_key: *mut u8,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn EVP_PBE_scrypt(
+        password: *const ::std::os::raw::c_char,
+        password_len: size_t,
+        salt: *const u8,
+        salt_len: size_t,
+        N: u64,
+        r: u64,
+        p: u64,
+        max_mem: size_t,
+        out_key: *mut u8,
+        key_len: size_t,
+    ) -> ::std::os::raw::c_int;
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub struct evp_pkey_st {
+    pub references: CRYPTO_refcount_t,
+    pub type_: ::std::os::raw::c_int,
+    pub pkey: evp_pkey_st__bindgen_ty_1,
+    pub ameth: *const EVP_PKEY_ASN1_METHOD,
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub union evp_pkey_st__bindgen_ty_1 {
+    pub ptr: *mut ::std::os::raw::c_void,
+    pub rsa: *mut RSA,
+    pub dsa: *mut DSA,
+    pub dh: *mut DH,
+    pub ec: *mut EC_KEY,
+}
+#[test]
+fn bindgen_test_layout_evp_pkey_st__bindgen_ty_1() {
+    assert_eq!(
+        ::std::mem::size_of::<evp_pkey_st__bindgen_ty_1>(),
+        8usize,
+        concat!("Size of: ", stringify!(evp_pkey_st__bindgen_ty_1))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<evp_pkey_st__bindgen_ty_1>(),
+        8usize,
+        concat!("Alignment of ", stringify!(evp_pkey_st__bindgen_ty_1))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).ptr as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(ptr))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).rsa as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(rsa))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).dsa as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(dsa))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).dh as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(dh))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).ec as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(ec))
+    );
+}
+#[test]
+fn bindgen_test_layout_evp_pkey_st() {
+    assert_eq!(
+        ::std::mem::size_of::<evp_pkey_st>(),
+        24usize,
+        concat!("Size of: ", stringify!(evp_pkey_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<evp_pkey_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(evp_pkey_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).references as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(evp_pkey_st), "::", stringify!(references))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).type_ as *const _ as usize },
+        4usize,
+        concat!("Offset of field: ", stringify!(evp_pkey_st), "::", stringify!(type_))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).pkey as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(evp_pkey_st), "::", stringify!(pkey))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).ameth as *const _ as usize },
+        16usize,
+        concat!("Offset of field: ", stringify!(evp_pkey_st), "::", stringify!(ameth))
+    );
+}
+extern "C" {
+    pub fn HMAC_CTX_init(ctx: *mut HMAC_CTX);
+}
+extern "C" {
+    pub fn HMAC_CTX_cleanup(ctx: *mut HMAC_CTX);
+}
+extern "C" {
+    pub fn HMAC_Init_ex(
+        ctx: *mut HMAC_CTX,
+        key: *const ::std::os::raw::c_void,
+        key_len: size_t,
+        md: *const EVP_MD,
+        impl_: *mut ENGINE,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn HMAC_Update(
+        ctx: *mut HMAC_CTX,
+        data: *const u8,
+        data_len: size_t,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn HMAC_Final(
+        ctx: *mut HMAC_CTX,
+        out: *mut u8,
+        out_len: *mut ::std::os::raw::c_uint,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn HMAC_size(ctx: *const HMAC_CTX) -> size_t;
+}
+extern "C" {
+    pub fn HMAC_CTX_copy(dest: *mut HMAC_CTX, src: *const HMAC_CTX) -> ::std::os::raw::c_int;
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct hmac_ctx_st {
+    pub md: *const EVP_MD,
+    pub md_ctx: EVP_MD_CTX,
+    pub i_ctx: EVP_MD_CTX,
+    pub o_ctx: EVP_MD_CTX,
+}
+#[test]
+fn bindgen_test_layout_hmac_ctx_st() {
+    assert_eq!(
+        ::std::mem::size_of::<hmac_ctx_st>(),
+        104usize,
+        concat!("Size of: ", stringify!(hmac_ctx_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<hmac_ctx_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(hmac_ctx_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).md as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(hmac_ctx_st), "::", stringify!(md))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).md_ctx as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(hmac_ctx_st), "::", stringify!(md_ctx))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).i_ctx as *const _ as usize },
+        40usize,
+        concat!("Offset of field: ", stringify!(hmac_ctx_st), "::", stringify!(i_ctx))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).o_ctx as *const _ as usize },
+        72usize,
+        concat!("Offset of field: ", stringify!(hmac_ctx_st), "::", stringify!(o_ctx))
+    );
+}
+extern "C" {
+    pub fn MD5_Init(md5: *mut MD5_CTX) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn MD5_Update(
+        md5: *mut MD5_CTX,
+        data: *const ::std::os::raw::c_void,
+        len: size_t,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn MD5_Final(out: *mut u8, md5: *mut MD5_CTX) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn MD5_Transform(md5: *mut MD5_CTX, block: *const u8);
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct md5_state_st {
+    pub h: [u32; 4usize],
+    pub Nl: u32,
+    pub Nh: u32,
+    pub data: [u8; 64usize],
+    pub num: ::std::os::raw::c_uint,
+}
+#[test]
+fn bindgen_test_layout_md5_state_st() {
+    assert_eq!(
+        ::std::mem::size_of::<md5_state_st>(),
+        92usize,
+        concat!("Size of: ", stringify!(md5_state_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<md5_state_st>(),
+        4usize,
+        concat!("Alignment of ", stringify!(md5_state_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<md5_state_st>())).h as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(h))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<md5_state_st>())).Nl as *const _ as usize },
+        16usize,
+        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(Nl))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<md5_state_st>())).Nh as *const _ as usize },
+        20usize,
+        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(Nh))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<md5_state_st>())).data as *const _ as usize },
+        24usize,
+        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(data))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<md5_state_st>())).num as *const _ as usize },
+        88usize,
+        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(num))
+    );
+}
+extern "C" {
+    pub fn CRYPTO_memcmp(
+        a: *const ::std::os::raw::c_void,
+        b: *const ::std::os::raw::c_void,
+        len: size_t,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn RAND_bytes(buf: *mut u8, len: size_t) -> ::std::os::raw::c_int;
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct rc4_key_st {
+    pub x: u32,
+    pub y: u32,
+    pub data: [u32; 256usize],
+}
+#[test]
+fn bindgen_test_layout_rc4_key_st() {
+    assert_eq!(
+        ::std::mem::size_of::<rc4_key_st>(),
+        1032usize,
+        concat!("Size of: ", stringify!(rc4_key_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<rc4_key_st>(),
+        4usize,
+        concat!("Alignment of ", stringify!(rc4_key_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rc4_key_st>())).x as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(rc4_key_st), "::", stringify!(x))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rc4_key_st>())).y as *const _ as usize },
+        4usize,
+        concat!("Offset of field: ", stringify!(rc4_key_st), "::", stringify!(y))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rc4_key_st>())).data as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(rc4_key_st), "::", stringify!(data))
+    );
+}
+extern "C" {
+    pub fn RC4_set_key(rc4key: *mut RC4_KEY, len: ::std::os::raw::c_uint, key: *const u8);
+}
+extern "C" {
+    pub fn RC4(key: *mut RC4_KEY, len: size_t, in_: *const u8, out: *mut u8);
+}
+extern "C" {
+    pub fn RSA_new() -> *mut RSA;
+}
+extern "C" {
+    pub fn RSA_free(rsa: *mut RSA);
+}
+extern "C" {
+    pub fn RSA_up_ref(rsa: *mut RSA) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn RSA_bits(rsa: *const RSA) -> ::std::os::raw::c_uint;
+}
+extern "C" {
+    pub fn RSA_get0_n(rsa: *const RSA) -> *const BIGNUM;
+}
+extern "C" {
+    pub fn RSA_get0_e(rsa: *const RSA) -> *const BIGNUM;
+}
+extern "C" {
+    pub fn RSA_generate_key_ex(
+        rsa: *mut RSA,
+        bits: ::std::os::raw::c_int,
+        e: *const BIGNUM,
+        cb: *mut BN_GENCB,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn RSA_sign(
+        hash_nid: ::std::os::raw::c_int,
+        in_: *const u8,
+        in_len: ::std::os::raw::c_uint,
+        out: *mut u8,
+        out_len: *mut ::std::os::raw::c_uint,
+        rsa: *mut RSA,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn RSA_sign_pss_mgf1(
+        rsa: *mut RSA,
+        out_len: *mut size_t,
+        out: *mut u8,
+        max_out: size_t,
+        in_: *const u8,
+        in_len: size_t,
+        md: *const EVP_MD,
+        mgf1_md: *const EVP_MD,
+        salt_len: ::std::os::raw::c_int,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn RSA_verify(
+        hash_nid: ::std::os::raw::c_int,
+        msg: *const u8,
+        msg_len: size_t,
+        sig: *const u8,
+        sig_len: size_t,
+        rsa: *mut RSA,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn RSA_verify_pss_mgf1(
+        rsa: *mut RSA,
+        msg: *const u8,
+        msg_len: size_t,
+        md: *const EVP_MD,
+        mgf1_md: *const EVP_MD,
+        salt_len: ::std::os::raw::c_int,
+        sig: *const u8,
+        sig_len: size_t,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn RSA_size(rsa: *const RSA) -> ::std::os::raw::c_uint;
+}
+extern "C" {
+    pub fn RSA_parse_private_key(cbs: *mut CBS) -> *mut RSA;
+}
+extern "C" {
+    pub fn RSA_marshal_private_key(cbb: *mut CBB, rsa: *const RSA) -> ::std::os::raw::c_int;
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct rsa_meth_st {
+    pub common: openssl_method_common_st,
+    pub app_data: *mut ::std::os::raw::c_void,
+    pub init: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
+    pub finish: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
+    pub size: ::std::option::Option<unsafe extern "C" fn(rsa: *const RSA) -> size_t>,
+    pub sign: ::std::option::Option<
+        unsafe extern "C" fn(
+            type_: ::std::os::raw::c_int,
+            m: *const u8,
+            m_length: ::std::os::raw::c_uint,
+            sigret: *mut u8,
+            siglen: *mut ::std::os::raw::c_uint,
+            rsa: *const RSA,
+        ) -> ::std::os::raw::c_int,
+    >,
+    pub sign_raw: ::std::option::Option<
+        unsafe extern "C" fn(
+            rsa: *mut RSA,
+            out_len: *mut size_t,
+            out: *mut u8,
+            max_out: size_t,
+            in_: *const u8,
+            in_len: size_t,
+            padding: ::std::os::raw::c_int,
+        ) -> ::std::os::raw::c_int,
+    >,
+    pub decrypt: ::std::option::Option<
+        unsafe extern "C" fn(
+            rsa: *mut RSA,
+            out_len: *mut size_t,
+            out: *mut u8,
+            max_out: size_t,
+            in_: *const u8,
+            in_len: size_t,
+            padding: ::std::os::raw::c_int,
+        ) -> ::std::os::raw::c_int,
+    >,
+    pub private_transform: ::std::option::Option<
+        unsafe extern "C" fn(
+            rsa: *mut RSA,
+            out: *mut u8,
+            in_: *const u8,
+            len: size_t,
+        ) -> ::std::os::raw::c_int,
+    >,
+    pub flags: ::std::os::raw::c_int,
+}
+#[test]
+fn bindgen_test_layout_rsa_meth_st() {
+    assert_eq!(
+        ::std::mem::size_of::<rsa_meth_st>(),
+        80usize,
+        concat!("Size of: ", stringify!(rsa_meth_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<rsa_meth_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(rsa_meth_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).common as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(common))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).app_data as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(app_data))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).init as *const _ as usize },
+        16usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(init))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).finish as *const _ as usize },
+        24usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(finish))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).size as *const _ as usize },
+        32usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(size))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).sign as *const _ as usize },
+        40usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(sign))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).sign_raw as *const _ as usize },
+        48usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(sign_raw))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).decrypt as *const _ as usize },
+        56usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(decrypt))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).private_transform as *const _ as usize },
+        64usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(private_transform))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).flags as *const _ as usize },
+        72usize,
+        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(flags))
+    );
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct bn_blinding_st {
+    _unused: [u8; 0],
+}
+pub type BN_BLINDING = bn_blinding_st;
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub struct rsa_st {
+    pub meth: *mut RSA_METHOD,
+    pub n: *mut BIGNUM,
+    pub e: *mut BIGNUM,
+    pub d: *mut BIGNUM,
+    pub p: *mut BIGNUM,
+    pub q: *mut BIGNUM,
+    pub dmp1: *mut BIGNUM,
+    pub dmq1: *mut BIGNUM,
+    pub iqmp: *mut BIGNUM,
+    pub ex_data: CRYPTO_EX_DATA,
+    pub references: CRYPTO_refcount_t,
+    pub flags: ::std::os::raw::c_int,
+    pub lock: CRYPTO_MUTEX,
+    pub mont_n: *mut BN_MONT_CTX,
+    pub mont_p: *mut BN_MONT_CTX,
+    pub mont_q: *mut BN_MONT_CTX,
+    pub d_fixed: *mut BIGNUM,
+    pub dmp1_fixed: *mut BIGNUM,
+    pub dmq1_fixed: *mut BIGNUM,
+    pub inv_small_mod_large_mont: *mut BIGNUM,
+    pub num_blindings: ::std::os::raw::c_uint,
+    pub blindings: *mut *mut BN_BLINDING,
+    pub blindings_inuse: *mut ::std::os::raw::c_uchar,
+    pub blinding_fork_generation: u64,
+    pub _bitfield_align_1: [u8; 0],
+    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
+    pub __bindgen_padding_0: [u8; 7usize],
+}
+#[test]
+fn bindgen_test_layout_rsa_st() {
+    assert_eq!(::std::mem::size_of::<rsa_st>(), 240usize, concat!("Size of: ", stringify!(rsa_st)));
+    assert_eq!(
+        ::std::mem::align_of::<rsa_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(rsa_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).meth as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(meth))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).n as *const _ as usize },
+        8usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(n))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).e as *const _ as usize },
+        16usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(e))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).d as *const _ as usize },
+        24usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(d))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).p as *const _ as usize },
+        32usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(p))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).q as *const _ as usize },
+        40usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(q))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmp1 as *const _ as usize },
+        48usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmp1))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmq1 as *const _ as usize },
+        56usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmq1))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).iqmp as *const _ as usize },
+        64usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(iqmp))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).ex_data as *const _ as usize },
+        72usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(ex_data))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).references as *const _ as usize },
+        80usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(references))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).flags as *const _ as usize },
+        84usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(flags))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).lock as *const _ as usize },
+        88usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(lock))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).mont_n as *const _ as usize },
+        144usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(mont_n))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).mont_p as *const _ as usize },
+        152usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(mont_p))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).mont_q as *const _ as usize },
+        160usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(mont_q))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).d_fixed as *const _ as usize },
+        168usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(d_fixed))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmp1_fixed as *const _ as usize },
+        176usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmp1_fixed))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmq1_fixed as *const _ as usize },
+        184usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmq1_fixed))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).inv_small_mod_large_mont as *const _ as usize },
+        192usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(rsa_st),
+            "::",
+            stringify!(inv_small_mod_large_mont)
+        )
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).num_blindings as *const _ as usize },
+        200usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(num_blindings))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).blindings as *const _ as usize },
+        208usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(blindings))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).blindings_inuse as *const _ as usize },
+        216usize,
+        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(blindings_inuse))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<rsa_st>())).blinding_fork_generation as *const _ as usize },
+        224usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(rsa_st),
+            "::",
+            stringify!(blinding_fork_generation)
+        )
+    );
+}
+impl rsa_st {
+    #[inline]
+    pub fn private_key_frozen(&self) -> ::std::os::raw::c_uint {
+        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
+    }
+    #[inline]
+    pub fn set_private_key_frozen(&mut self, val: ::std::os::raw::c_uint) {
+        unsafe {
+            let val: u32 = ::std::mem::transmute(val);
+            self._bitfield_1.set(0usize, 1u8, val as u64)
+        }
+    }
+    #[inline]
+    pub fn new_bitfield_1(
+        private_key_frozen: ::std::os::raw::c_uint,
+    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
+        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
+        __bindgen_bitfield_unit.set(0usize, 1u8, {
+            let private_key_frozen: u32 = unsafe { ::std::mem::transmute(private_key_frozen) };
+            private_key_frozen as u64
+        });
+        __bindgen_bitfield_unit
+    }
+}
+extern "C" {
+    pub fn SHA1_Init(sha: *mut SHA_CTX) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn SHA1_Update(
+        sha: *mut SHA_CTX,
+        data: *const ::std::os::raw::c_void,
+        len: size_t,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn SHA1_Final(out: *mut u8, sha: *mut SHA_CTX) -> ::std::os::raw::c_int;
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub struct sha_state_st {
+    pub __bindgen_anon_1: sha_state_st__bindgen_ty_1,
+    pub Nl: u32,
+    pub Nh: u32,
+    pub data: [u8; 64usize],
+    pub num: ::std::os::raw::c_uint,
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+pub union sha_state_st__bindgen_ty_1 {
+    pub h: [u32; 5usize],
+    pub __bindgen_anon_1: sha_state_st__bindgen_ty_1__bindgen_ty_1,
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct sha_state_st__bindgen_ty_1__bindgen_ty_1 {
+    pub h0: u32,
+    pub h1: u32,
+    pub h2: u32,
+    pub h3: u32,
+    pub h4: u32,
+}
+#[test]
+fn bindgen_test_layout_sha_state_st__bindgen_ty_1__bindgen_ty_1() {
+    assert_eq!(
+        ::std::mem::size_of::<sha_state_st__bindgen_ty_1__bindgen_ty_1>(),
+        20usize,
+        concat!("Size of: ", stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<sha_state_st__bindgen_ty_1__bindgen_ty_1>(),
+        4usize,
+        concat!("Alignment of ", stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1))
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h0 as *const _
+                as usize
+        },
+        0usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
+            "::",
+            stringify!(h0)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h1 as *const _
+                as usize
+        },
+        4usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
+            "::",
+            stringify!(h1)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h2 as *const _
+                as usize
+        },
+        8usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
+            "::",
+            stringify!(h2)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h3 as *const _
+                as usize
+        },
+        12usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
+            "::",
+            stringify!(h3)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h4 as *const _
+                as usize
+        },
+        16usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
+            "::",
+            stringify!(h4)
+        )
+    );
+}
+#[test]
+fn bindgen_test_layout_sha_state_st__bindgen_ty_1() {
+    assert_eq!(
+        ::std::mem::size_of::<sha_state_st__bindgen_ty_1>(),
+        20usize,
+        concat!("Size of: ", stringify!(sha_state_st__bindgen_ty_1))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<sha_state_st__bindgen_ty_1>(),
+        4usize,
+        concat!("Alignment of ", stringify!(sha_state_st__bindgen_ty_1))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1>())).h as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(sha_state_st__bindgen_ty_1), "::", stringify!(h))
+    );
+}
+#[test]
+fn bindgen_test_layout_sha_state_st() {
+    assert_eq!(
+        ::std::mem::size_of::<sha_state_st>(),
+        96usize,
+        concat!("Size of: ", stringify!(sha_state_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<sha_state_st>(),
+        4usize,
+        concat!("Alignment of ", stringify!(sha_state_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha_state_st>())).Nl as *const _ as usize },
+        20usize,
+        concat!("Offset of field: ", stringify!(sha_state_st), "::", stringify!(Nl))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha_state_st>())).Nh as *const _ as usize },
+        24usize,
+        concat!("Offset of field: ", stringify!(sha_state_st), "::", stringify!(Nh))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha_state_st>())).data as *const _ as usize },
+        28usize,
+        concat!("Offset of field: ", stringify!(sha_state_st), "::", stringify!(data))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha_state_st>())).num as *const _ as usize },
+        92usize,
+        concat!("Offset of field: ", stringify!(sha_state_st), "::", stringify!(num))
+    );
+}
+extern "C" {
+    pub fn SHA256_Init(sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn SHA256_Update(
+        sha: *mut SHA256_CTX,
+        data: *const ::std::os::raw::c_void,
+        len: size_t,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn SHA256_Final(out: *mut u8, sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct sha256_state_st {
+    pub h: [u32; 8usize],
+    pub Nl: u32,
+    pub Nh: u32,
+    pub data: [u8; 64usize],
+    pub num: ::std::os::raw::c_uint,
+    pub md_len: ::std::os::raw::c_uint,
+}
+#[test]
+fn bindgen_test_layout_sha256_state_st() {
+    assert_eq!(
+        ::std::mem::size_of::<sha256_state_st>(),
+        112usize,
+        concat!("Size of: ", stringify!(sha256_state_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<sha256_state_st>(),
+        4usize,
+        concat!("Alignment of ", stringify!(sha256_state_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).h as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(h))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).Nl as *const _ as usize },
+        32usize,
+        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(Nl))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).Nh as *const _ as usize },
+        36usize,
+        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(Nh))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).data as *const _ as usize },
+        40usize,
+        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(data))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).num as *const _ as usize },
+        104usize,
+        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(num))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).md_len as *const _ as usize },
+        108usize,
+        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(md_len))
+    );
+}
+extern "C" {
+    pub fn SHA384_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn SHA384_Update(
+        sha: *mut SHA512_CTX,
+        data: *const ::std::os::raw::c_void,
+        len: size_t,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn SHA384_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn SHA512_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn SHA512_Update(
+        sha: *mut SHA512_CTX,
+        data: *const ::std::os::raw::c_void,
+        len: size_t,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn SHA512_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct sha512_state_st {
+    pub h: [u64; 8usize],
+    pub Nl: u64,
+    pub Nh: u64,
+    pub p: [u8; 128usize],
+    pub num: ::std::os::raw::c_uint,
+    pub md_len: ::std::os::raw::c_uint,
+}
+#[test]
+fn bindgen_test_layout_sha512_state_st() {
+    assert_eq!(
+        ::std::mem::size_of::<sha512_state_st>(),
+        216usize,
+        concat!("Size of: ", stringify!(sha512_state_st))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<sha512_state_st>(),
+        8usize,
+        concat!("Alignment of ", stringify!(sha512_state_st))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).h as *const _ as usize },
+        0usize,
+        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(h))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).Nl as *const _ as usize },
+        64usize,
+        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(Nl))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).Nh as *const _ as usize },
+        72usize,
+        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(Nh))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).p as *const _ as usize },
+        80usize,
+        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(p))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).num as *const _ as usize },
+        208usize,
+        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(num))
+    );
+    assert_eq!(
+        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).md_len as *const _ as usize },
+        212usize,
+        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(md_len))
+    );
+}
diff --git a/src/boringssl/mod.rs b/src/boringssl/mod.rs
index 18e69b9..272d990 100644
--- a/src/boringssl/mod.rs
+++ b/src/boringssl/mod.rs
@@ -74,8 +74,13 @@
 // NOTE(joshlf): It's important to define this module before the abort module,
 // or else all of the assertions that are auto-generated by bindgen would result
 // in compilation errors.
-#[path = "../../boringssl/boringssl.rs"]
+#[cfg(not(feature = "bazel_build"))]
+#[path = "../../boringssl/boringssl_with_renames.rs"]
 mod ffi;
+#[cfg(feature = "bazel_build")]
+#[path = "../../boringssl/boringssl_without_renames.rs"]
+mod ffi;
+
 #[macro_use]
 mod abort;
 #[macro_use]
