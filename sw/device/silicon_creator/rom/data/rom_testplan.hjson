// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

{
  name: "rom"

  testpoints: [
    {
      name: rom_e2e_shutdown_output
      desc: '''Verify that ROM can properly report errors over UART.

            - Attempt to boot without a valid ROM_EXT.
            - Verify that we can receive the 28 character long (`LCV:xxxxxxxx\r\nBFV:xxxxxxxx\r\n`) error
              output in all life cycle states where Ibex is enabled, i.e. TEST_UNLOCKED*, PROD,
              PROD_END, DEV, and RMA.
                - BFV should be 0142500d for all life cycle states.
                - See the table below for the expected LCV value.

            | LC State |     LCV    | OTP LIFE_CYCLE state | OTP LIFE_CYCLE count |
            |:--------:|:----------:|:--------------------:|:--------------------:|
            |   TEST   | 0x02108421 |   "TEST_UNLOCKED0"   |           5          |
            |   DEV    | 0x21084210 |        "DEV"         |           5          |
            |   PROD   | 0x2318c631 |        "PROD"        |           5          |
            | PROD_END | 0x25294a52 |      "PROD_END"      |           5          |
            |   RMA    | 0x2739ce73 |        "RMA"         |           5          |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_shutdown_redact
      desc: '''Verify that ROM redacts errors properly.

            - Attempt to boot without a valid ROM_EXT.
            - Verify that there is no redaction in TEST_UNLOCKED* and RMA.
            - For DEV, PROD, and PROD_END:
              - Verify that BFV value is redacted according to the ROM_ERROR_REPORTING OTP item.

            | OTP ROM_ERROR_REPORTING |    BFV   |
            |:-----------------------:|:--------:|
            |   0xe2290aa5 (None)     | 0142500d |
            |   0x3367d3d4 (Error)    | 0042500d |
            |   0x1e791123 (Module)   | 0100000d |
            |   0x48eb4bd9 (All)      | ffffffff |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_shutdown_watchdog
      desc: '''Verify that ROM configures the watchdog properly.

            - Attempt to boot with a valid ROM_EXT.
              - ROM_EXT needs to print something and busy loop (bounded) until watchdog resets the
                chip.
            - Verify that the chip does not reset in TEST and RMA.
            - For DEV, PROD, and PROD_END:
              - Verify that the chip resets when the `WATCHDOG_BITE_THRESHOLD_CYCLES` OTP item is
               `0x00061a80` (2 s).
              - Verify that watchdog is disabled when `WATCHDOG_BITE_THRESHOLD_CYCLES` is `0`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: ["rom_e2e_shutdown_watchdog"]
    }

    {
      name: rom_e2e_shutdown_exception_asm
      desc: '''Verify that ROM asm exception handler resets the chip.

            - Power on with the `CREATOR_SW_CFG_ROM_EXEC_EN` OTP item set to `0`.
              - Execution should halt very early in `_rom_start_boot`.
            - Connect the debugger and set a breakpoint at `_asm_exception_handler`.
              - Note: We need to use a debugger for this test since `mtvec` points to C handlers
                when `rom_main()` starts executing.
            - Set `pc` to `0x10000000` (start of main SRAM) and execute one machine instruction,
              i.e. `stepi`.
            - Verify that execution stops at `_asm_exception_handler` since code execution from SRAM is
              not enabled.
            - Continue and verify that the asm exception handler resets the chip by confirming that
              execution halts at `_rom_start_boot`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_shutdown_exception_c
      desc: '''Verify that ROM C exception handler triggers shutdown.

            - Boot a valid _fake_ ROM_EXT that doesn't register any interrupt handlers.
            - Trigger an exception in the second stage.
              - Set `pc` to `0x10000000` (start of main SRAM). This should trigger an exception
                since code execution from SRAM is not enabled.
            - Verify that the chip resets with the correct `BFV`: `01495202`, i.e. instruction
              access fault in the interrupt module.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_shutdown_alert_config
      desc: '''Verify that alerts trigger a chip reset when enabled.

            - For PROD, PROD_END, DEV, and RMA life cycle states
              - Use an OTP image with an alert enabled.
            - Boot a ROM_EXT that triggers this alert by writing to a ALERT_TEST register.
            - Verify that ROM_EXT boots and the chip resets after the write to the ALERT_TEST
              register.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_enabled_requested
      desc: '''Verify that ROM enters bootstrap when enabled in OTP and requested.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping.
            - Reset the chip.
            - Verify that the chip responds to `READ_STATUS` (`0x05`) with `0x00`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_enabled_not_requested
      desc: '''Verify that ROM does not enter bootstrap when enabled in OTP but not requested.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Do not apply bootstrap pin strapping.
            - Reset the chip.
            - Verify that the chip outputs the expected `BFV`: `0142500d` over UART.
              - ROM will continously reset the chip and output the same `BFV`.
            - Verify that the chip does not respond to `READ_STATUS` (`0x05`).
              - The data on the CIPO line must be `0xff`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_disabled_requested
      desc: '''Verify that ROM does not enter bootstrap when disabled in OTP but requested.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolFalse` (`0x1d4`).

            - Apply bootstrap pin strapping.
            - Reset the chip.
            - Verify that the chip outputs the expected `BFV`: `0142500d` over UART.
              - ROM will continously reset the chip and output the same `BFV` and `LCV`.
            - Verify that the chip does not respond to `READ_STATUS` (`0x05`).
              - The data on the CIPO line must be `0xff`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_disabled_not_requested
      desc: '''Verify that ROM does not enter bootstrap when disabled in OTP and not requested.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolFalse` (`0x1d4`).

            - Do not apply bootstrap pin strapping.
            - Reset the chip.
            - Verify that the chip outputs the expected `BFV`: `0142500d` over UART.
              - ROM will continously reset the chip and output the same `BFV` and `LCV`.
            - Verify that the chip does not respond to `READ_STATUS` (`0x05`).
              - The data on the CIPO line must be `0xff`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_read_status
      desc: '''Verify that bootstrap handles `READ_STATUS` correctly.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping.
            - Reset the chip.
            - Verify that the chip responds to `READ_STATUS` (`0x05`) with `0x00`.

            See `rom_e2e_bootstrap_enabled_requested`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_watchdog_disabled
      desc: '''Verify that watchdog is disabled upon entering bootstrap.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).
            `OWNER_SW_CFG_ROM_WATCHDOG_BITE_THRESHOLD_CYCLES` OTP item must be `0x30d40`

            - For TEST, DEV, PROD, PROD_END, and RMA life cycle states:
              - Apply bootstrap pin strapping.
              - Reset the chip.
              - Verify that the chip responds to `READ_STATUS` (`0x05`) with `0x00`.
              - Release bootstrap pin strapping and wait for 2 seconds.
                - Note: Watchdog is always disabled in TEST and RMA. In other states, the threshold
                  is set to `OWNER_SW_CFG_ROM_WATCHDOG_BITE_THRESHOLD_CYCLES`.
              - Verify that the chip responds to `READ_STATUS` (`0x05`) with `0x00`.
              - Verify that there was no output from UART.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_read_id
      desc: '''Verify the JEDEC ID used during bootstrap.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping.
            - Reset the chip.
            - Verify that the chip responds to `READ_JEDEC_ID` (`0x9f`) with
              - 12 repetitions of the continuation code `0x7f`,
              - manufacturer ID `0xef`, and
              - density `0x14`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_read_sfdp
      desc: '''Verify the SFDP table used during bootstrap.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping.
            - Reset the chip.
            - Verify that the chip responds to `READ_SFDP` (`0x5a`).
            - Verify the SFDP header structure. See this
              [document](https://docs.google.com/document/d/1X_x7f62IrPeHRLGBzybhDu9TsvsSCb6_1uKOjQO_fI4/edit?resourcekey=0-vLsVqyrt1F2mGwLrz73uwA#heading=h.gc2hf662pvy9).
            - Verify the JEDEC Basic Flash Parameter Table. See this
              [spreadsheet](https://docs.google.com/spreadsheets/d/1cioU3HgsWZXD4-eoUiH9TuVLZeFpucSdjyq5HND-FpQ/edit#gid=0).
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_write_enable_disable
      desc: '''Verify that bootstrap handles `WRITE_ENABLE` (`0x06`) and `WRITE_DISABLE` (`0x04`).

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping.
            - Reset the chip.
            - Verify that the chip responds to `READ_STATUS` (`0x05`) with `0x00`.
            - Send `WRITE_ENABLE` (`0x06`) and `READ_STATUS` (`0x05`).
            - Verify that the chip responds with the `WEL` bit set, i.e. `0x02`.
            - Send `WRITE_DISABLE` (`0x04`) and `READ_STATUS` (`0x05`).
            - Verify that the chip responds with `0x00`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_phase1_reset
      desc: '''Verify that bootstrap phase 1 handles `RESET` (`0x99`) correctly.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping.
            - Reset the chip.
            - Verify that the chip responds to `READ_STATUS` (`0x05`) with `0x00`.
            - Send `RESET` (`0x99`).
            - Verify that the chip outputs the expected `BFV`: `0142500d` over UART.
              - ROM will continously reset the chip and output the same `BFV` and `LCV`.
            - Verify that the chip does not respond to `READ_STATUS` (`0x05`).
              - The data on the CIPO line must be `0xff`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_phase1_page_program
      desc: '''Verify that bootstrap phase 1 ignores `PAGE_PROGRAM` (`0x02`).

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping.
            - Reset the chip.
            - Write `0x4552544f` (ASCII "OTRE") at byte offset `0x334`.
            - Write `0x1` at byte offset `0x374`.
            - Reset the chip.
            - Verify that the chip outputs the expected `BFV`: `0142500d` over UART.
              - If the write succeeds, which shouldn't happen, ROM outputs `024d410d`
                (`kErrorManifestBadCodeRegion`).
              - ROM will continously reset the chip and output the same `BFV` and `LCV`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_phase1_erase
      desc: '''Verify that bootstrap phase 1 handles erase commands correctly.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - For `erase` in {`SECTOR_ERASE` (`0x20`), `CHIP_ERASE` (`0xc7`)}:
              - Apply bootstrap pin strapping and reset the chip.
              - Send `erase`.
              - Write `0x4552544f` (ASCII "OTRE") at byte offset `0x334`.
              - Write `0x1` at byte offset `0x374`.
              - Release pins and reset.
              - Verify that the chip outputs the expected `BFV`: `024d410d` over UART.
                - ROM will continously reset the chip and output the same `BFV` and `LCV`.
              - Apply bootstrap pin strapping and reset the chip.
              - Send `erase`.
              - Release pins and reset.
              - Verify that the chip outputs the expected `BFV`: `0142500d` over UART.
                - ROM will continously reset the chip and output the same `BFV` and `LCV`.

            Note: For additional coverage we can also add another test point that uses a test
            program on flash.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_phase1_read
      desc: '''Verify that phase 1 of bootstrap ignores `READ` (`0x03`).

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping and reset the chip.
            - Send `CHIP_ERASE` (`0xc7`).
            - Write `0x4552544f` (ASCII "OTRE") at byte offset `0x334`.
            - Reset the chip.
            - Verify that the chip outputs the expected `BFV`: `024d410d` over UART.
              - ROM will continously reset the chip and output the same `BFV` and `LCV`.
            - Apply bootstrap pin strapping and reset the chip.
            - Send `READ` (`0x03`) followed by the 3-byte address 0x000334.
              - This is the address of the identifier that was written earlier.
            - Verify that the chip does not respond for the next 4 bytes.
              - The data on the CIPO line must be `0xff`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_phase2_reset
      desc: '''Verify that bootstrap phase 2 handles `RESET` (`0x99`) correctly.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping and reset the chip.
            - Verify that the chip responds to `READ_STATUS` (`0x05`) with `0x00`.
            - Send `CHIP_ERASE` (`0xc7`).
              - This moves bootstrap to phase 2.
            - Release pins and send `RESET` (`0x99`).
            - Verify that the chip outputs the expected `BFV`: `0142500d` over UART.
              - ROM will continously reset the chip and output the same `BFV` and `LCV`.
            - Verify that the chip does not respond to `READ_STATUS` (`0x05`).
              - The data on the CIPO line must be `0xff`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_phase2_page_program
      desc: '''Verify that bootstrap phase 2 handles `PAGE_PROGRAM` (`0x02`) correctly.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping and reset the chip.
            - Send `erase`.
            - Write `0x4552544f` (ASCII "OTRE") at byte offset `0x334`.
            - Release pins and reset.
            - Verify that the chip outputs the expected `BFV`: `024d410d`
              (`kErrorManifestBadCodeRegion`) over UART.
              - ROM will continously reset the chip and output the same `BFV` and `LCV`.

            Note: For additional coverage we can also add another test point that uses a test
            program on flash that verifies that the rest of the flash is empty after bootstrap.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_phase2_erase
      desc: '''Verify that bootstrap phase 2 handles erase commands correctly.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - For `erase` in {`SECTOR_ERASE` (`0x20`), `CHIP_ERASE` (`0xc7`)}:
              - Apply bootstrap pin strapping and reset the chip.
              - Send `erase`.
              - Write `0x4552544f` (ASCII "OTRE") at byte offset `0x334`.
              - Write `0x1` at byte offset `0x374`.
              - Send `erase`.
              - Release pins and reset.
              - Verify that the chip outputs the expected `BFV`: `0142500d` over UART.
                - ROM will continously reset the chip and output the same `BFV` and `LCV`.

            Note: For additional coverage we can also add another test point that uses a test
            program on flash.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_phase2_read
      desc: '''Verify that phase 2 of bootstrap ignores `READ` (`0x03`).

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - Apply bootstrap pin strapping and reset the chip.
            - Send `CHIP_ERASE` (`0xc7`).
            - Write `0x4552544f` (ASCII "OTRE") at byte offset `0x334`.
            - Reset the chip.
            - Verify that the chip outputs the expected `BFV`: `024d410d` over UART.
              - ROM will continously reset the chip and output the same `BFV` and `LCV`.
            - Apply bootstrap pin strapping and reset the chip.
            - Send `READ` (`0x03`) followed by the 3-byte address 0x000334.
              - This is the address of the identifier that was written earlier.
            - Verify that the chip does not respond for the next 4 bytes.
              - The data on the CIPO line must be `0xff`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_bootstrap_shutdown
      desc: '''Verify that invalid addresses trigger shutdown.

            `OWNER_SW_CFG_ROM_BOOTSTRAP_EN` OTP item must be `kHardenedBoolTrue` (`0x739`).

            - For `command` in {`SECTOR_ERASE` (`0xc7`) and `PAGE_PROGRAM (`0x02`)}
              - Apply bootstrap pin strapping and reset the chip.
              - Send `command` with invalid 3-byte address, e.g. `0xffffff`.
              - Verify that the chip outputs the expected `BFV` over UART.
                - ROM will continously reset the chip and output the same `BFV` and `LCV`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_boot_policy_no_rom_ext
      desc: '''Verify that ROM triggers shutdown when there is no valid ROM_EXT.

            - Reset the chip.
            - Verify that the chip outputs the expected `BFV`: `0142500d ` over UART.
              - ROM will continously reset the chip and output the same `BFV` and `LCV`.
            - Repeat for all life cycle states: TEST, DEV, PROD, PROD_END, and RMA.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_boot_policy_newer
      desc: '''Verify that ROM chooses the slot with the greater security version.

            - Apply bootstrap pin strapping and reset the chip.
            - Write the ROM_EXT images to the chip.
            - Verify that ROM chooses the slot with the greater security version.
            - Repeat for all life cycle states: TEST, DEV, PROD, PROD_END, and RMA.

            | Slot a security version | Slot b security version | Chosen |
            |:-----------------------:|:-----------------------:|:------:|
            |            0            |             0           |   a    |
            |            0            |             1           |   b    |
            |            1            |             0           |   a    |
            |            1            |             1           |   a    |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_boot_policy_bad_manifest
      desc: '''Verify that ROM performs some basic checks on manifest fields.

            `CREATOR_SW_CFG_MIN_SEC_VER_ROM_EXT` OTP item should be 1, and
            `CREATOR_SW_CFG_DEFAULT_BOOT_DATA_IN_PROD` should be `kHardenedBoolTrue` for PROD and
            PROD_END for the sake of simplicity.


            - Write the image to the chip. See the table below.
              - The other slot remains empty.
            - Verify that the chip outputs the expected `BFV` over UART.
            - Repeat for all life cycle states: TEST, DEV, PROD, PROD_END, and RMA.

            | Slot |     Case                          |   `BFV`                         |
            |:----:|:---------------------------------:|:-------------------------------:|
            |   b  | `identitfier = 0`                 | `kErrorBootPolicyBadIdentifier` |
            |   b  | `length < CHIP_ROM_EXT_SIZE_MIN`  | `kErrorBootPolicyBadLength`     |
            |   b  | `length > CHIP_ROM_EXT_SIZE_MIN`  | `kErrorBootPolicyBadLength`     |
            |   b  | `code_start = code_end`           | `kErrorManifestBadCodeRegion`   |
            |   b  | `code_start < CHIP_MANIFEST_SIZE` | `kErrorManifestBadCodeRegion`   |
            |   b  | `code_end > length`               | `kErrorManifestBadCodeRegion`   |
            |   b  | `code_start` in range, unaligned  | `kErrorManifestBadCodeRegion`   |
            |   b  | `code_end` in range, unaligned    | `kErrorManifestBadCodeRegion`   |
            |   b  | `entry_point < code_start`        | `kErrorManifestBadCodeRegion`   |
            |   b  | `entry_point >= code_end`         | `kErrorManifestBadCodeRegion`   |
            |   b  | `entry_point` in range, unaligned | `kErrorManifestBadCodeRegion`   |
            |   b  | `security_version = 0`            | `kErrorBootPolicyRollback`      |
            |   a  | `identitfier = 0`                 | `0142500d`                      |
            |   a  | `length < CHIP_ROM_EXT_SIZE_MIN`  | `0142500d`                      |
            |   a  | `length > CHIP_ROM_EXT_SIZE_MIN`  | `0142500d`                      |
            |   a  | `code_start = code_end`           | `0142500d`                      |
            |   a  | `code_start < CHIP_MANIFEST_SIZE` | `0142500d`                      |
            |   a  | `code_end > length`               | `0142500d`                      |
            |   a  | `code_start` in range, unaligned  | `0142500d`                      |
            |   a  | `code_end` in range, unaligned    | `0142500d`                      |
            |   a  | `entry_point < code_start`        | `0142500d`                      |
            |   a  | `entry_point >= code_end`         | `0142500d`                      |
            |   a  | `entry_point` in range, unaligned | `0142500d`                      |
            |   a  | `security_version = 0`            | `0142500d`                      |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_boot_policy_valid
      desc: '''Verify that ROM chooses the slot with the valid signature.

            - Apply bootstrap pin strapping and reset the chip.
            - Write the ROM_EXT images to the chip -- same security_version.
            - Verify that ROM chooses the slot with the valid signature, otherwise triggers a
              shutdown.
            - Repeat for all life cycle states: TEST, DEV, PROD, PROD_END, and RMA.

            | Slot a | Slot b | Chosen |
            |:------:|:------:|:------:|
            |   Bad  |   Bad  |  None  |
            |   Bad  |  Good  |   b    |
            |  Good  |   Bad  |   a    |
            |  Good  |  Good  |   a    |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_boot_policy_rollback
      desc: '''Verify that ROM rejects rollbacks.

            `CREATOR_SW_CFG_MIN_SEC_VER_ROM_EXT` OTP item should be 1, and
            `CREATOR_SW_CFG_DEFAULT_BOOT_DATA_IN_PROD` should be `kHardenedBoolTrue` for PROD and
            PROD_END for the sake of simplicity.

            - Apply bootstrap pin strapping and reset the chip.
            - Write the ROM_EXT images to the chip -- valid signatures.
            - Verify that ROM chooses the slot with acceptable & newer seurity version, otherwise
              triggers a shutdown.
            - Repeat for all life cycle states: TEST, DEV, PROD, PROD_END, and RMA.

            | Slot a | Slot b | Chosen |
            |:------:|:------:|:------:|
            |    0   |    0   |  None  |
            |    0   |    1   |   b    |
            |    2   |    0   |   a    |
            |    1   |    1   |   a    |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_boot_data_recovery
      desc: '''Verify that ROM can use the default boot data when configured to do so.

            - Apply bootstrap pin strapping and reset the chip.
            - Write the ROM_EXT images to the chip -- valid signature, security version = 2.
            - Verify that ROM boots the slot when boot data is available.
            - Repeat for all life cycle states: TEST, DEV, PROD, PROD_END, and RMA.

            | LC State | CREATOR_SW_CFG_MIN_SEC_VER_ROM_EXT | CREATOR_SW_CFG_DEFAULT_BOOT_DATA_IN_PROD |
            |:--------:|:----------------------------------:|:----------------------------------------:|
            |   TEST   |                 0                  |            `kHardenedBoolFalse`          |
            |   DEV    |                 1                  |            `kHardenedBoolFalse`          |
            |   PROD   |                 1                  |            `kHardenedBoolTrue`           |
            |   PROD   |                 0                  |            `kHardenedBoolFalse` (error)  |
            | PROD_END |                 0                  |            `kHardenedBoolTrue`           |
            | PROD_END |                 1                  |            `kHardenedBoolFalse` (error)  |
            |   RMA    |                 0                  |            `kHardenedBoolFalse`          |

            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_sigverify_always
      desc: '''Verify that ROM performs signature verification in all life cycle states.

            - Prepare a ROM_EXT image with a valid signature generated using an authorized key.
            - Flip a bit/make all zeros/make all ones at random.
              - Log so that test can be reproduced.
            - Apply bootstrap pin strapping and reset the chip.
            - Load the image.
            - Verify that boot fails with the expected `BFV`: `kErrorSigverifyBadEncodedMessage`.
            - Repeat the steps above for TEST, DEV, PROD, PROD_END, and RMA.

            See `rom_e2e_boot_policy_valid`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_sigverify_key_auth
      desc: '''Verify that ROM only uses authorized keys for signature verification.

            - Prepare a ROM_EXT image with a valid signature generated using an unauthorized key.
            - Attempt to boot.
            - Verify that boot fails with `BFV:kErrorSigverifyBadKey`.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_sigverify_key_validity
      desc: '''Verify that ROM only uses authorized keys that are not invalidated.

            - For each key entry in `CREATOR_SW_CFG_KEY_IS_VALID`,
              - Invalidate the key by setting the entry to a value other than `kHardenedBoolTrue`.
              - Prepare a ROM_EXT image with a valid signature generated using the invalidated key.
              - Verify that boot fails with `BFV:kErrorSigverifyBadKey`

            | LC State | Allowed key types |
            |:--------:|:-----------------:|
            |   DEV    | Prod, Dev         |
            |   PROD   | Prod              |
            | PROD_END | Prod              |
            |   RMA    | Test, Prod        |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_sigverify_key_type
      desc: '''Verify that ROM only uses appropriate key types for each life cycle state.

            - For each life cycle state and key type,
              - Prepare a ROM_EXT image with a valid signature generated using a key of that type.
              - Verify that boot fails with `BFV:kErrorSigverifyBadKey` or succeeds depending on the
                life cycle state and key type. See the table below.

            | LC State | Allowed key types |
            |:--------:|:-----------------:|
            |   TEST   | Test, Prod        |
            |   DEV    | Prod, Dev         |
            |   PROD   | Prod              |
            | PROD_END | Prod              |
            |   RMA    | Test, Prod        |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_sigverify_mod_exp
      desc: '''Verify that ROM can verify signatures using both implementations of mod_exp.

            Note: The chip can be in any life cycle state except TEST since we use the software
            implementation without reading from the OTP in TEST.

            - Prepare a ROM_EXT image with a valid signature generated using an authorized key.
            - Apply bootstrap pin strapping and reset the chip and load the image.
            - Verify that boot succeeeds. Repeat with the following values:

            | `CREATOR_SW_CFG_USE_SW_RSA_VERIFY` | Result  |
            |:-----------------------------------:---------|
            | `kHardenedBoolTrue`                | Success |
            | `kHardenedBoolFalse`               | Success |
            | `0`                                | Failure |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_sigverify_usage_constraints
      desc: '''Verify that ROM enforces usage constraints.

            - Generate an otherwise valid ROM_EXT image for the following cases:
              - No constraints specified
              - Constrained to a specific device ID
                - Device ID matches
                - Device ID doesn't match
              - Constrained to a family of devices
                - Device ID matches
                - Device ID doesn't match
              - Constrained to TEST, DEV, PROD, PROD_END, RMA
                - Life cycle state matches
                - Life cycle state doesn't match
              - Constrained to a creator manufacturing state
                - `CREATOR_SW_CFG_MANUF_STATE` matches
                - `CREATOR_SW_CFG_MANUF_STATE` doesn't match
              - Constrained to an owner manufacturing state
                - `OWNER_SW_CFG_MANUF_STATE` matches
                - `OWNER_SW_CFG_MANUF_STATE` doesn't match
              - All constraints specified
              - Corrupt usage constraints data, e.g. wrong unselected word value.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    {
      name: rom_e2e_address_translation
      desc: '''Verify that all address translation configurations work

            - Bootstrap the chip with a valid second stage image. See the table below.
            - Verify that the chip behaves as expected.

            | Address translation | Image addr | Slot used | Error |
            |:-------------------:|:----------:|:---------:|:-----:|
            |         Off         |      A     |     A     |  No   |
            |         Off         |      B     |     B     |  No   |
            |         Off         |      A     |     B     |  Yes  |
            |         Off         |      B     |     A     |  Yes  |
            |         On          |   Virtual  |     A     |  No   |
            |         On          |   Virtual  |     B     |  No   |
            |         Invalid     |   Virtual  |     A     |  Yes  |
            |         Invalid     |   Virtual  |     B     |  Yes  |
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }


            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }

    // Upgrade
    {
      name: rom_e2e_upgradable
      desc: '''Verify that new firmware allows for upgrades.

            - Load new firmware of version N.
            - Attempt to upgrade to version N+1.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }
    {
      name: rom_e2e_upgrade_min_sec_version
      desc: '''Verify that ROM checks minimum security version before booting.

            - Load ROM_EXT that updates min_security_version past its own version.
            - Attempt to boot again.
            - Verify that the same ROM_EXT cannot be booted again.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }
    {
      name: rom_e2e_upgrade_power_loss
      desc: '''Verify that losing power during a ROM_EXT upgrade does not brick the chip.

            - Initiate a ROM_EXT update.
            - After the new ROM_EXT is loaded into flash, trigger a reset.
            - Verify that the chip can boot.
            '''
      tags: ["rom", "verilator", "dv", "fpga", "silicon"]
      milestone: V2
      tests: []
    }
    {
      name: rom_rv_dm_perform_debug
      desc: '''Verify that Ibex enters debug mode when triggered through JTAG

            This test must be run with ROM.  ROM is responsible for enabling debug ROM
            access and must be used to ensure the epmp configurations are done correctly.

            - X-ref'ed with chip_sw_sram_execution and populate a single "return" instruction into
              main SRAM at a fixed location (bottom of SRAM).
            - Execute a "wait_for_interrupt" in a wrapping function in the test, this causes Ibex
              to populate the return address and halt execution.
            - Trigger a debug request by programming `dmcontrol.haltreq` via JTAG.
            - Program the program buffer via JTAG with code to jump Ibex to the SRAM return
              instruction.
            - Verify that Ibex can fetch and execute the instructions from the SRAM correctly, Ibex
              should return to the code that originally invoked the wait_for_interrupt routine.
            - Release Ibex from halt via JTAG and allow the test to complete.
            - The test should also ensure that no other interrupts occur in the system.
            '''
      milestone: V2
      tests: []
    }
]
}
