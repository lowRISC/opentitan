// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#include "sw/device/lib/coverage/printer.h"

#include <stdint.h>

#include "sw/device/lib/base/crc32.h"
#include "sw/device/lib/base/macros.h"

enum {
  // SHA-1 build ID
  kBuildIdSize = 20,

  // File magic: \x81OTCove\xff
  kFileMagic = 0xff65766f43544f81ULL,
};

// symbols generated by linker.
extern char __llvm_prf_cnts_start[];
extern char __llvm_prf_cnts_end[];
extern char _build_id_start[];
extern char _build_id_end[];

#define BUILD_ID ((uint8_t *)_build_id_end - kBuildIdSize)

OT_SET_BSS_SECTION(
    "__ot_coverage_bss",

    /**
     * When the linker finds a definition of this symbol, it knows to skip
     * loading the object which contains the profiling runtime's static
     * initializer. See
     * https://clang.llvm.org/docs/SourceBasedCodeCoverage.html#using-the-profiling-runtime-without-static-initializers
     * for more information.
     */
    int __llvm_profile_runtime;

    /**
     * Stores the current coverage counters validity.
     *
     * The `coverage_status` field stores the `build_id` if the coverage report
     * is valid. It gets cleared when the coverage report is invalidated.
     */
    static uint32_t coverage_status;

    /**
     * Stores the CRC of the ongoing coverage report stream.
     */
    static uint32_t coverage_crc;

    /**
     * End of `__ot_coverage_bss` section.
     */
);

void coverage_printer_sink_with_crc(const void *buf, size_t size) {
  crc32_add(&coverage_crc, buf, size);
  coverage_printer_sink(buf, size);
}

void coverage_compress_rle(uint8_t tag, uint32_t size) {
  // assumption: the device is little-endian.
  uint32_t buf[2] = {0, size};
  if (size <= 0xfd) {
    //  00    XX
    // [tag][size]
    buf[0] = 0x00000000 | ((uint32_t)tag << 24);
    coverage_printer_sink_with_crc((uint8_t *)buf + 3, 2);
  } else if (size <= 0xffff) {
    //  00   fe  XXXX
    // [tag][fe][size]
    buf[0] = 0xfe000000 | ((uint32_t)tag << 16);
    coverage_printer_sink_with_crc((uint8_t *)buf + 2, 4);
  } else {
    //  00   ff  XXXXXX
    // [tag][ff][ size ]
    buf[0] = 0xff000000 | ((uint32_t)tag << 16);
    coverage_printer_sink_with_crc((uint8_t *)buf + 2, 5);
  }
}

void coverage_compress(unsigned char *data, size_t size) {
  size_t i = 0;

  // assumption: `coverage_is_valid` checks all bytes are either 0x00 or 0xff.
  while (i < size) {
    // Find next span.
    size_t start = i;
    uint8_t tag = data[i++];
    while (i < size && data[i] == tag)
      i++;
    size_t span_size = i - start;

    // Check for fast alternating sequence
    if (span_size < 8 && start + 8 <= size) {
      // Pack next 8 bits as one byte, 0x00 as bit 1, 0xff as bit 0.
      uint8_t packed_byte = 0;
      for (uint8_t k = 0; k < 8; ++k) {
        packed_byte |= ((data[start + k] + 1) << k);
      }
      coverage_printer_sink_with_crc(&packed_byte, 1);
      i = start + 8;
    } else {
      coverage_compress_rle(tag, span_size);
    }
  }
}

void coverage_init(void) {
  if (!coverage_is_valid()) {
    // The linker script ensure the prf cnts section is aligned to 4-byte
    // boundary.
    uint32_t *ptr = (uint32_t *)__llvm_prf_cnts_start;
    while (ptr < (uint32_t *)__llvm_prf_cnts_end) {
      *ptr++ = 0xffffffff;
    }

    // Set the report as valid.
    coverage_status = *(uint32_t *)BUILD_ID;
  }
}

void coverage_printer_run(void) {
  crc32_init(&coverage_crc);

  const uint64_t magic = kFileMagic;
  coverage_printer_sink_with_crc(&magic, sizeof(magic));
  coverage_printer_sink_with_crc((unsigned char *)BUILD_ID, kBuildIdSize);

  size_t cnts_size =
      (size_t)__llvm_prf_cnts_end - (size_t)__llvm_prf_cnts_start;
  uint8_t *cnts = (uint8_t *)__llvm_prf_cnts_start;
  coverage_compress(cnts, cnts_size);

  coverage_crc = crc32_finish(&coverage_crc);
  coverage_printer_sink(&coverage_crc, sizeof(coverage_crc));
}

void coverage_invalidate(void) { coverage_status = 0x42; }

bool coverage_is_valid(void) {
  if (coverage_status != *(uint32_t *)BUILD_ID) {
    return false;
  }

  // Ensures all coverage counters are either 0x00 or 0xff.
  uint8_t *ptr = (uint8_t *)__llvm_prf_cnts_start;
  while (ptr < (uint8_t *)__llvm_prf_cnts_end) {
    uint8_t counter = *ptr++;
    if (counter != 0x00 && counter != 0xff) {
      return false;
    }
  }

  return true;
}
