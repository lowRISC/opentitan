// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// AUTOGENERATED. Do not edit this file by hand.
// See the crypto/tests README for details.

#ifndef OPENTITAN_SW_DEVICE_TESTS_CRYPTO_HMAC_ALL_TESTVECTORS_H_
#define OPENTITAN_SW_DEVICE_TESTS_CRYPTO_HMAC_ALL_TESTVECTORS_H_

#include "sw/device/lib/crypto/drivers/kmac.h"
#include "sw/device/lib/crypto/include/mac.h"
#include "sw/device/lib/crypto/include/hash.h"


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

/**
 * Use the following enum to route a test vector to XOF, HASH or MAC
 * call through cryptolib API.
 */
typedef enum hmac_test_operation {
  kHmacTestOperationSha256,
  kHmacTestOperationSha384,
  kHmacTestOperationSha512,
  kHmacTestOperationHmacSha256,
  kHmacTestOperationHmacSha384,
  kHmacTestOperationHmacSha512,
} hmac_test_operation_t;

typedef struct hmac_test_vector {
  char* vector_identifier;
  hmac_test_operation_t test_operation;
  otcrypto_blinded_key_t key;
  otcrypto_const_byte_buf_t message;
  otcrypto_const_word32_buf_t digest;
} hmac_test_vector_t;

static hmac_test_vector_t kHmacTestVectors[${len(tests)}] = {
% for idx, t in enumerate(tests):
    {
        .vector_identifier = "${t["vector_identifier"]}",
        .test_operation = ${t["test_operation"]},
    % if "keyblob" in t:
        .key = {
            .config = {
                .version = kOtcryptoLibVersion1,
                .key_mode = ${t["key_mode"]},
                .key_length = ${t["key_len"]},
                .hw_backed = kHardenedBoolFalse,
                .exportable = kHardenedBoolFalse,
                .security_level = kOtcryptoKeySecurityLevelLow,
            },
            .keyblob_length = ${4 * len(t["keyblob"])},
            .keyblob = (uint32_t[]){
      % for i in range(0, len(t["keyblob"]), 4):
                ${', '.join(t["keyblob"][i:i + 4])},
      % endfor
            },
        },
    % endif
        .message = {
  % if len(t["message"]) != 0:
            .data = (uint8_t[]){
      % for i in range(0, len(t["message"]), 8):
                ${', '.join(t["message"][i:i + 8])},
      % endfor
            },
            .len = ${len(t["message"])},
  % else:
            .data = NULL,
            .len = 0,
  % endif
        },
    .digest = {
            .data = (uint32_t[]){
      % for i in range(0, len(t["digest"]), 4):
                ${', '.join(t["digest"][i:i + 4])},
      % endfor
            },
            .len = ${len(t["digest"])},
        },
    },
% endfor
};

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // OPENTITAN_SW_DEVICE_TESTS_CRYPTO_HMAC_ALL_TESTVECTORS_H_
