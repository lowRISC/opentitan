// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// AUTOGENERATED. Do not edit this file by hand.
// See the crypto/tests README for details.

#ifndef OPENTITAN_SW_DEVICE_TESTS_CRYPTO_KDF_TESTVECTORS_H_
#define OPENTITAN_SW_DEVICE_TESTS_CRYPTO_KDF_TESTVECTORS_H_

#include "sw/device/lib/crypto/drivers/kmac.h"
#include "sw/device/lib/crypto/include/mac.h"

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

/**
 * Use the following enum to route a test vector to XOF, HASH or MAC
 * call through cryptolib API.
 */
typedef enum kdf_test_operation_t {
  kKdfTestOperationKmac128,
  kKdfTestOperationKmac256,
} kdf_test_operation_t;

typedef struct kdf_test_vector {
  char* vector_identifier;
  kdf_test_operation_t test_operation;
  otcrypto_blinded_key_t key_derivation_key;
  otcrypto_const_byte_buf_t label;
  otcrypto_const_byte_buf_t context;
  otcrypto_blinded_key_t keying_material;
} kdf_kmac_test_vector_t;

static kdf_kmac_test_vector_t kKdfTestVectors[${len(tests)}] = {
% for idx, t in enumerate(tests):
    {
        .vector_identifier = "${t["vector_identifier"]}",
        .test_operation = ${t["test_operation"]},
        .key_derivation_key = {
            .config = {
                .key_mode = ${"kOtcryptoKeyModeKdfKmac" + str(t["security_str"])},
                .key_length = ${2 * len(t["keyblob"])},
                .hw_backed = kHardenedBoolFalse,
                .security_level = kOtcryptoKeySecurityLevelLow,
            },
            .keyblob_length = ${4 * len(t["keyblob"])},
            .keyblob = (uint32_t[]){
      % for i in range(0, len(t["keyblob"]), 4):
                ${', '.join(t["keyblob"][i:i + 4])},
      % endfor
            },
        },
        .context = {
  % if len(t["context"]) != 0:
            .data = (uint8_t[]){
      % for i in range(0, len(t["context"]), 8):
                ${', '.join(t["context"][i:i + 8])},
      % endfor
            },
            .len = ${len(t["context"])},
  % else:
            .data = NULL,
            .len = 0,
  % endif
        },
        .label = {
  % if len(t["label"]) > 0:
            .data = (uint8_t[]){
      % for i in range(0, len(t["label"]), 8):
                ${', '.join(t["label"][i:i + 8])},
      % endfor
            },
            .len = ${len(t["label"])},
  % else:
            .data = NULL,
            .len = 0,
  % endif
        },
        .keying_material = {
            .config = {
                .key_length = ${2 * len(t["km_keyblob"])},
                .hw_backed = kHardenedBoolFalse,
            },
            .keyblob_length = ${4 * len(t["km_keyblob"])},
            .keyblob = (uint32_t[]){
      % for i in range(0, len(t["km_keyblob"]), 4):
                ${', '.join(t["km_keyblob"][i:i + 4])},
      % endfor
            },
        },
    },
% endfor
};

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // OPENTITAN_SW_DEVICE_TESTS_CRYPTO_KDF_TESTVECTORS_H_
