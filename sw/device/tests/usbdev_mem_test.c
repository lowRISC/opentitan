// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// USB packet memory test
//
// This test performs a simple read/write test of the entire USB packet memory
// from the CPU to check connectivity, addressing, integrity etc. A LFSR-
// generated byte stream is used as the test pattern.
//
// Two methods of access are tested in turn:
// (i)  direct access using the mmio_ routines
// (ii) DIF-based buffer reading/writing

#include "sw/device/lib/dif/dif_pinmux.h"
#include "sw/device/lib/dif/dif_usbdev.h"
#include "sw/device/lib/runtime/log.h"
#include "sw/device/lib/runtime/print.h"
#include "sw/device/lib/testing/pinmux_testutils.h"
#include "sw/device/lib/testing/test_framework/check.h"
#include "sw/device/lib/testing/test_framework/ottf_main.h"

#include "hw/top_earlgrey/sw/autogen/top_earlgrey.h"  // Generated.
#include "sw/device/lib/dif/autogen/dif_usbdev_autogen.h"

#define USBDEV_BASE_ADDR TOP_EARLGREY_USBDEV_BASE_ADDR

#ifndef USBDEV_BUFFER_REG_OFFSET
#define USBDEV_BUFFER_REG_OFFSET 0x800u
#endif

// Simple LFSR for 8-bit sequences
/// Note: zero is an isolated state that shall be avoided
#define LFSR_ADVANCE(lfsr)     \
  (uint8_t)(                   \
      (uint8_t)((lfsr) << 1) ^ \
      ((((lfsr) >> 1) ^ ((lfsr) >> 2) ^ ((lfsr) >> 3) ^ ((lfsr) >> 7)) & 1U))

// Total size of packet buffer memory in bytes
#define USBDEV_PACKET_MEM_SIZE (USBDEV_NUM_BUFFERS * USBDEV_MAX_PACKET_SIZE)

// Basic test of packet memory function from the CPU side
static alignas(uint32_t) uint8_t testpatt[USBDEV_PACKET_MEM_SIZE];
static alignas(uint32_t) uint8_t testcopy[USBDEV_PACKET_MEM_SIZE];

static dif_usbdev_t usbdev;

OTTF_DEFINE_TEST_CONFIG();

/* The obvious advantage of using the DIF interface is that we are testing that
   code too, but the disadvantage is that we have to resort to modifying the
   buffer descriptors to perform reads because the buffers are not being used
   in accordance with the expected flow model.
*/

static status_t mem_dif_write(const dif_usbdev_t *dev, const uint8_t *data,
                              size_t n) {
  const unsigned nbufs =
      (n + USBDEV_MAX_PACKET_SIZE - 1) / USBDEV_MAX_PACKET_SIZE;
  TRY_CHECK(nbufs <= USBDEV_NUM_BUFFERS);

  for (unsigned id = 0u; id < nbufs; id++) {
    TRY(dif_usbdev_buffer_raw_write(dev, (uint8_t)id,
                                    &data[id * USBDEV_MAX_PACKET_SIZE],
                                    USBDEV_MAX_PACKET_SIZE));
  }

  return OK_STATUS();
}

static status_t mem_dif_read(const dif_usbdev_t *dev, uint8_t *data, size_t n) {
  const unsigned nbufs =
      (n + USBDEV_MAX_PACKET_SIZE - 1) / USBDEV_MAX_PACKET_SIZE;
  TRY_CHECK(nbufs <= USBDEV_NUM_BUFFERS);

  for (unsigned id = 0u; id < nbufs; id++) {
    TRY(dif_usbdev_buffer_raw_read(dev, (uint8_t)id,
                                   &data[id * USBDEV_MAX_PACKET_SIZE],
                                   USBDEV_MAX_PACKET_SIZE));
  }

  return OK_STATUS();
}

// Perform a read from the usbdev packet memory, optionally using the DIF
// interface
static status_t mem_read(const dif_usbdev_t *dev, unsigned use_dif,
                         uint8_t *data, size_t n) {
  if (use_dif) {
    return mem_dif_read(dev, data, n);
  } else {
    mmio_region_memcpy_from_mmio32(dev->base_addr, USBDEV_BUFFER_REG_OFFSET,
                                   data, n);
    return OK_STATUS();
  }
}

// Write a block of data to the usbdev packet memory, optionally using the DIF
// interface
static status_t mem_write(const dif_usbdev_t *dev, unsigned use_dif,
                          const uint8_t *data, size_t n) {
  if (use_dif) {
    return mem_dif_write(dev, data, n);
  } else {
    mmio_region_memcpy_to_mmio32(dev->base_addr, USBDEV_BUFFER_REG_OFFSET, data,
                                 n);
    return OK_STATUS();
  }
}

bool test_main(void) {
  LOG_INFO("Running USBDEV Mem Test");

  // Initialize DIF-based access to the packet buffer memory
  CHECK_DIF_OK(
      dif_usbdev_init(mmio_region_from_addr(USBDEV_BASE_ADDR), &usbdev));

  // Exercise mmio_ routines and then dif_usbdev_ routines in turn; it provides
  // a bit more testing of the packet memory because the two routines exhibit
  // different access patterns/timing.
  for (unsigned use_dif = 0u; use_dif <= 1u; use_dif++) {
    // Set up test pattern
    uint8_t lfsr = 0x13u;
    for (unsigned idx = 0u; idx < sizeof(testpatt); idx++) {
      testpatt[idx] = lfsr;
      lfsr = LFSR_ADVANCE(lfsr);
    }

    // Write the generated test pattern to the usbdev packet memory
    CHECK_STATUS_OK(mem_write(&usbdev, use_dif, testpatt, sizeof(testpatt)));

    // Invalidate the contents of the copy buffer
    memset(testcopy, 0xffu, sizeof(testcopy));

    // Read back a copy of the test pattern from the usbdev packet memory
    CHECK_STATUS_OK(
        mem_read(&usbdev, use_dif, testcopy, USBDEV_PACKET_MEM_SIZE));

    // Check the copy against the original
    CHECK_ARRAYS_EQ(testcopy, testpatt, sizeof(testcopy));

    for (unsigned idx = 0u; idx < sizeof(testpatt); idx++) {
      // Invert the test pattern to ensure every byte is modified
      testcopy[idx] = ~testcopy[idx];
    }

    // Write the modified test pattern to the device memory
    CHECK_STATUS_OK(mem_write(&usbdev, use_dif, testcopy, sizeof(testcopy)));

    // Invalidate the original test pattern buffer
    memset(testpatt, 0xffu, sizeof(testpatt));

    // Read back the modified test pattern from the device memory
    CHECK_STATUS_OK(mem_read(&usbdev, use_dif, testpatt, sizeof(testpatt)));

    // Check against the modified test pattern
    CHECK_ARRAYS_EQ(testpatt, testcopy, USBDEV_PACKET_MEM_SIZE);
  }

  return true;
}
